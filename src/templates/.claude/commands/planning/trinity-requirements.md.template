# Trinity Requirements Analysis - MON

**Command:** `/planning:trinity-requirements`
**Purpose:** Analyze requirements using MON (Requirements Analyst)
**Architecture:** MON requirements analysis → Scale determination → Acceptance criteria definition
**Trinity Version:** 2.0.9
**Last Updated:** 2026-01-12

**Agent:** MON (Requirements Analyst)
**Role:** Scale determination, acceptance criteria, and requirements documentation

## What MON Does

1. **Scale Determination:**
   - Analyzes task complexity
   - Counts affected files
   - Determines workflow (Small/Medium/Large)

2. **Requirements Documentation:**
   - Captures functional requirements
   - Defines acceptance criteria (testable)
   - Identifies constraints and dependencies

3. **Acceptance Criteria Format:**
   ```
   ✅ Given [context]
   ✅ When [action]
   ✅ Then [expected outcome]
   ```

4. **Risk Assessment:**
   - Breaking changes?
   - Dependencies affected?
   - Performance implications?

## Output Format

MON produces structured JSON handoff:
```json
{
  "scale": "Small|Medium|Large",
  "fileCount": <number>,
  "requirements": ["req1", "req2"],
  "acceptanceCriteria": ["✅ criterion 1", "✅ criterion 2"],
  "risks": ["risk1", "risk2"],
  "dependencies": ["dep1", "dep2"]
}
```

## MON Agent Capabilities

MON specializes in requirements analysis following Trinity principles:
- **Systematic Analysis:** Structured approach to capturing functional and non-functional requirements
- **Scale Determination:** Objective criteria for Small/Medium/Large classification
- **Acceptance Criteria:** Testable Given/When/Then format for clear validation
- **Risk Assessment:** Proactive identification of constraints and dependencies

## Integration with Trinity Workflow

MON's requirements analysis is the first phase in Trinity workflows:

1. **Investigation Start:** User describes task or investigation
2. **MON Analysis (Claude adopts MON persona):** Determines scale, documents requirements, identifies risks
3. **Scale-Based Workflow:** Small/Medium/Large determines next steps
4. **Phase 1 Output:** Requirements with acceptance criteria in JSON format
5. **Handoff to ROR:** Requirements feed into technical design phase

**Example in Large-scale workflow:**
```
Phase 1: Requirements Analysis
├── Analyze functional requirements
└── Analyze non-functional requirements

Output: JSON handoff with scale, requirements, acceptance criteria, risks
Next: ROR technical design phase
```

**See Also:** `/trinity-orchestrate` for complete workflow planning

## Quality Standards

MON follows Trinity quality standards for requirements:
- **Clear acceptance criteria:** Testable with Given/When/Then format
- **Risk identification:** Proactive constraint and dependency mapping
- **Scale determination:** Objective criteria (file count, complexity)
- **Structured handoff:** JSON format for downstream agents

## Usage

**Describe your task and Claude (as MON) will analyze requirements:**

What functionality needs to be implemented?

**For complete workflow planning:**

Use `/trinity-orchestrate` to plan your implementation approach with MON as the first phase

---

## Requirements Extraction Template

Use this template to extract requirements from user requests:

### 1. Functional Requirements
**What the system must do**:
- [ ] Requirement 1: [Action] when [condition]
- [ ] Requirement 2: [System] shall [capability]
- [ ] Requirement 3: [Feature] must support [scenario]

**Example**:
- [ ] System shall validate JWT tokens on every authenticated request
- [ ] Refresh endpoint must return new access token within 100ms
- [ ] Invalid tokens must return 401 Unauthorized with error message

### 2. Non-Functional Requirements
**How the system must perform**:
- **Performance**: Response time, throughput targets
- **Security**: Authentication, authorization, data protection
- **Scalability**: Concurrent users, data volume
- **Reliability**: Uptime, error handling
- **Maintainability**: Code quality, documentation

**Example**:
- Performance: Token refresh <100ms (p95)
- Security: HttpOnly cookies, HTTPS only
- Scalability: Support 10k concurrent sessions

### 3. Constraints & Assumptions
**Limitations and dependencies**:
- Technology constraints (must use X, cannot use Y)
- Timeline constraints
- Resource constraints
- Third-party dependencies
- Assumptions about user behavior

**Example**:
- Must use existing PostgreSQL database
- Cannot modify user table schema (constraint)
- Assume users refresh tokens before expiration (assumption)

### 4. Acceptance Criteria
**How to verify requirements are met**:
- Given [context], When [action], Then [expected outcome]

**Example**:
- Given valid refresh token, When POST /auth/refresh, Then return 200 with new tokens
- Given expired token, When POST /auth/refresh, Then return 401 with error
- Given invalid token, When POST /auth/refresh, Then return 401 and log attempt

---
