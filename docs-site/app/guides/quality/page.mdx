# Code Quality Investigation

Comprehensive code quality assessment covering maintainability, complexity, test coverage, and best practices using Trinity Method SDK.

## Overview

Code quality investigations evaluate codebase health, identify maintainability issues, assess test coverage, and provide actionable recommendations for improvement.

**Primary Agents**: JUNO (Quality Audit) + ZEN (Pattern Recognition)
**Supporting Agents**: TAN (Complexity Analysis)
**Duration**: 3-5 hours (medium codebase)
**Output**: Quality report, technical debt inventory, improvement recommendations

## What Gets Analyzed

### 1. Code Maintainability
- Cyclomatic complexity
- Code duplication
- Function/method length
- Nesting depth
- Naming conventions

### 2. Test Coverage
- Unit test coverage (lines, branches, functions)
- Integration test coverage
- E2E test coverage
- Test quality and assertions
- Untested critical paths

### 3. Code Standards
- Linting violations
- Formatting consistency
- TypeScript strictness
- Documentation coverage
- Error handling patterns

### 4. Technical Debt
- TODO/FIXME comments
- Deprecated API usage
- Security vulnerabilities
- Outdated dependencies
- Code smells

### 5. Best Practices
- SOLID principles adherence
- DRY (Don't Repeat Yourself)
- Error handling
- Logging and monitoring
- Type safety

## Investigation Setup

### Quick Start

```bash
# Create quality investigation
trinity wizard

# Follow prompts
? Investigation Type: Code Quality
? Scope: Entire codebase
? Focus Areas: [x] Maintainability
               [x] Test Coverage
               [x] Code Standards
               [x] Technical Debt
? Quality Threshold: High (80%+)
```

### Advanced Configuration

```bash
# Custom quality investigation
trinity create investigation \
  --type code-quality \
  --scope "src/**/*.ts" \
  --exclude "tests/**,build/**,node_modules/**" \
  --agents JUNO,ZEN,TAN \
  --thresholds "complexity:10,coverage:80,duplication:3"
```

### Investigation Plan

Generated plan structure:

```yaml
investigation:
  type: code-quality
  phases:
    - name: Discovery
      agents: [TAN, JUNO]
      tasks:
        - Scan codebase files
        - Run linters and formatters
        - Analyze test coverage
        - Identify technical debt markers

    - name: Analysis
      agents: [JUNO, ZEN]
      tasks:
        - Calculate complexity metrics
        - Detect code duplication
        - Assess test quality
        - Identify anti-patterns
        - Evaluate error handling

    - name: Recommendations
      agents: [JUNO, ZEN]
      tasks:
        - Prioritize quality issues
        - Generate refactoring suggestions
        - Create technical debt backlog
        - Provide improvement roadmap
```

## Execution Flow

### Phase 1: Discovery (TAN + JUNO)

**TAN** scans codebase:
```bash
trinity run INV-001 --phase discovery
```

Output:
```
🔍 Scanning Codebase (TAN)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✓ Files analyzed: 247
  - Source files: 156
  - Test files: 91
  - Config files: 12

✓ Lines of code: 42,318
  - Source: 28,456
  - Tests: 11,234
  - Comments: 2,628
```

**JUNO** runs quality checks:
```
🔬 Running Quality Checks (JUNO)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✓ Linting: 47 issues found
  - Errors: 8
  - Warnings: 39

✓ Test Coverage: 73.2%
  - Lines: 73.2%
  - Branches: 68.4%
  - Functions: 81.3%

✓ Technical Debt: 156 markers
  - TODO: 89
  - FIXME: 34
  - HACK: 18
  - XXX: 15
```

### Phase 2: Analysis (JUNO + ZEN)

**JUNO** calculates complexity:
```bash
trinity run INV-001 --phase analysis
```

Output:
```
📊 Complexity Analysis (JUNO)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✓ Cyclomatic Complexity:
  - Average: 8.2 (Good)
  - Max: 47 ⚠️ (src/utils/parser.ts:142)
  - Files > 10: 23 (14.7%)

✓ Function Length:
  - Average: 24 lines (Good)
  - Max: 342 lines ⚠️ (src/services/DataProcessor.ts:56)
  - Functions > 50 lines: 18 (11.5%)

✓ Nesting Depth:
  - Average: 2.3 (Good)
  - Max: 7 ⚠️ (src/controllers/ReportController.ts:89)
```

**ZEN** detects patterns:
```
🧩 Pattern Analysis (ZEN)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
✓ Code Duplication:
  - Duplicate blocks: 34
  - Duplication rate: 8.2% ⚠️
  - Largest duplicate: 67 lines

✓ Anti-Patterns:
  - Magic numbers: 156 occurrences
  - God classes: 4 identified
  - Long parameter lists: 23 functions
  - Feature envy: 12 cases

✓ Best Practice Violations:
  - Missing error handling: 45 functions
  - Inconsistent naming: 78 cases
  - Missing documentation: 134 functions
```

### Phase 3: Recommendations (JUNO + ZEN)

**JUNO** prioritizes issues:
```bash
trinity run INV-001 --phase recommendations
```

Output generates prioritized improvement list:

```
🎯 Quality Improvement Roadmap
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
HIGH PRIORITY (Impact: 🔴 High, Effort: Low)
1. Reduce complexity in parser.ts:142 (complexity: 47 → 10)
2. Split DataProcessor.ts:56 (342 lines → 4 functions)
3. Add error handling to 45 functions
4. Fix 8 linting errors

MEDIUM PRIORITY (Impact: 🟡 Medium, Effort: Medium)
5. Improve test coverage (73% → 80%)
6. Refactor 4 God classes
7. Eliminate 34 code duplications
8. Document 134 functions

LOW PRIORITY (Impact: 🟢 Low, Effort: High)
9. Replace 156 magic numbers with constants
10. Standardize naming conventions (78 cases)
```

## Example Investigation

### Finding #1: High Cyclomatic Complexity

**Severity**: 🔴 HIGH
**Location**: src/utils/parser.ts:142
**Metric**: Cyclomatic Complexity = 47 (threshold: 10)

#### Problem

```typescript
// ❌ Too complex (complexity: 47)
function parseInput(input: string, options: ParseOptions): ParsedResult {
  if (!input) {
    throw new Error('Input required');
  }

  if (options.type === 'json') {
    if (options.validate) {
      if (options.strict) {
        // ... 20 more nested if statements
      } else {
        // ... 15 more nested if statements
      }
    } else {
      // ... 12 more nested if statements
    }
  } else if (options.type === 'xml') {
    // ... 50 more lines
  } else if (options.type === 'csv') {
    // ... 40 more lines
  }

  // ... 200+ more lines of complex logic
}
```

#### Solution

```typescript
// ✅ Refactored (complexity: 3 per function)
interface Parser {
  parse(input: string, options: ParseOptions): ParsedResult;
}

class JsonParser implements Parser {
  parse(input: string, options: ParseOptions): ParsedResult {
    const validator = this.getValidator(options);
    return validator.validate(input);
  }

  private getValidator(options: ParseOptions): Validator {
    return options.strict ? new StrictValidator() : new RelaxedValidator();
  }
}

class XmlParser implements Parser {
  parse(input: string, options: ParseOptions): ParsedResult {
    // Simple, focused XML parsing logic
  }
}

class CsvParser implements Parser {
  parse(input: string, options: ParseOptions): ParsedResult {
    // Simple, focused CSV parsing logic
  }
}

// Factory pattern for parser selection
function parseInput(input: string, options: ParseOptions): ParsedResult {
  const parser = ParserFactory.create(options.type);
  return parser.parse(input, options);
}
```

#### Impact

- **Complexity**: 47 → 3 average per function (84% reduction)
- **Testability**: Can test each parser independently
- **Maintainability**: Each parser is < 50 lines, easy to understand

### Finding #2: Low Test Coverage

**Severity**: 🟡 MEDIUM
**Location**: src/services/PaymentService.ts
**Metric**: Coverage = 34% (threshold: 80%)

#### Problem

```typescript
// ❌ Untested critical payment logic
export class PaymentService {
  async processPayment(amount: number, card: CardInfo): Promise<PaymentResult> {
    // ⚠️ No tests for this critical path
    const validated = this.validateCard(card);
    if (!validated) {
      throw new PaymentError('Invalid card');
    }

    const charge = await this.gateway.charge(amount, card);
    await this.recordTransaction(charge);
    await this.sendReceipt(charge);

    return { success: true, transactionId: charge.id };
  }

  // ⚠️ No tests for error cases
  private async recordTransaction(charge: Charge): Promise<void> {
    // What if database fails?
    await this.db.insert('transactions', charge);
  }
}
```

#### Solution

```typescript
// ✅ Comprehensive test coverage
describe('PaymentService', () => {
  let service: PaymentService;
  let mockGateway: jest.Mocked<PaymentGateway>;
  let mockDb: jest.Mocked<Database>;

  beforeEach(() => {
    mockGateway = createMockGateway();
    mockDb = createMockDatabase();
    service = new PaymentService(mockGateway, mockDb);
  });

  describe('processPayment', () => {
    it('should successfully process valid payment', async () => {
      const result = await service.processPayment(100, validCard);
      expect(result.success).toBe(true);
      expect(mockGateway.charge).toHaveBeenCalledWith(100, validCard);
    });

    it('should reject invalid card', async () => {
      await expect(service.processPayment(100, invalidCard))
        .rejects.toThrow('Invalid card');
    });

    it('should handle gateway failures', async () => {
      mockGateway.charge.mockRejectedValue(new Error('Gateway timeout'));
      await expect(service.processPayment(100, validCard))
        .rejects.toThrow('Gateway timeout');
    });

    it('should rollback on transaction recording failure', async () => {
      mockDb.insert.mockRejectedValue(new Error('DB error'));
      await expect(service.processPayment(100, validCard))
        .rejects.toThrow('DB error');
      expect(mockGateway.refund).toHaveBeenCalled();
    });
  });
});
```

#### Impact

- **Coverage**: 34% → 92% (171% increase)
- **Bug Prevention**: Caught 3 error handling bugs before production
- **Confidence**: Safe to refactor payment logic

### Finding #3: Code Duplication

**Severity**: 🟡 MEDIUM
**Location**: Multiple files
**Metric**: 67-line duplicate block (3 occurrences)

#### Problem

```typescript
// ❌ Duplicated in UserController.ts, ProductController.ts, OrderController.ts
async function validateAndSanitize(input: any): Promise<SanitizedInput> {
  // Validation logic (67 lines)
  if (!input) {
    throw new ValidationError('Input required');
  }

  const sanitized = {
    ...input,
    // ... 60 lines of sanitization logic
  };

  return sanitized;
}
```

#### Solution

```typescript
// ✅ Extract to shared utility
// src/utils/validation.ts
export class InputValidator {
  static validateAndSanitize(input: any): SanitizedInput {
    if (!input) {
      throw new ValidationError('Input required');
    }

    return this.sanitize(input);
  }

  private static sanitize(input: any): SanitizedInput {
    // Centralized sanitization logic
    return {
      ...input,
      // ... sanitization
    };
  }
}

// Usage in controllers
import { InputValidator } from '@/utils/validation';

async createUser(input: UserInput) {
  const sanitized = InputValidator.validateAndSanitize(input);
  // ...
}
```

#### Impact

- **Duplication**: 67 lines × 3 = 201 lines → 67 lines (67% reduction)
- **Maintainability**: Single source of truth for validation
- **Consistency**: All controllers use same validation logic

### Finding #4: Missing Error Handling

**Severity**: 🔴 HIGH
**Location**: 45 functions across codebase
**Pattern**: Unhandled promise rejections

#### Problem

```typescript
// ❌ No error handling
async function fetchUserData(userId: string): Promise<User> {
  const response = await fetch(`/api/users/${userId}`);
  const data = await response.json();
  return data;
}

// ⚠️ What if network fails?
// ⚠️ What if response is not JSON?
// ⚠️ What if user doesn't exist?
```

#### Solution

```typescript
// ✅ Comprehensive error handling
async function fetchUserData(userId: string): Promise<User> {
  try {
    const response = await fetch(`/api/users/${userId}`);

    if (!response.ok) {
      if (response.status === 404) {
        throw new UserNotFoundError(userId);
      }
      throw new ApiError(`HTTP ${response.status}: ${response.statusText}`);
    }

    const data = await response.json();
    return this.validateUser(data);

  } catch (error) {
    if (error instanceof UserNotFoundError) {
      throw error; // Re-throw known errors
    }

    if (error instanceof SyntaxError) {
      throw new ApiError('Invalid JSON response from server');
    }

    // Network or other errors
    logger.error('Failed to fetch user data', { userId, error });
    throw new ApiError('Failed to fetch user data. Please try again.');
  }
}
```

#### Impact

- **Reliability**: Graceful error handling prevents crashes
- **User Experience**: Meaningful error messages
- **Debugging**: Proper logging for troubleshooting

## Advanced Techniques

### 1. Custom Quality Rules

Define project-specific quality rules:

```yaml
# trinity/config/quality-rules.yml
rules:
  complexity:
    cyclomatic: 10
    cognitive: 15
    nesting: 3

  coverage:
    lines: 80
    branches: 75
    functions: 85
    critical-paths: 100

  maintainability:
    function-length: 50
    file-length: 300
    parameter-count: 4
    duplication-threshold: 3

  standards:
    naming: camelCase
    documentation: required
    type-safety: strict
    error-handling: required
```

### 2. Quality Gates

Enforce quality standards in CI/CD:

```yaml
# .github/workflows/quality-gate.yml
name: Quality Gate

on: [pull_request]

jobs:
  quality:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Run Trinity Quality Check
        run: |
          trinity investigate quality --threshold high

      - name: Enforce Quality Gates
        run: |
          trinity quality-gate \
            --min-coverage 80 \
            --max-complexity 10 \
            --fail-on-violations
```

### 3. Quality Trends

Track quality metrics over time:

```bash
trinity metrics quality --history --export quality-trends.json
```

Output:
```json
{
  "trends": {
    "coverage": {
      "current": 82.3,
      "30daysAgo": 76.1,
      "trend": "improving",
      "changePercent": 8.1
    },
    "complexity": {
      "current": 8.2,
      "30daysAgo": 10.4,
      "trend": "improving",
      "changePercent": -21.2
    },
    "technicalDebt": {
      "current": 156,
      "30daysAgo": 203,
      "trend": "improving",
      "changePercent": -23.2
    }
  }
}
```

### 4. Automated Refactoring

Generate refactoring suggestions:

```bash
trinity suggest refactor --from-investigation INV-001 --auto-apply safe
```

Output applies safe refactorings:
```
✓ Replaced 156 magic numbers with constants
✓ Extracted 12 duplicate blocks to utilities
✓ Added error handling to 8 functions
✓ Applied consistent formatting to 47 files

⚠️ Manual review required:
- Complex function splits (3 cases)
- God class refactorings (4 cases)
```

## Best Practices

### 1. Incremental Improvement

Focus on high-impact areas first:

```bash
# Prioritize by impact and effort
trinity investigate quality --prioritize impact-vs-effort
```

### 2. Quality Budgets

Set and enforce quality budgets:

```typescript
// trinity/config/quality-budgets.yml
budgets:
  new-code:
    coverage: 90  # New code must have 90%+ coverage
    complexity: 8  # New functions max complexity 8

  existing-code:
    coverage: 80  # Gradually improve to 80%
    complexity: 10  # Gradually reduce to 10

  critical-paths:
    coverage: 100  # Payment, auth must be 100% tested
```

### 3. Regular Quality Audits

Schedule periodic quality checks:

```bash
# Weekly quick check
trinity investigate quality --quick --focus high-priority

# Monthly comprehensive audit
trinity investigate quality --comprehensive --track-trends
```

### 4. Team Quality Dashboards

Visualize quality metrics for team:

```bash
trinity dashboard quality --team --live
```

Shows real-time quality metrics, trends, and individual contributions.

## Troubleshooting

### Coverage Calculation Issues

Ensure test instrumentation is correct:

```json
// package.json
{
  "jest": {
    "collectCoverage": true,
    "coverageDirectory": "coverage",
    "coverageReporters": ["json", "lcov", "text", "html"],
    "collectCoverageFrom": [
      "src/**/*.ts",
      "!src/**/*.test.ts",
      "!src/**/*.spec.ts"
    ]
  }
}
```

### False Positive Complexity

Exclude generated or config files:

```yaml
# trinity/config/quality.yml
exclude:
  - "**/*.generated.ts"
  - "**/*.config.ts"
  - "**/migrations/**"
```

### Slow Quality Checks

Use incremental mode for large codebases:

```bash
# Only analyze changed files
trinity investigate quality --incremental --since origin/main
```

## Report Generation

Quality investigation generates:

### 1. Executive Summary

```markdown
# Code Quality Report

## Overall Health: B+ (82/100)

### Key Metrics
- Test Coverage: 73.2% (Target: 80%)
- Avg Complexity: 8.2 (Good)
- Technical Debt: 156 items (Medium)
- Code Duplication: 8.2% (Acceptable)

### Trend
📈 Improving (+12% from last month)
```

### 2. Detailed Analysis

Per-file quality scores and issues

### 3. Improvement Roadmap

Prioritized action items with effort estimates

### 4. Quality Dashboard

Interactive HTML dashboard with charts and drill-down

## Next Steps

Learn more:

- [Technical Debt Management](/guides/tech-debt) - Managing and reducing debt
- [Testing Strategies](/guides/testing) - Comprehensive testing guide
- [JUNO Agent](/agents/juno) - Quality audit capabilities
- [Analytics Dashboard](/api/analytics) - Quality metrics tracking

Or explore other investigation types:

- [Security Audit](/guides/security)
- [Performance Review](/guides/performance)
- [Architecture Analysis](/guides/architecture)
