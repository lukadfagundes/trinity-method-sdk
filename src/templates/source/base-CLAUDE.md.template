# CLAUDE.md - Technology-Specific Rules
## {{PROJECT_NAME}} - {{FRAMEWORK}} Implementation

**Framework:** {{FRAMEWORK}}
**Language:** {{TECH_STACK}}
**Source Directory:** {{SOURCE_DIR}}

---

## Technology Stack Behavioral Modifications

### Framework-Specific Requirements
- **Code Organization**: Follow {{FRAMEWORK}} project structure conventions
- **Dependency Management**: Use appropriate package manager for {{TECH_STACK}}
- **Module System**: Implement framework-specific module patterns
- **Performance Optimization**: Framework-specific performance best practices
- **Error Handling**: Implement framework error handling patterns

### Language-Specific Adaptations
- **Type Safety**: Use type systems where available (TypeScript, type hints, etc.)
- **Async Patterns**: Implement language-specific async/await patterns
- **Memory Management**: Follow memory management best practices
- **Concurrency**: Handle concurrent operations per language specifications

---

## Technology Debugging Standards

### Standard Debugging Framework
```javascript
// Generic debugging format - adapt to your language
const createDebugLogger = (moduleName) => {
    return {
        entry: (functionName, params) => {
            console.log(`[ENTRY] ${moduleName}.${functionName}`, {
                params: params,
                timestamp: new Date().toISOString(),
                module: moduleName,
                framework: '{{FRAMEWORK}}'
            });
        },
        exit: (functionName, result, startTime) => {
            console.log(`[EXIT] ${moduleName}.${functionName}`, {
                result: result,
                duration: Date.now() - startTime,
                timestamp: new Date().toISOString()
            });
        },
        error: (functionName, error, context) => {
            console.error(`[ERROR] ${moduleName}.${functionName}`, {
                error: error.message || error,
                context: context,
                timestamp: new Date().toISOString(),
                module: moduleName
            });
        }
    };
};
```

### Framework Event Debugging
```javascript
// Adapt to framework-specific event system
// Monitor framework lifecycle events
// Log framework warnings and errors
// Track performance metrics
```

---

## Performance Optimization Rules

### Performance Monitoring
```javascript
// Generic performance monitoring - adapt to language/framework
class PerformanceMonitor {
    static measure(name, operation) {
        const startTime = performance.now();

        try {
            const result = operation();
            const duration = performance.now() - startTime;

            console.log(`[PERF] ${name}`, {
                duration: duration,
                timestamp: new Date().toISOString()
            });

            return result;
        } catch (error) {
            console.error(`[PERF-ERROR] ${name}`, {
                error: error.message || error,
                duration: performance.now() - startTime
            });
            throw error;
        }
    }
}
```

### Framework Optimization Guidelines
- Implement lazy loading where appropriate
- Optimize asset loading and bundling
- Use framework-specific caching strategies
- Monitor and optimize rendering performance
- Implement pagination for large datasets

---

## Security Best Practices

### Input Validation
```javascript
// Input validation patterns
function validateInput(input, rules) {
    // Implement validation logic
    // Sanitize user input
    // Prevent injection attacks
    // Enforce type constraints
}
```

### Authentication & Authorization
- Implement secure authentication flows
- Use framework security middleware
- Validate permissions before operations
- Secure API endpoints and routes
- Handle sensitive data appropriately

### Data Protection
- Encrypt sensitive data at rest
- Use HTTPS for data in transit
- Implement secure session management
- Follow OWASP security guidelines
- Regular security audits

---

## Testing Requirements

### Unit Testing
```javascript
// Framework-specific testing patterns
describe('Component Tests', () => {
    it('should perform expected behavior', () => {
        // Test implementation
        // Use framework testing utilities
        // Assert expected outcomes
    });
});
```

### Integration Testing
- Test component interactions
- Verify data flow between modules
- Test external service integrations
- Validate error handling paths
- Performance testing under load

### Test Coverage Requirements
- Minimum 80% code coverage for critical paths
- 100% coverage for security-sensitive code
- Test edge cases and error conditions
- Document test scenarios
- Automated test execution in CI/CD

---

## Framework Best Practices

### Project Structure
```
{{SOURCE_DIR}}/
├── components/        # Reusable components
├── utils/            # Utility functions
├── services/         # Business logic
├── models/           # Data models
├── config/           # Configuration
└── tests/            # Test files
```

### Code Organization
- Follow framework conventions
- Separate concerns appropriately
- Use dependency injection
- Implement modular architecture
- Maintain clear file naming

### Documentation Standards
```javascript
/**
 * Function description
 * @param {Type} param - Parameter description
 * @returns {Type} Return value description
 * @throws {Error} Error conditions
 */
function documentedFunction(param) {
    // Implementation
}
```

---

## Error Handling Patterns

### Comprehensive Error Handling
```javascript
// Framework-specific error handling
async function safeOperation(operation, context) {
    try {
        return await operation();
    } catch (error) {
        console.error(`[ERROR] ${context}`, {
            error: error.message || error,
            stack: error.stack,
            context: context,
            timestamp: new Date().toISOString()
        });

        // Handle specific error types
        // Implement retry logic if appropriate
        // Log to error tracking service

        throw error;
    }
}
```

### Global Error Handlers
```javascript
// Implement framework-specific global error handlers
// Catch unhandled exceptions
// Log errors for debugging
// Graceful degradation
// User-friendly error messages
```

---

## Technology-Specific Command References

### Development Commands
```bash
# Framework-specific commands
# Start development server
# Run build process
# Execute tests
# Lint code
```

### Testing Commands
```bash
# Run test suite
# Generate coverage reports
# Run specific tests
# Watch mode for development
```

### Deployment Commands
```bash
# Build for production
# Deploy application
# Run migrations
# Health checks
```

---

## Component-Level Customizations

### State Management
- Implement framework-specific state patterns
- Use appropriate state management libraries
- Maintain predictable state updates
- Debug state changes effectively

### Data Flow
- Implement unidirectional data flow
- Use framework data binding
- Optimize data fetching
- Cache frequently accessed data

### UI/UX Patterns
- Follow framework UI conventions
- Implement responsive design
- Optimize user interactions
- Accessibility compliance

---

## Reference to Parent Context

This file extends the Trinity Method protocols defined in `../trinity/CLAUDE.md` and global requirements from `../CLAUDE.md`. Technology-specific implementations must comply with:

- Trinity Method investigation requirements
- Global performance baselines
- Quality gate standards
- Crisis management protocols

All {{FRAMEWORK}} code must implement the debugging frameworks, error handling patterns, and performance monitoring specified in this document.

---

**Technology Context**: {{FRAMEWORK}} ({{TECH_STACK}}) Implementation
**Parent References**:
- `../CLAUDE.md` - Global project requirements
- `../trinity/CLAUDE.md` - Trinity Method enforcement

**Last Updated**: {{CURRENT_DATE}}
**Trinity Version**: {{TRINITY_VERSION}}
