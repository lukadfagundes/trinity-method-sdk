# Trinity Documentation Generator (Orchestration Architecture)

**Command:** `/execution:trinity-docs`
**Purpose:** Generate comprehensive project documentation using multi-agent orchestration
**Architecture:** JUNO audit ‚Üí Parallel APO execution ‚Üí Verification
**Version:** 2.0.9

---

## Overview

This command uses **agent orchestration** to generate documentation:

1. **JUNO** audits codebase and creates documentation checklist report
2. **Three APO instances** execute in parallel, each handling one section:
   - APO-1: Architecture diagrams
   - APO-2: API documentation and guides
   - APO-3: Configuration files
3. **Verification** ensures all items from checklist were completed

**Key Benefits:**
- Each agent has clean, focused context (<100 lines of instructions)
- Parallel execution (3x faster)
- Quality gate upfront (JUNO validates before generation)
- No single agent reads massive command (prevents context fatigue)

---

## Phase 0: Preparation

Before invoking agents, set up the environment:

```javascript
// Global state tracking
global.trinity_docs_session = {
  started: new Date().toISOString(),
  audit_report: null,
  juno_incomplete: false,
  juno_issues: [],
  apo_results: {
    diagrams: null,
    docs: null,
    config: null
  },
  verification: null,
  performance_metrics: {
    juno_start: null,
    juno_end: null,
    apo_start: null,
    apo_end: null,
    verification_start: null,
    verification_end: null,
    total_start: Date.now(),
    total_end: null
  }
};

LOG: "";
LOG: "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó";
LOG: "‚ïë     TRINITY DOCUMENTATION GENERATOR v2.0.9                 ‚ïë";
LOG: "‚ïë     Architecture: Multi-Agent Orchestration                ‚ïë";
LOG: "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù";
LOG: "";
LOG: "üìã Documentation generation process:";
LOG: "   1. JUNO audits codebase (READ-ONLY)";
LOG: "   2. Three APO instances generate docs (PARALLEL)";
LOG: "   3. Verification ensures completeness and quality";
LOG: "";
```

---

## Phase 0.2: Template Validation (Rec 18 - Optional)

**Purpose:** Validate template files before APO execution (optional quality check)

```javascript
// Optional: Enable template validation (default: disabled for performance)
const VALIDATE_TEMPLATES = false; // Set to true to enable template validation

if (VALIDATE_TEMPLATES) {
  LOG: "";
  LOG: "=== PHASE 0.2: TEMPLATE VALIDATION ===";
  LOG: "";
  LOG: "Validating template files for correct variable syntax...";
  LOG: "";

  const template_paths = [
    "trinity/templates/documentation/mermaid-diagrams/mvc-flow.md.template",
    "trinity/templates/documentation/mermaid-diagrams/database-er.md.template",
    "trinity/templates/documentation/mermaid-diagrams/component-hierarchy.md.template",
    "trinity/templates/documentation/mermaid-diagrams/api-endpoint-map.md.template",
    "trinity/templates/documentation/guides/getting-started.md",
    "trinity/templates/documentation/guides/api-development.md",
    "trinity/templates/documentation/guides/deployment.md",
    "trinity/templates/documentation/guides/contributing.md",
    "trinity/templates/documentation/api/README.md",
    "trinity/templates/documentation/config/env-example.md",
    "trinity/templates/documentation/config/readme-update.md"
  ];

  const template_issues = [];
  let templates_validated = 0;
  let templates_skipped = 0;

  for (const path of template_paths) {
    if (!exists(path)) {
      templates_skipped++;
      LOG: \`  ‚è≠Ô∏è Skipped: \${path} (not found)\`;
      continue;
    }

    const content = Read(path);
    templates_validated++;

    // Check 1: Valid variable syntax (only {{UPPERCASE_UNDERSCORE}})
    const variable_pattern = /\{\{([^}]+)\}\}/g;
    const variables = content.match(variable_pattern);

    if (variables) {
      for (const variable of variables) {
        const var_name = variable.replace(/[{}]/g, '');

        // Valid: {{DATABASE_TYPE}}, {{API_BASE_PATH}}
        // Invalid: {{databaseType}}, {{Database Type}}, {{123}}
        if (!/^[A-Z][A-Z0-9_]*$/.test(var_name)) {
          template_issues.push({
            file: path,
            variable: variable,
            reason: "Invalid variable name (must be UPPERCASE_UNDERSCORE)"
          });
        }
      }
    }

    // Check 2: Ensure no nested variables ({{VAR_{{NESTED}}}})
    if (/\{\{[^}]*\{\{/.test(content)) {
      template_issues.push({
        file: path,
        variable: "N/A",
        reason: "Nested variables detected (not supported)"
      });
    }

    // Check 3: Balanced braces
    const open_braces = (content.match(/\{\{/g) || []).length;
    const close_braces = (content.match(/\}\}/g) || []).length;

    if (open_braces !== close_braces) {
      template_issues.push({
        file: path,
        variable: "N/A",
        reason: \`Unbalanced braces (\${open_braces} open, \${close_braces} close)\`
      });
    }

    if (template_issues.filter(i => i.file === path).length === 0) {
      LOG: \`  ‚úÖ Valid: \${path}\`;
    } else {
      WARNING: \`  ‚ö†Ô∏è Issues: \${path}\`;
    }
  }

  LOG: "";
  LOG: \`Template Validation Summary:\`;
  LOG: \`  Validated: \${templates_validated}\`;
  LOG: \`  Skipped: \${templates_skipped} (not found)\`;
  LOG: \`  Issues: \${template_issues.length}\`;
  LOG: "";

  if (template_issues.length > 0) {
    WARNING: "";
    WARNING: "‚ö†Ô∏è Template validation warnings (non-blocking):";
    for (const issue of template_issues) {
      WARNING: \`   \${issue.file}\`;
      WARNING: \`     Variable: \${issue.variable}\`;
      WARNING: \`     Issue: \${issue.reason}\`;
    }
    WARNING: "";
    WARNING: "These issues may cause APO variable replacement failures.";
    WARNING: "Consider fixing templates before production use.";
    WARNING: "";
  } else if (templates_validated > 0) {
    LOG: "‚úÖ All templates have valid syntax";
    LOG: "";
  }
}
```

---

## Phase 0.25: Retry Mechanism (Rec 21)

**Purpose:** Handle transient failures gracefully (filesystem delays, race conditions)

```javascript
// Rec 21: Retry mechanism for operations that may have transient failures
function retry_operation(operation_name, operation_func, max_attempts = 3, delay_ms = 500) {
  LOG: `Executing: ${operation_name} (max ${max_attempts} attempts)`;

  for (let attempt = 1; attempt <= max_attempts; attempt++) {
    try {
      LOG: `  Attempt ${attempt}/${max_attempts}...`;

      const result = operation_func();

      LOG: `  ‚úÖ ${operation_name} succeeded on attempt ${attempt}`;
      return {
        success: true,
        result: result,
        attempts: attempt
      };
    } catch (error) {
      if (attempt < max_attempts) {
        WARNING: `  ‚ö†Ô∏è Attempt ${attempt} failed: ${error.message}`;
        WARNING: `  Retrying in ${delay_ms}ms...`;

        // Wait before retry
        const start = Date.now();
        while (Date.now() - start < delay_ms) {
          // Busy wait
        }
      } else {
        // Final attempt failed
        ERROR: `  ‚ùå ${operation_name} failed after ${max_attempts} attempts`;
        ERROR: `  Final error: ${error.message}`;

        return {
          success: false,
          error: error,
          attempts: attempt
        };
      }
    }
  }
}

// Example usage patterns:

// Pattern 1: File read with retry (handles filesystem delays)
const file_read_result = retry_operation(
  "Read JUNO report",
  () => Read("trinity/reports/DOCS-AUDIT-*.md"),
  3,
  500
);

if (!file_read_result.success) {
  ERROR: "Failed to read JUNO report after retries";
  ABORT_COMMAND();
}

const audit_report_content = file_read_result.result;

// Pattern 2: Glob with retry (handles race conditions in parallel execution)
const file_discovery_result = retry_operation(
  "Discover documentation files",
  () => {
    const files = {
      diagrams: Glob({pattern: "docs/images/*.md"}),
      guides: Glob({pattern: "docs/guides/*.md"}),
      api: Glob({pattern: "docs/api/*.md"})
    };

    const total = files.diagrams.length + files.guides.length + files.api.length;

    if (total === 0) {
      throw new Error("No files discovered - may be transient filesystem delay");
    }

    return files;
  },
  3,
  1000 // Longer delay for file discovery
);

if (!file_discovery_result.success) {
  ERROR: "Failed to discover files after retries - generation likely failed";
  ABORT_COMMAND();
}

// Pattern 3: File existence check with retry
const file_exists_result = retry_operation(
  "Check file existence",
  () => {
    if (!exists("expected/file/path.md")) {
      throw new Error("File not found");
    }
    return true;
  },
  3,
  500
);
```

**When to Use Retry Mechanism:**

1. **File Operations After Parallel Execution:**
   - Reading files created by parallel APO instances
   - Glob operations immediately after APO completion
   - File existence checks in verification phase

2. **Transient Error Indicators:**
   - "File not found" (immediately after known file creation)
   - Empty Glob results (when files should exist)
   - "Permission denied" (temporary lock)
   - "Resource temporarily unavailable"

3. **DO NOT Use For:**
   - Permanent errors (syntax errors, logic errors)
   - User input errors
   - Configuration errors
   - Business logic failures

**Integration Points:**

- Phase 1: Reading JUNO report after generation
- Phase 2: APO synchronization barrier (file availability check)
- Phase 2: APO-3 README link validation (file existence)
- Phase 3: Verification file discovery
- Phase 3: Reading generated files for quality checks

---

## Phase 0.5: Success Criteria Definition

**Purpose:** Define objective quality standards for documentation generation

### Tier 1: Completion (REQUIRED - 40 points)

**File Creation:**
- All expected files created (based on JUNO report)
- Correct directory structure (docs/images/, docs/guides/, docs/api/)
- No missing files from checklist

**Threshold:** 100% completion required (0 points if any file missing)

### Tier 2: Content Quality (REQUIRED - 40 points)

**Template Placeholders (10 points):**
- ABORT: Any {{VARIABLE}} syntax remaining in output files
- Expected: 0 placeholders in all documentation

**Internal Link Validation (15 points):**
- ABORT: Any broken internal links (file references that don't exist)
- Expected: 0 broken links in all documentation

**Mermaid Syntax Validation (15 points):**
- ABORT: Invalid Mermaid syntax in diagram files
- Expected: All diagrams have valid Mermaid code blocks with proper diagram types

**Threshold:** Must pass all checks (100%) - any failure causes ABORT

### Tier 3: Content Accuracy (WARNING - 15 points)

**Documentation vs. Reality (15 points):**
- WARN: API endpoint counts differ by >¬±1
- WARN: Component counts differ by >¬±2
- WARN: Testing framework mentioned incorrectly (e.g., Jest when using Vitest)
- WARN: Non-existent components referenced in diagrams

**Threshold:** Warnings logged but do not cause ABORT

### Tier 4: Excellence (OPTIONAL - 5 points)

**Best Practices:**
- Comprehensive code examples in guides
- Clear architecture explanations
- Helpful deployment instructions
- Complete API documentation with examples

### Scoring Formula

```
Total Score = Tier1_Points + Tier2_Points + Tier3_Points + Tier4_Points

Grade Scale:
- 95-100: Excellent (Production Ready)
- 85-94: Good (Minor improvements recommended)
- 70-84: Acceptable (Requires review and fixes)
- <70: Poor (Significant issues, re-generation recommended)
```

**Quality Gates:**
- Tier 1 failure: ABORT immediately
- Tier 2 failure: ABORT immediately
- Tier 3 issues: LOG warnings, continue
- Tier 4 issues: LOG suggestions, continue

---

## Phase 1: JUNO Documentation Audit

**Purpose:** Analyze codebase and create comprehensive documentation checklist

### Step 1.1: Invoke JUNO for Codebase Audit

```javascript
// ============================================================
// PHASE 0: TEMPLATE VALIDATION (PRE-EXECUTION GATE)
// WO-003: Pre-execution gate ensures all required templates exist
// ============================================================

LOG: "";
LOG: "=== PHASE 0: TEMPLATE VALIDATION ===";
LOG: "Verifying all required templates exist before execution...";
LOG: "";

const required_templates = [
  // Mermaid diagrams (WO-1.8)
  "trinity/templates/documentation/mermaid-diagrams/mvc-flow.md.template",
  "trinity/templates/documentation/mermaid-diagrams/database-er.md.template",
  "trinity/templates/documentation/mermaid-diagrams/api-endpoint-map.md.template",
  "trinity/templates/documentation/mermaid-diagrams/component-hierarchy.md.template",
  
  // Guides (WO-002)
  "trinity/templates/documentation/guides/getting-started.md.template",
  "trinity/templates/documentation/guides/api-development.md.template",
  "trinity/templates/documentation/guides/deployment.md.template",
  "trinity/templates/documentation/guides/contributing.md.template",
  
  // API docs (WO-002)
  "trinity/templates/documentation/api-docs/README.md.template",
  
  // Configuration (WO-003)
  "trinity/templates/documentation/config/env-example-generator.md.template",
  
  // JUNO internal report (WO-1.8)
  "trinity/templates/documentation/reports/juno-internal-report.md.template"
];

const missing_templates = [];

for (const template_path of required_templates) {
  // Check if template file exists
  if (!exists(template_path)) {
    missing_templates.push(template_path);
    ERROR: \`‚ùå Missing required template: \${template_path}\`;
  } else {
    LOG: \`  ‚úÖ \${template_path}\`;
  }
}

if (missing_templates.length > 0) {
  ERROR: "";
  ERROR: "‚ùå CRITICAL ERROR: Required templates missing";
  ERROR: \`Missing \${missing_templates.length} template file(s)\`;
  ERROR: "";
  ERROR: "This indicates 'trinity update' CLI was not run or templates failed to deploy.";
  ERROR: "";
  ERROR: "REQUIRED ACTIONS:";
  ERROR: "  1. Run: trinity update";
  ERROR: "  2. Verify templates exist in trinity/templates/documentation/";
  ERROR: "  3. Re-run this command";
  ERROR: "";
  
  // ABORT - Cannot proceed without templates
  return {
    status: "ABORTED",
    reason: "Required templates missing",
    missing_templates: missing_templates,
    action_required: "Run 'trinity update' to deploy templates"
  };
}

LOG: "";
LOG: \`‚úÖ Template validation PASSED: All \${required_templates.length} templates found\`;
LOG: "";
LOG: "=== PHASE 0 COMPLETE ===";
LOG: "";

LOG: "=== PHASE 1: JUNO DOCUMENTATION AUDIT ===";
LOG: "";
LOG: "Invoking JUNO (Quality Auditor) to analyze codebase...";
LOG: "";

// Track performance
global.trinity_docs_session.performance_metrics.juno_start = Date.now();

// Invoke JUNO agent
Task({
  subagent_type: "JUNO (Quality Auditor)",
  description: "Audit codebase for documentation needs",
  prompt: `
# JUNO Documentation Audit Task

**Objective:** Analyze the codebase and create a comprehensive documentation checklist report using the internal report template.

## Your Mission

You are JUNO, the Quality Auditor. Your task is to audit this codebase and generate a structured report for APO consumption.

**CRITICAL:** This is a READ-ONLY operation. DO NOT create any documentation files. Only analyze and create the audit report.

---

## Report Template to Use

**Template File:** \`trinity/templates/documentation/reports/juno-internal-report.md.template\`

**Instructions:**
1. **Read the template** to understand the complete structure required
2. **Analyze the codebase** to gather all data for every {{VARIABLE}}
3. **Replace ALL placeholders** with actual discovered values (no placeholders like "[Database detected]")
4. **Output the completed report** to: \`trinity/reports/DOCS-AUDIT-{timestamp}.md\`

**Timestamp Format:** YYYY-MM-DD-HHmm (e.g., 2026-01-15-1530)

---

## Critical Requirements

**ZERO TOLERANCE RULES:**
- ALL {{VARIABLE}} placeholders MUST be replaced with actual values
- Component names MUST exist in codebase (verify with Glob)
- Model names MUST come from actual schema files
- Endpoint counts MUST match actual route files
- Testing framework MUST be from package.json (not assumed)
- Use ONLY discovered data - NO invented names, NO assumptions

**Autonomous Execution:**
- Do NOT ask user for input
- Do NOT prompt for decisions
- Proceed directly to analyze and generate report
- If ambiguous: use sensible defaults based on codebase evidence

---

## Discovery Logic

Use the following patterns to discover codebase information:

### 1. Framework and Technology Detection

**Package Analysis:**
\`\`\`javascript
const pkg_json = Read("package.json");
const pkg = JSON.parse(pkg_json);

// Detect frameworks, database, ORM, testing from dependencies
// Backend: express, fastify, koa, hapi, nestjs
// Frontend: react, vue, angular, svelte, solid
// Database/ORM: prisma, typeorm, sequelize, mongoose, knex
// Testing: jest, vitest, mocha, jasmine, cypress, playwright
\`\`\`

### 2. Component Discovery (CRITICAL - ZERO TOLERANCE)

**RULE:** Every component name MUST exist in codebase (verified with Glob)

\`\`\`javascript
// Find React/Vue components
const component_patterns = ["client/**/*.{tsx,jsx}", "src/**/*.{tsx,jsx}", "**/*.vue"];
const all_component_files = [/* use Glob for each pattern */];

// Filter out tests, configs, entry points
const actual_components = all_component_files.filter(f =>
  !f.includes('.test.') && !f.includes('.spec.') && !f.includes('.config.')
);

// Extract names and paths for template variables
// List ALL components with paths in report for APO-1 verification
\`\`\`

### 3. Database Schema Analysis

\`\`\`javascript
// Prisma: Parse prisma/schema.prisma for models and relationships
// TypeORM: Find @Entity decorator files
// Mongoose: Find schema definitions
// Extract: model names, relationships (foreign keys), counts
\`\`\`

### 4. API Endpoint Discovery

\`\`\`javascript
// Find route files in: server/routes/, src/routes/, api/, server/api/
// Parse for HTTP methods: router.get(), app.post(), etc.
// Extract: method, path, file location
// Group by resource for SECTION B template variable
\`\`\`

### 5. Environment Variables

\`\`\`javascript
// Check for .env file
// Grep codebase for process.env.VARIABLE_NAME patterns
// Extract all unique environment variable names for SECTION C
\`\`\`

---

## Template Usage Instructions

**Read the template first:**
\`\`\`javascript
const template_content = Read("trinity/templates/documentation/reports/juno-internal-report.md.template");
// Study the structure to understand ALL {{VARIABLES}} you need to fill
\`\`\`

**Perform all discovery tasks above, then fill the template:**
- Replace {{PROJECT_NAME}} with actual name from package.json
- Replace {{BACKEND_FRAMEWORK}} with detected framework
- Replace {{MODEL_COUNT}} with actual count from schema
- Replace {{ENDPOINT_COUNT}} with actual discovered count
- Replace {{COMPONENT_NAMES}} with comma-separated list of actual components
- **ALL {{VARIABLES}} must be replaced - zero tolerance for placeholders**

**Output the completed report:**
\`\`\`javascript
const completed_report = /* filled template with all variables replaced */;
Write("trinity/reports/DOCS-AUDIT-{timestamp}.md", completed_report);
\`\`\`

---

## Self-Validation (Rec 3)

Before returning, verify report completeness:

\`\`\`javascript
const report_path = "trinity/reports/DOCS-AUDIT-{timestamp}.md";
const report_content = Read(report_path);

const validation_checks = {
  file_exists: report_content.length > 0,
  has_all_sections: report_content.includes("SECTION A") &&
                    report_content.includes("SECTION B") &&
                    report_content.includes("SECTION C"),
  min_length: report_content.length >= 2000,
  no_placeholders: !report_content.includes("[") && !report_content.includes("{{"),
  component_verification: /* Glob each listed component path to verify exists */
};

// All checks must pass before proceeding
if (!Object.values(validation_checks).every(v => v === true)) {
  ERROR: "JUNO self-validation failed - fix report before returning";
  return "VALIDATION_FAILED";
}

LOG: "‚úÖ JUNO self-validation passed";
\`\`\`

---

## Completion Summary

Return concise summary after validation passes:

\`\`\`
JUNO Audit Complete
Report: trinity/reports/DOCS-AUDIT-{timestamp}.md

Architecture: [type]
Backend: [framework] [version]
Frontend: [framework] [version]
Database: [type] ([N] models)
API: [N] endpoints
Components: [N] total
Testing: [framework or None]

Documentation: [N] files to generate
Status: Ready for APO execution
\`\`\`
  `
});

LOG: "";
LOG: "‚è≥ Waiting for JUNO audit to complete...";
LOG: "";
```

### Step 1.2: Capture JUNO's Report Path and Validate (Rec 1)

```javascript
// After JUNO completes, extract report path from response
const juno_response = [JUNO's returned message];

// Track performance
global.trinity_docs_session.performance_metrics.juno_end = Date.now();

// Parse report path from JUNO's response
const report_path_match = juno_response.match(/trinity\/reports\/DOCS-AUDIT-[\d-]+\.md/);

if (!report_path_match) {
  ERROR: "";
  ERROR: "‚ùå CRITICAL ERROR: JUNO did not create audit report";
  ERROR: "Expected report at: trinity/reports/DOCS-AUDIT-{timestamp}.md";
  ERROR: "";
  ERROR: "Cannot proceed without audit report.";
  ERROR: "";
  ABORT_COMMAND();
}

const audit_report_path = report_path_match[0];
global.trinity_docs_session.audit_report = audit_report_path;

LOG: `‚úÖ JUNO audit complete: ${audit_report_path}`;

// NEW: Validate JUNO report completeness (Recommendation 1)
LOG: "";
LOG: "Validating JUNO report completeness...";

const juno_report = Read(audit_report_path);
const juno_issues = [];

// Check 1: Report size (should be substantial)
if (juno_report.length < 1000) {
  juno_issues.push({
    severity: "HIGH",
    issue: `Report suspiciously short (${juno_report.length} chars, expected 2000+)`
  });
}

// Check 2: Required sections present
const has_section_a = juno_report.includes("## SECTION A:");
const has_section_b = juno_report.includes("## SECTION B:");
const has_section_c = juno_report.includes("## SECTION C:");

if (!has_section_a) {
  juno_issues.push({
    severity: "CRITICAL",
    issue: "Section A (Architecture & Diagrams) missing"
  });
}

if (!has_section_b) {
  juno_issues.push({
    severity: "CRITICAL",
    issue: "Section B (API Documentation & Guides) missing"
  });
}

if (!has_section_c) {
  juno_issues.push({
    severity: "CRITICAL",
    issue: "Section C (Configuration & Setup) missing"
  });
}

// Check 3: Executive Summary present
const has_executive_summary = juno_report.includes("## Executive Summary") || juno_report.includes("Executive Summary:");
if (!has_executive_summary) {
  juno_issues.push({
    severity: "HIGH",
    issue: "Executive Summary missing"
  });
}

// Check 4: Enhanced Placeholder Detection (Rec 4)
LOG: "Checking for template placeholders...";

// Rec 4: Multiple placeholder patterns
const placeholder_patterns = [
  /\[[A-Z][a-z]+( [a-z]+)+ detected\]/g,          // [Database type detected]
  /\{\{[A-Z_]+\}\}/g,                             // {{VARIABLE}}
  /\[YOUR_[A-Z_]+\]/g,                            // [YOUR_API_KEY]
  /\bTBD\b/g,                                      // TBD
  /\bTODO:/g,                                      // TODO:
  /\[PLACEHOLDER\]/gi,                             // [PLACEHOLDER]
  /\[Fill this in\]/gi,                            // [Fill this in]
  /\[Add (.*?) here\]/gi                           // [Add X here]
];

const found_placeholders = [];
let total_placeholder_count = 0;

for (const pattern of placeholder_patterns) {
  const matches = juno_report.match(pattern);
  if (matches) {
    total_placeholder_count += matches.length;
    for (const match of matches) {
      if (!found_placeholders.includes(match)) {
        found_placeholders.push(match);
      }
    }
  }
}

LOG: `Placeholder patterns checked: ${placeholder_patterns.length}`;
LOG: `Unique placeholders found: ${found_placeholders.length}`;
LOG: `Total occurrences: ${total_placeholder_count}`;

if (total_placeholder_count > 3) {
  juno_issues.push({
    severity: "HIGH",
    issue: `Too many placeholders detected (${total_placeholder_count} instances): ${found_placeholders.slice(0, 5).join(', ')}${found_placeholders.length > 5 ? '...' : ''}`
  });

  WARNING: `Found ${total_placeholder_count} placeholders in JUNO report:`;
  for (const ph of found_placeholders.slice(0, 10)) {
    WARNING: `  - ${ph}`;
  }
  if (found_placeholders.length > 10) {
    WARNING: `  ... and ${found_placeholders.length - 10} more`;
  }
}

// Check 5: Component Verification (Rec 3) - Verify no invented components
LOG: "";
LOG: "Performing component verification (Rec 3)...";

// Extract component names documented in JUNO report
const component_section = juno_report.match(/\*\*Discovered Components.*?(?=\n\*\*|$)/s);
const documented_components = [];

if (component_section) {
  const component_lines = component_section[0].match(/^\d+\.\s+([A-Za-z0-9_]+)/gm);
  if (component_lines) {
    for (const line of component_lines) {
      const component_name = line.match(/^\d+\.\s+([A-Za-z0-9_]+)/)[1];
      documented_components.push(component_name);
    }
  }
}

LOG: `Documented components in report: ${documented_components.length}`;

// Re-discover components from actual codebase
const component_patterns = [
  "client/**/*.{tsx,jsx}",
  "src/**/*.{tsx,jsx}",
  "client/**/*.vue",
  "src/**/*.vue"
];

let actual_component_files = [];
for (const pattern of component_patterns) {
  const files = Glob({pattern: pattern});
  actual_component_files = [...actual_component_files, ...files];
}

// Filter out non-component files
const actual_components = actual_component_files.filter(f =>
  !f.includes('.test.') &&
  !f.includes('.spec.') &&
  !f.endsWith('main.tsx') &&
  !f.endsWith('main.jsx') &&
  !f.endsWith('index.tsx') &&
  !f.endsWith('index.jsx') &&
  !f.includes('setupTests') &&
  !f.includes('vite.config') &&
  !f.includes('.config.')
);

// Extract actual component names
const actual_component_names = actual_components.map(f => {
  const path_parts = f.split('/');
  const filename = path_parts[path_parts.length - 1];
  return filename.replace(/\.(tsx|jsx|vue)$/, '');
});

LOG: `Actual components in codebase: ${actual_component_names.length}`;

// Find invented components (in report but not in codebase)
const invented_components = [];
for (const doc_component of documented_components) {
  if (!actual_component_names.includes(doc_component)) {
    invented_components.push(doc_component);
  }
}

if (invented_components.length > 0) {
  juno_issues.push({
    severity: "CRITICAL",
    issue: `Invented components detected (${invented_components.length}): ${invented_components.join(', ')}`
  });

  ERROR: "";
  ERROR: `‚ùå Component verification failed: ${invented_components.length} invented components`;
  for (const invented of invented_components) {
    ERROR: `   - ${invented} (NOT FOUND in codebase)`;
  }
  ERROR: "";
} else {
  LOG: `‚úÖ Component verification passed: All ${documented_components.length} components exist in codebase`;
}

LOG: "";

// Report validation results
LOG: `Report size: ${juno_report.length} characters`;
LOG: `Section A present: ${has_section_a ? "‚úÖ" : "‚ùå"}`;
LOG: `Section B present: ${has_section_b ? "‚úÖ" : "‚ùå"}`;
LOG: `Section C present: ${has_section_c ? "‚úÖ" : "‚ùå"}`;
LOG: `Executive Summary: ${has_executive_summary ? "‚úÖ" : "‚ùå"}`;
LOG: `Placeholders: ${placeholder_count} instances`;
LOG: "";

// Decision: Proceed with warnings or abort?
const critical_issues = juno_issues.filter(i => i.severity === "CRITICAL");

if (critical_issues.length >= 3) {
  // All sections missing - report is too minimal
  ERROR: "";
  ERROR: "‚ùå JUNO REPORT VALIDATION: CRITICAL FAILURE";
  ERROR: "";
  ERROR: "JUNO report is too incomplete to proceed:";
  for (const issue of juno_issues) {
    ERROR: `   [${issue.severity}] ${issue.issue}`;
  }
  ERROR: "";
  ERROR: "The report must contain Executive Summary and all 3 sections (A, B, C).";
  ERROR: "Please investigate JUNO task execution.";
  ERROR: "";
  ABORT_COMMAND();
} else if (juno_issues.length > 0) {
  // Some issues but not critical failure
  WARNING: "";
  WARNING: "‚ö†Ô∏è JUNO REPORT VALIDATION: PARTIAL SUCCESS";
  WARNING: "";
  WARNING: "Issues detected in JUNO report:";
  for (const issue of juno_issues) {
    WARNING: `   [${issue.severity}] ${issue.issue}`;
  }
  WARNING: "";
  WARNING: "APOs will activate fallback mechanisms (Phase 1.5).";
  WARNING: "Enhanced verification will be applied to ensure quality.";
  WARNING: "";

  // Log for investigation
  global.trinity_docs_session.juno_incomplete = true;
  global.trinity_docs_session.juno_issues = juno_issues;
} else {
  LOG: "‚úÖ JUNO report validation: PASSED";
  global.trinity_docs_session.juno_incomplete = false;
}

// Rec 5: JUNO Execution Time Tracking
LOG: "";
LOG: "=== JUNO PERFORMANCE METRICS ===";
LOG: "";

const juno_duration = (global.trinity_docs_session.performance_metrics.juno_end - global.trinity_docs_session.performance_metrics.juno_start) / 1000;

// Count files analyzed by JUNO (estimate from various patterns)
const files_analyzed_match = juno_report.match(/Files analyzed:\s*(\d+)/i) ||
                            juno_report.match(/(\d+)\s+files? analyzed/i) ||
                            juno_report.match(/Total files:\s*(\d+)/i);
const files_analyzed = files_analyzed_match ? parseInt(files_analyzed_match[1]) : "Unknown";

// Extract discovered counts
const component_count_match = juno_report.match(/Components?:\s*(\d+)/i) ||
                              juno_report.match(/(\d+)\s+components?/i);
const component_count = component_count_match ? parseInt(component_count_match[1]) : 0;

const endpoint_count_match = juno_report.match(/API Endpoints?:\s*(\d+)/i) ||
                             juno_report.match(/(\d+)\s+endpoints?/i);
const endpoint_count = endpoint_count_match ? parseInt(endpoint_count_match[1]) : 0;

const model_count_match = juno_report.match(/Models?:\s*(\d+)/i) ||
                          juno_report.match(/(\d+)\s+models?/i);
const model_count = model_count_match ? parseInt(model_count_match[1]) : 0;

LOG: `Analysis Duration: ${juno_duration.toFixed(2)}s`;
LOG: `Files Analyzed: ${files_analyzed}`;
LOG: ``;
LOG: `Discoveries:`;
LOG: `  - Components: ${component_count}`;
LOG: `  - API Endpoints: ${endpoint_count}`;
LOG: `  - Data Models: ${model_count}`;
LOG: ``;
LOG: `Report Size: ${(juno_report.length / 1024).toFixed(2)} KB (${juno_report.length} chars)`;
LOG: `Report Location: ${audit_report_path}`;
LOG: "";

// Calculate throughput
if (files_analyzed !== "Unknown" && files_analyzed > 0) {
  const files_per_second = (files_analyzed / juno_duration).toFixed(2);
  LOG: `Throughput: ${files_per_second} files/second`;
  LOG: "";
}

LOG: "";
```

---

## Phase 1.5: APO Fallback Architecture (Rec 4)

**Purpose:** Document resilience mechanisms when JUNO report is incomplete

### When Fallback Activates

Fallback mechanisms activate when:
- JUNO report validation detects HIGH severity issues (not CRITICAL)
- Sections are present but minimal or contain placeholders
- Variable values are missing or incomplete
- `global.trinity_docs_session.juno_incomplete === true`

### APO Fallback Protocol

When JUNO report is incomplete, each APO must:

#### Step 1: Detect Incomplete Report

```javascript
// Each APO checks global state
if (global.trinity_docs_session.juno_incomplete) {
  LOG: "";
  LOG: "‚ö†Ô∏è FALLBACK MODE ACTIVATED";
  LOG: "JUNO report incomplete - using direct codebase analysis";
  LOG: "";
}
```

#### Step 2: Direct Codebase Analysis

**APO-1 (Diagrams):**
- If diagram variables missing: Parse database schema files directly
- If component list empty: Use Glob to find component files
- If API endpoint list empty: Search route files directly
- Generate Mermaid syntax from raw data

**APO-2 (Guides & Docs):**
- If framework not specified: Read package.json dependencies
- If test command missing: Check package.json scripts
- If environment variables missing: Read .env file or grep for process.env
- Fill template variables from direct detection

**APO-3 (Config Files):**
- If .env keys missing: Search codebase for process.env.KEY patterns
- If README links undefined: Build links from expected file locations
- Validate all file references before writing

#### Step 3: Access Templates Directly

When JUNO report doesn't specify templates:
- Use default template paths: `trinity/templates/documentation/`
- Read template structure to determine required variables
- Extract variables from codebase analysis

#### Step 4: Mark Fallback Usage

Each APO logs when fallback is used:

```javascript
LOG: "‚ö†Ô∏è FALLBACK: [Variable name] not in JUNO report - detected from [source]";
```

### Quality Assurance with Fallback

Even with fallback:
- All files must be created (100% completion)
- No {{PLACEHOLDERS}} in output (content quality check)
- Internal links must be validated
- Mermaid syntax must be valid

Verification phase (Phase 3) enforces same quality standards regardless of fallback usage.

### Fallback Success Criteria

Fallback is successful if:
- APO completes task using direct analysis
- Generated documentation passes verification
- Quality score ‚â•85 (Good grade)

Fallback is unsuccessful if:
- APO cannot extract required information from codebase
- Generated documentation contains placeholders
- Verification fails quality checks

### Logging Standards

**When entering fallback:**
```
‚ö†Ô∏è FALLBACK MODE ACTIVATED
JUNO report incomplete - using direct codebase analysis
Fallback reason: [Specific JUNO issue from global state]
```

**During fallback:**
```
‚ö†Ô∏è FALLBACK: {{DATABASE}} not in report - detected "PostgreSQL" from prisma/schema.prisma
‚ö†Ô∏è FALLBACK: Component list empty - discovered 15 components via Glob
```

**After fallback:**
```
‚úÖ FALLBACK SUCCESS: All required information extracted from codebase
Files created: [count] (same as without fallback)
```

**Note:** Fallback is a **feature**, not a failure. It demonstrates APO resilience and ensures documentation generation succeeds even with incomplete JUNO reports.

---

## Phase 2: Parallel APO Execution

**Purpose:** Generate documentation in parallel using JUNO's checklist

### Step 2.1: Invoke Three APO Instances in Parallel

```javascript
LOG: "=== PHASE 2: PARALLEL DOCUMENTATION GENERATION ===";
LOG: "";
LOG: "Invoking 3 APO instances in parallel...";
LOG: "  - APO-1: Architecture diagrams (Section A)";
LOG: "  - APO-2: API docs and guides (Section B)";
LOG: "  - APO-3: Configuration files (Section C)";
LOG: "";

// Track performance
global.trinity_docs_session.performance_metrics.apo_start = Date.now();

// Invoke 3 APO agents IN PARALLEL
// This is done by making multiple Task calls in the same message

// APO Instance 1: Architecture & Diagrams
Task({
  subagent_type: "APO",
  description: "Generate architecture diagrams",
  prompt: `
# APO-1: Architecture Diagram Generation

**Your Mission:** Generate Mermaid architecture diagrams using templates and JUNO's audit report.

## Error Handling Protocol (Rec 5)

**Tier 1: ABORT Conditions (Stop immediately, return error)**

ABORT if:
- ‚ùå Cannot read codebase (permission denied, files missing at system level)
- ‚ùå Cannot write output files (permission denied, disk full, directory creation fails)
- ‚ùå Critical templates completely missing AND cannot generate from scratch

**Tier 2: WARN and CONTINUE (Report issue, activate fallback)**

WARN if:
- ‚ö†Ô∏è JUNO section A incomplete/missing (use direct codebase analysis - see Phase 1.5)
- ‚ö†Ô∏è Some variable values missing (infer from codebase directly)
- ‚ö†Ô∏è Template file missing but can generate Mermaid from scratch
- ‚ö†Ô∏è Component list empty (use Glob to discover components)

**Tier 3: LOG INFO (Normal process updates)**

LOG if:
- ‚ÑπÔ∏è Reading templates
- ‚ÑπÔ∏è Creating diagram files
- ‚ÑπÔ∏è Replacing variables
- ‚ÑπÔ∏è Writing output files

**Error Response Format:**

\`\`\`javascript
if (TIER_1_ERROR) {
  ERROR: "";
  ERROR: "‚ùå APO-1 CRITICAL ERROR: [Error description]";
  ERROR: "Cannot proceed with diagram generation.";
  ERROR: "";
  return "APO-1 ABORTED: [Reason]";
}

if (TIER_2_ERROR) {
  WARNING: "";
  WARNING: "‚ö†Ô∏è APO-1 WARNING: [Issue description]";
  WARNING: "Activating fallback mechanism...";
  WARNING: "";
  // Continue with fallback
}
\`\`\`

## Step 1: Read JUNO's Audit Report

Read the audit report at: **${audit_report_path}**

Find **SECTION A: ARCHITECTURE & DIAGRAMS**

This section contains your complete checklist of diagrams to create.

**Check for Fallback Mode:**
\`\`\`javascript
if (global.trinity_docs_session.juno_incomplete) {
  LOG: "";
  LOG: "‚ö†Ô∏è FALLBACK MODE ACTIVATED";
  LOG: "JUNO report incomplete - will use direct codebase analysis for missing data";
  LOG: "";
}
\`\`\`

**Rec 12: Template Existence Verification**
\`\`\`javascript
LOG: "";
LOG: "Verifying template accessibility...";

const template_paths = {
  mvc_flow: "trinity/templates/documentation/mermaid-diagrams/mvc-flow.md.template",
  database_er: "trinity/templates/documentation/mermaid-diagrams/database-er.md.template",
  component_hierarchy: "trinity/templates/documentation/mermaid-diagrams/component-hierarchy.md.template",
  api_endpoint_map: "trinity/templates/documentation/mermaid-diagrams/api-endpoint-map.md.template"
};

const template_status = {};
let templates_found = 0;
let templates_missing = 0;

for (const [name, path] of Object.entries(template_paths)) {
  if (exists(path)) {
    template_status[name] = "FOUND";
    templates_found++;
    LOG: \`  ‚úÖ Template available: \${name} (\${path})\`;
  } else {
    template_status[name] = "MISSING";
    templates_missing++;
    WARNING: \`  ‚ö†Ô∏è Template missing: \${name} (\${path}) - will generate from scratch\`;
  }
}

LOG: "";
LOG: \`Template Availability: \${templates_found} found, \${templates_missing} missing\`;

if (templates_missing > 0) {
  WARNING: "";
  WARNING: \`‚ö†Ô∏è \${templates_missing} template(s) missing - activating generation fallback\`;
  WARNING: "This is NOT a failure - Mermaid diagrams will be generated from scratch";
  WARNING: "";
}

LOG: "";
\`\`\`

**Rec 13: Context Size Monitoring**
\`\`\`javascript
LOG: "Monitoring context size...";

const juno_report_content = Read("${audit_report_path}");
const juno_full_size = juno_report_content.length;

// Find Section A boundaries
const section_a_start = juno_report_content.indexOf("## SECTION A:");
const section_b_start = juno_report_content.indexOf("## SECTION B:");

let section_a_size = 0;
if (section_a_start !== -1 && section_b_start !== -1) {
  section_a_size = section_b_start - section_a_start;
} else if (section_a_start !== -1) {
  section_a_size = juno_report_content.length - section_a_start;
}

LOG: \`  Full JUNO report: \${(juno_full_size / 1024).toFixed(2)} KB (\${juno_full_size} chars)\`;
LOG: \`  Section A (my section): \${(section_a_size / 1024).toFixed(2)} KB (\${section_a_size} chars)\`;
LOG: \`  Context overhead: This prompt + report section = ~\${((section_a_size + 15000) / 1024).toFixed(2)} KB\`;

if (section_a_size > 50000) {
  WARNING: "";
  WARNING: \`‚ö†Ô∏è Large context detected: Section A is \${(section_a_size / 1024).toFixed(2)} KB\`;
  WARNING: "Consider JUNO optimization if this causes performance issues";
  WARNING: "";
}

LOG: "";
\`\`\`

## Step 2: Generate Each Required Diagram

For EACH diagram marked "Required: YES" in Section A:

### Process:
1. Read the template file (path provided in report)
   - If template missing: Generate Mermaid syntax from scratch (WARN)
2. Extract variable values from report (all values should be pre-filled by JUNO)
   - If values missing: Detect from codebase directly (WARN, activate fallback)
3. Replace {{VARIABLES}} with actual values
4. Write the final diagram file to the output path
5. Verify file was created successfully

### Example:

**If diagram 1 shows:**
\`\`\`
Diagram 1: MVC Flow Diagram
- Required: YES
- Template: trinity/templates/documentation/mermaid-diagrams/mvc-flow.md.template
- Variables:
  - {{DATABASE}}: "SQLite"
  - {{FRAMEWORK}}: "Express"
- Output: docs/images/architecture-mvc-flow.md
\`\`\`

**You must:**
\`\`\`javascript
// 1. Read template
const template = Read("trinity/templates/documentation/mermaid-diagrams/mvc-flow.md.template");

// 2. Replace variables
const diagram = template
  .replace(/\{\{DATABASE\}\}/g, "SQLite")
  .replace(/\{\{FRAMEWORK\}\}/g, "Express");

// 3. Write output
Write("docs/images/architecture-mvc-flow.md", diagram);

// 4. Verify
LOG: "‚úÖ Created: docs/images/architecture-mvc-flow.md";
\`\`\`

### Fallback Example (if JUNO report incomplete):

**If database type is missing:**
\`\`\`javascript
let database_type = "[Database type from JUNO report]";

// If JUNO report has placeholder or missing value
if (database_type.includes("[") || !database_type) {
  WARNING: "‚ö†Ô∏è FALLBACK: Database type not in JUNO report - detecting from codebase";

  // Check for Prisma
  if (exists("prisma/schema.prisma")) {
    const schema = Read("prisma/schema.prisma");
    if (schema.includes('provider = "postgresql"')) {
      database_type = "PostgreSQL";
    } else if (schema.includes('provider = "sqlite"')) {
      database_type = "SQLite";
    } else if (schema.includes('provider = "mysql"')) {
      database_type = "MySQL";
    }
  }
  // Check package.json for MongoDB
  else if (pkg.dependencies?.mongoose) {
    database_type = "MongoDB";
  }

  LOG: \`‚ö†Ô∏è FALLBACK: Detected database type: \${database_type}\`;
}
\`\`\`

## Step 3: Self-Validation (Rec 6)

After generating all diagrams, you MUST verify:

\`\`\`javascript
LOG: "";
LOG: "=== APO-1 SELF-VALIDATION ===";
LOG: "";

const created_diagrams = Glob({pattern: "docs/images/*.md"});

// Validation checks
const validation_results = {
  files_created: created_diagrams.length > 0,
  expected_count_met: true, // Check against JUNO report count
  no_placeholders: true,
  mermaid_valid: true,
  min_content_length: true,
  component_accuracy: true // Rec 9: Verify components match JUNO list
};

// Check 1: All expected diagrams created
const juno_report = Read("${audit_report_path}");
const section_a = juno_report.match(/SECTION A:.*?(?=SECTION B:)/s);
if (section_a) {
  const expected_count = (section_a[0].match(/Required: YES/g) || []).length;
  validation_results.expected_count_met = created_diagrams.length === expected_count;

  if (!validation_results.expected_count_met) {
    ERROR: \`‚ùå Expected \${expected_count} diagrams, created \${created_diagrams.length}\`;
  }
}

// Check 2: No {{PLACEHOLDERS}} in any diagram
for (const file of created_diagrams) {
  const content = Read(file);
  const placeholders = content.match(/\{\{[^}]+\}\}/g);

  if (placeholders) {
    validation_results.no_placeholders = false;
    ERROR: \`‚ùå Placeholders remaining in \${file}: \${placeholders.join(", ")}\`;
  }

  // Check 3: Valid Mermaid syntax
  if (!content.includes("\`\`\`mermaid")) {
    validation_results.mermaid_valid = false;
    ERROR: \`‚ùå No Mermaid code block in \${file}\`;
  }

  // Check 4: Substantial content
  if (content.length < 100) {
    validation_results.min_content_length = false;
    ERROR: \`‚ùå Content too short in \${file} (\${content.length} chars)\`;
  }
}

// Check 5: Component Accuracy (Rec 9)
// Verify diagram components match JUNO's authoritative list
LOG: "";
LOG: "Checking component accuracy against JUNO report...";

validation_results.component_accuracy = true;
const juno_report_content = Read("${audit_report_path}");

// Extract component list from JUNO report
const component_section = juno_report_content.match(/\*\*CRITICAL FOR APO-1 - Use ONLY the components listed below:\*\*(.*?)(?=\n\n\*\*|$)/s);
if (component_section) {
  const juno_components = [];
  const component_lines = component_section[1].match(/- `([^`]+)`/g);
  if (component_lines) {
    for (const line of component_lines) {
      const match = line.match(/- `([^`]+)`/);
      if (match) {
        juno_components.push(match[1]);
      }
    }
  }

  LOG: \`  JUNO authoritative components: \${juno_components.length}\`;

  // Extract components from generated diagrams
  const diagram_components = new Set();
  for (const file of created_diagrams) {
    const content = Read(file);
    const mermaid_block = content.match(/\`\`\`mermaid(.*?)\`\`\`/s);
    if (mermaid_block) {
      // Extract node names from Mermaid syntax (various formats)
      const nodes = mermaid_block[1].match(/\b([A-Z][a-zA-Z0-9]*)\b(?=[\s\[({]|$)/g);
      if (nodes) {
        for (const node of nodes) {
          // Filter out Mermaid keywords
          if (!['graph', 'flowchart', 'sequenceDiagram', 'classDiagram', 'erDiagram', 'LR', 'TD', 'TB', 'RL', 'BT'].includes(node)) {
            diagram_components.add(node);
          }
        }
      }
    }
  }

  LOG: \`  Components found in diagrams: \${diagram_components.size}\`;

  // Check for invented components (in diagram but not in JUNO list)
  const invented_components = [];
  for (const component of diagram_components) {
    if (!juno_components.includes(component)) {
      invented_components.push(component);
    }
  }

  if (invented_components.length > 0) {
    validation_results.component_accuracy = false;
    ERROR: \`‚ùå INVENTED COMPONENTS DETECTED: \${invented_components.join(', ')}\`;
    ERROR: \`   These components are in diagrams but NOT in JUNO's authoritative list\`;
    ERROR: \`   ZERO TOLERANCE: All diagram components MUST come from JUNO report\`;
  } else {
    LOG: \`  ‚úÖ Component accuracy verified: All diagram components from JUNO list\`;
  }

  // Also check for missing components (in JUNO but not in diagram)
  const missing_components = [];
  for (const component of juno_components) {
    if (!diagram_components.has(component)) {
      missing_components.push(component);
    }
  }

  if (missing_components.length > 0) {
    WARNING: \`‚ö†Ô∏è Missing components (in JUNO but not in diagrams): \${missing_components.join(', ')}\`;
    WARNING: \`   This may indicate incomplete diagram coverage\`;
  }
}

LOG: "";

// Overall validation
const all_passed = Object.values(validation_results).every(v => v === true);

LOG: "Self-Validation Results:";
LOG: \`  Files created: \${validation_results.files_created ? "‚úÖ" : "‚ùå"}\`;
LOG: \`  Expected count: \${validation_results.expected_count_met ? "‚úÖ" : "‚ùå"}\`;
LOG: \`  No placeholders: \${validation_results.no_placeholders ? "‚úÖ" : "‚ùå"}\`;
LOG: \`  Mermaid valid: \${validation_results.mermaid_valid ? "‚úÖ" : "‚ùå"}\`;
LOG: \`  Content length: \${validation_results.min_content_length ? "‚úÖ" : "‚ùå"}\`;
LOG: \`  Component accuracy: \${validation_results.component_accuracy ? "‚úÖ" : "‚ùå"}\`;
LOG: "";

if (!all_passed) {
  ERROR: "";
  ERROR: "‚ùå APO-1 SELF-VALIDATION FAILED";
  ERROR: "";
  ERROR: "Validation Failures:";

  if (!validation_results.files_created) {
    ERROR: "   - Expected files not created";
  }
  if (!validation_results.expected_count_met) {
    ERROR: \`   - File count mismatch (expected: \${expected_count}, actual: \${actual_count})\`;
  }
  if (!validation_results.no_placeholders) {
    ERROR: "   - Template placeholders remaining in output";
    for (const issue of placeholder_issues) {
      ERROR: \`     * \${issue.file}: \${issue.placeholders.join(', ')}\`;
    }
  }
  if (!validation_results.mermaid_valid) {
    ERROR: "   - Invalid Mermaid syntax detected";
  }
  if (!validation_results.min_content_length) {
    ERROR: "   - Files with insufficient content detected";
  }
  if (!validation_results.component_accuracy) {
    ERROR: "   - Component accuracy failed: Invented components detected in diagrams";
    ERROR: "     Components in diagrams MUST match JUNO's authoritative list";
  }

  ERROR: "";
  ERROR: "ABORTING APO-1 EXECUTION";
  ERROR: "Cannot proceed with invalid documentation.";
  ERROR: "";
  ERROR: "Root Cause Analysis:";
  ERROR: "This failure indicates one of:";
  ERROR: "  1. JUNO report was incomplete (missing data)";
  ERROR: "  2. Template access failed (file not found)";
  ERROR: "  3. Variable replacement logic failed";
  ERROR: "  4. File write operation failed";
  ERROR: "";
  ERROR: "Recommended Action:";
  ERROR: "  1. Review JUNO report completeness";
  ERROR: "  2. Verify template paths exist";
  ERROR: "  3. Check disk space and permissions";
  ERROR: "";

  // CRITICAL: Actually abort by returning error status
  return {
    status: "FAILED",
    agent: "APO-1",
    reason: "Self-validation failed",
    details: validation_results,
    files_created: 0
  };
}

// Only reach this point if validation passed
LOG: "";
LOG: "‚úÖ APO-1 SELF-VALIDATION PASSED";
LOG: "";
LOG: "APO-1 Completion Summary:";
LOG: \`Diagrams created: \${created_diagrams.length}\`;
for (const file of created_diagrams) {
  LOG: \`  ‚úÖ \${file}\`;
}
LOG: "";
\`\`\`

## Critical Requirements

- ‚úÖ **Read JUNO's report** - All information should be pre-filled
- ‚úÖ **Activate fallback** if information missing (don't ABORT)
- ‚úÖ **Create EVERY diagram** marked "Required: YES"
- ‚úÖ **Use templates** when available - generate from scratch if missing
- ‚úÖ **Replace ALL variables** - No {{PLACEHOLDERS}} in output
- ‚úÖ **Write to correct paths** - Use output paths from report
- ‚úÖ **Self-validate** - Run validation checks before returning
- ‚úÖ **Handle errors** per tier system (ABORT/WARN/LOG)

## Completion

Return a summary of what you created:

\`\`\`
APO-1: Architecture Diagrams Complete

Files Created:
- docs/images/architecture-mvc-flow.md (MVC flow diagram)
- docs/images/database-schema.md (ER diagram with 8 entities)
- docs/images/api-endpoint-flow.md (30 endpoints)
- docs/images/component-hierarchy.md (11 components)

Total: 4 diagram files created

Self-Validation: ‚úÖ PASSED

Fallback Usage: [Yes/No] ([Description if used])

Status: Section A complete
\`\`\`
  `
});

// APO Instance 2: API Documentation & Guides
Task({
  subagent_type: "APO",
  description: "Generate API docs and guides",
  prompt: `
# APO-2: API Documentation & Guide Generation

**Your Mission:** Generate API documentation and developer guides using templates and JUNO's audit report.

## Error Handling Protocol (Rec 5)

**Tier 1: ABORT Conditions (Stop immediately, return error)**

ABORT if:
- ‚ùå Cannot read codebase (permission denied, files missing at system level)
- ‚ùå Cannot write output files (permission denied, disk full, directory creation fails)
- ‚ùå Critical templates completely missing AND cannot generate from scratch

**Tier 2: WARN and CONTINUE (Report issue, activate fallback)**

WARN if:
- ‚ö†Ô∏è JUNO section B incomplete/missing (use direct codebase analysis - see Phase 1.5)
- ‚ö†Ô∏è Some variable values missing (infer from codebase: package.json, route files, .env)
- ‚ö†Ô∏è Template file missing but can generate guide from scratch
- ‚ö†Ô∏è Testing framework not specified (detect from package.json)

**Tier 3: LOG INFO (Normal process updates)**

LOG if:
- ‚ÑπÔ∏è Reading templates
- ‚ÑπÔ∏è Creating guide files
- ‚ÑπÔ∏è Replacing variables
- ‚ÑπÔ∏è Writing output files

**Error Response Format:**

\`\`\`javascript
if (TIER_1_ERROR) {
  ERROR: "";
  ERROR: "‚ùå APO-2 CRITICAL ERROR: [Error description]";
  ERROR: "Cannot proceed with documentation generation.";
  ERROR: "";
  return "APO-2 ABORTED: [Reason]";
}

if (TIER_2_ERROR) {
  WARNING: "";
  WARNING: "‚ö†Ô∏è APO-2 WARNING: [Issue description]";
  WARNING: "Activating fallback mechanism...";
  WARNING: "";
  // Continue with fallback
}
\`\`\`

## Step 1: Read JUNO's Audit Report

Read the audit report at: **${audit_report_path}**

Find **SECTION B: API DOCUMENTATION & GUIDES**

This section contains your complete checklist of documentation to create.

**Check for Fallback Mode:**
\`\`\`javascript
if (global.trinity_docs_session.juno_incomplete) {
  LOG: "";
  LOG: "‚ö†Ô∏è FALLBACK MODE ACTIVATED";
  LOG: "JUNO report incomplete - will use direct codebase analysis for missing data";
  LOG: "";
}
\`\`\`

**Rec 12: Template Existence Verification**
\`\`\`javascript
LOG: "";
LOG: "Verifying template accessibility...";

const template_paths = {
  getting_started: "trinity/templates/documentation/guides/getting-started.md.template",
  api_development: "trinity/templates/documentation/guides/api-development.md.template",
  deployment: "trinity/templates/documentation/guides/deployment.md.template",
  contributing: "trinity/templates/documentation/guides/contributing.md.template",
  api_readme: "trinity/templates/documentation/api-docs/README.md.template"
};

const template_status = {};
let templates_found = 0;
let templates_missing = 0;

for (const [name, path] of Object.entries(template_paths)) {
  if (exists(path)) {
    template_status[name] = "FOUND";
    templates_found++;
    LOG: \`  ‚úÖ Template available: \${name} (\${path})\`;
  } else {
    template_status[name] = "MISSING";
    templates_missing++;
    WARNING: \`  ‚ö†Ô∏è Template missing: \${name} (\${path}) - will generate from scratch\`;
  }
}

LOG: "";
LOG: \`Template Availability: \${templates_found} found, \${templates_missing} missing\`;

if (templates_missing > 0) {
  WARNING: "";
  WARNING: \`‚ö†Ô∏è \${templates_missing} template(s) missing - activating generation fallback\`;
  WARNING: "This is NOT a failure - documentation will be generated from scratch";
  WARNING: "";
}

LOG: "";
\`\`\`

**Rec 13: Context Size Monitoring**
\`\`\`javascript
LOG: "Monitoring context size...";

const juno_report_content = Read("${audit_report_path}");
const juno_full_size = juno_report_content.length;

// Find Section B boundaries
const section_b_start = juno_report_content.indexOf("## SECTION B:");
const section_c_start = juno_report_content.indexOf("## SECTION C:");

let section_b_size = 0;
if (section_b_start !== -1 && section_c_start !== -1) {
  section_b_size = section_c_start - section_b_start;
} else if (section_b_start !== -1) {
  section_b_size = juno_report_content.length - section_b_start;
}

LOG: \`  Full JUNO report: \${(juno_full_size / 1024).toFixed(2)} KB (\${juno_full_size} chars)\`;
LOG: \`  Section B (my section): \${(section_b_size / 1024).toFixed(2)} KB (\${section_b_size} chars)\`;
LOG: \`  Context overhead: This prompt + report section = ~\${((section_b_size + 15000) / 1024).toFixed(2)} KB\`;

if (section_b_size > 50000) {
  WARNING: "";
  WARNING: \`‚ö†Ô∏è Large context detected: Section B is \${(section_b_size / 1024).toFixed(2)} KB\`;
  WARNING: "Consider JUNO optimization if this causes performance issues";
  WARNING: "";
}

LOG: "";
\`\`\`

## CRITICAL REQUIREMENT: Complete Content Only (Rec 7)

**ZERO TOLERANCE FOR PLACEHOLDER CONTENT**

The following are **STRICTLY PROHIBITED** in all core documentation:
- "Coming Soon" sections or messages
- "TODO" or "TBD" placeholders
- "Will be added later" references
- Empty sections with no content
- Links to guides that don't exist
- "See [future guide]" references
- "To be documented" notes
- Stub content or outlines without substance

**Core Documentation Files (MUST BE COMPLETE):**
1. docs/guides/getting-started.md
2. docs/api/development-guide.md
3. docs/guides/deployment.md
4. docs/guides/contributing.md

**Allowed References to Future Work:**
You MAY include a final section titled "Future Enhancements" or "Roadmap" that mentions planned features, but:
1. This section must be AFTER all core content
2. Must be clearly labeled as "future" or "planned"
3. Must not use "coming soon" language
4. Must not be a substitute for core documentation

**Acceptable Example:**
\`\`\`markdown
## Future Enhancements

The following enhancements are planned for future releases:
- Advanced monitoring with Prometheus integration
- Horizontal scaling guide for containerized deployments
- Security hardening checklist for production environments

These are aspirational features and not required for current deployment.
\`\`\`

**Unacceptable Examples:**
\`\`\`markdown
### Monitoring (Coming Soon)
[Will be added in future update]

### Security
See the security guide (coming soon) for details.

## Deployment
TODO: Add deployment steps
\`\`\`

**Self-Validation Check:**
Before completing, scan ALL generated files for prohibited content:
\`\`\`javascript
const prohibited_patterns = [
  /coming soon/gi,
  /to be added/gi,
  /will be added/gi,
  /\[TODO\]/gi,
  /\[TBD\]/gi,
  /to be documented/gi,
  /see .* \(coming soon\)/gi
];

for (const file of all_guide_files) {
  const content = Read(file);
  for (const pattern of prohibited_patterns) {
    if (pattern.test(content)) {
      ERROR: \`‚ùå Prohibited stub content in \${file}: \${content.match(pattern)[0]}\`;
      validation_results.complete_content = false;
    }
  }
}
\`\`\`

**If stub content is detected, you MUST:**
1. Remove the stub section entirely, OR
2. Replace it with actual, complete content using available information, OR
3. Move it to a "Future Enhancements" section at the end

**DO NOT return completion with stub content remaining.**

---

## Step 2: Generate Each Required File

For EACH file marked "Required: YES" in Section B:

### Process:
1. Read template file from path provided in SECTION B
2. Extract ALL variable values from SECTION B (JUNO pre-fills these)
3. Replace {{VARIABLES}} with actual values using global regex replacement
4. Apply fallback detection if any {{PLACEHOLDERS}} remain
5. Write final documentation to output path
6. Validate no placeholders remain

### Implementation:
\`\`\`javascript
// For each file in SECTION B marked "Required: YES":
const template = Read(file_spec.template_path);
let output = template;

// Replace all variables from SECTION B
for (const [variable, value] of Object.entries(file_spec.variables)) {
  output = output.replace(new RegExp(`\\{\\{${variable}\\}\\}`, 'g'), value);
}

// Fallback: Detect missing values from codebase
if (output.includes("{{")) {
  output = applyFallbackDetection(output); // See Tier 2 error handling
}

Write(file_spec.output_path, output);
LOG: \`‚úÖ Created: \${file_spec.output_path}\`;
\`\`\`

**Note:** Templates are comprehensive. JUNO SECTION B provides all values. Fallback activates automatically for missing data.

## Step 3: Self-Validation (Rec 6)

After generating all documentation, you MUST verify:

\`\`\`javascript
LOG: "";
LOG: "=== APO-2 SELF-VALIDATION ===";
LOG: "";

const created_guides = Glob({pattern: "docs/guides/*.md"});
const created_api_docs = Glob({pattern: "docs/api/*.md"});
const all_docs = [...created_guides, ...created_api_docs];

// Validation checks
const validation_results = {
  files_created: all_docs.length > 0,
  expected_count_met: true,
  no_placeholders: true,
  min_content_length: true,
  referenced_files_exist: true,
  complete_content: true,
  endpoint_completeness: true // Rec 10: Verify all endpoints documented
};

// Check 1: All expected files created
const juno_report = Read("${audit_report_path}");
const section_b = juno_report.match(/SECTION B:.*?(?=SECTION C:)/s);
if (section_b) {
  const expected_count = (section_b[0].match(/Required: YES/g) || []).length;
  validation_results.expected_count_met = all_docs.length === expected_count;

  if (!validation_results.expected_count_met) {
    ERROR: \`‚ùå Expected \${expected_count} files, created \${all_docs.length}\`;
  }
}

// Check 2: No {{PLACEHOLDERS}} in any file
for (const file of all_docs) {
  const content = Read(file);
  const placeholders = content.match(/\{\{[^}]+\}\}/g);

  if (placeholders) {
    validation_results.no_placeholders = false;
    ERROR: \`‚ùå Placeholders remaining in \${file}: \${placeholders.join(", ")}\`;
  }

  // Check 3: Substantial content
  if (content.length < 200) {
    validation_results.min_content_length = false;
    ERROR: \`‚ùå Content too short in \${file} (\${content.length} chars)\`;
  }

  // Check 4: Internal links valid (basic check for file:// or docs/ paths)
  const doc_links = content.match(/\[([^\]]+)\]\(docs\/[^)]+\)/g);
  if (doc_links) {
    for (const link of doc_links) {
      const link_path = link.match(/\(docs\/([^)]+)\)/)[1];
      const full_path = "docs/" + link_path;

      if (!exists(full_path)) {
        validation_results.referenced_files_exist = false;
        WARNING: \`‚ö†Ô∏è Link target doesn't exist: \${full_path} (referenced in \${file})\`;
      }
    }
  }

  // Check 5: No stub content (Rec 7)
  const prohibited_patterns = [
    /coming soon/gi,
    /to be added/gi,
    /will be added/gi,
    /\[TODO\]/gi,
    /\[TBD\]/gi,
    /to be documented/gi,
    /see .* \(coming soon\)/gi
  ];

  for (const pattern of prohibited_patterns) {
    if (pattern.test(content)) {
      const matches = content.match(pattern);
      if (matches) {
        validation_results.complete_content = false;
        ERROR: \`‚ùå Prohibited stub content in \${file}: \${matches[0]}\`;
      }
    }
  }
}

// Check 6: Endpoint Completeness (¬±3 tolerance)
const juno_endpoint_count = parseInt(juno_report_content.match(/API Endpoints:\s*(\d+)/)?.[1] || 0);
if (juno_endpoint_count > 0) {
  const api_guide = created_guides.find(f => f.includes('api-development'));
  if (api_guide) {
    const documented_count = (Read(api_guide).match(/(GET|POST|PUT|DELETE|PATCH)/g) || []).length;
    if (Math.abs(documented_count - juno_endpoint_count) > 3) {
      validation_results.endpoint_completeness = false;
      ERROR: \`‚ùå Endpoint mismatch: JUNO=\${juno_endpoint_count}, Docs=\${documented_count}\`;
    }
  }
}

// Validation summary
const all_passed = Object.values(validation_results).every(v => v === true);

if (!all_passed) {
  ERROR: "‚ùå APO-2 SELF-VALIDATION FAILED";
  for (const [check, passed] of Object.entries(validation_results)) {
    if (!passed) ERROR: \`   - \${check} failed\`;
  }
  ERROR: "Review JUNO report completeness and template paths";
  return { status: "FAILED", agent: "APO-2", reason: "Validation failed", details: validation_results };
}

LOG: "‚úÖ APO-2 SELF-VALIDATION PASSED";
for (const file of all_docs) {
  LOG: \`  ‚úÖ \${file}\`;
}
\`\`\`

## Critical Requirements

- ‚úÖ **Read JUNO's report** - All information should be pre-filled
- ‚úÖ **Activate fallback** if information missing (don't ABORT)
- ‚úÖ **Create EVERY file** marked "Required: YES"
- ‚úÖ **Use templates** when available - generate from scratch if missing
- ‚úÖ **Replace ALL variables** - No {{PLACEHOLDERS}} in output
- ‚úÖ **Write to correct paths** - Use output paths from report
- ‚úÖ **Self-validate** - Run validation checks before returning
- ‚úÖ **Handle errors** per tier system (ABORT/WARN/LOG)

## Completion

Return a summary of what you created:

\`\`\`
APO-2: API Documentation & Guides Complete

Files Created:
- docs/api/README.md (30 endpoints documented)
- docs/guides/getting-started.md (quick start guide)
- docs/guides/api-development.md (API development guide)
- docs/guides/deployment.md (deployment instructions)
- docs/guides/contributing.md (contribution guidelines)

Total: 5 documentation files created

Self-Validation: ‚úÖ PASSED

Fallback Usage: [Yes/No] ([Description if used])

Status: Section B complete
\`\`\`
  `
});

// APO Instance 3: Configuration Files
Task({
  subagent_type: "APO",
  description: "Generate configuration files",
  prompt: `
# APO-3: Configuration File Generation

**Your Mission:** Generate configuration and setup files using templates and JUNO's audit report.

## Error Handling Protocol (Rec 5)

**Tier 1: ABORT Conditions (Stop immediately, return error)**

ABORT if:
- ‚ùå Cannot read codebase (permission denied, files missing at system level)
- ‚ùå Cannot write output files (permission denied, disk full)
- ‚ùå Cannot read existing README.md for updating

**Tier 2: WARN and CONTINUE (Report issue, activate fallback)**

WARN if:
- ‚ö†Ô∏è JUNO section C incomplete/missing (use direct codebase analysis - see Phase 1.5)
- ‚ö†Ô∏è Environment variable keys missing (search codebase for process.env usage)
- ‚ö†Ô∏è .env file doesn't exist (still create .env.example with discovered keys)
- ‚ö†Ô∏è Documentation files don't exist yet (will be created by APO-2 in parallel)

**Tier 3: LOG INFO (Normal process updates)**

LOG if:
- ‚ÑπÔ∏è Reading .env file
- ‚ÑπÔ∏è Creating .env.example
- ‚ÑπÔ∏è Updating README.md
- ‚ÑπÔ∏è Validating documentation links

**Error Response Format:**

\`\`\`javascript
if (TIER_1_ERROR) {
  ERROR: "";
  ERROR: "‚ùå APO-3 CRITICAL ERROR: [Error description]";
  ERROR: "Cannot proceed with configuration file generation.";
  ERROR: "";
  return "APO-3 ABORTED: [Reason]";
}

if (TIER_2_ERROR) {
  WARNING: "";
  WARNING: "‚ö†Ô∏è APO-3 WARNING: [Issue description]";
  WARNING: "Activating fallback mechanism...";
  WARNING: "";
  // Continue with fallback
}
\`\`\`

## Step 1: Read JUNO's Audit Report

Read the audit report at: **${audit_report_path}**

Find **SECTION C: CONFIGURATION & SETUP**

This section contains your complete checklist of configuration files to create.

**Check for Fallback Mode:**
\`\`\`javascript
if (global.trinity_docs_session.juno_incomplete) {
  LOG: "";
  LOG: "‚ö†Ô∏è FALLBACK MODE ACTIVATED";
  LOG: "JUNO report incomplete - will use direct codebase analysis for missing data";
  LOG: "";
}
\`\`\`

**Rec 12: Template Existence Verification**
\`\`\`javascript
LOG: "";
LOG: "Verifying template accessibility...";

const template_paths = {
  env_example: "trinity/templates/documentation/config/env-example.md",
  readme_update: "trinity/templates/documentation/config/readme-update.md"
};

const template_status = {};
let templates_found = 0;
let templates_missing = 0;

for (const [name, path] of Object.entries(template_paths)) {
  if (exists(path)) {
    template_status[name] = "FOUND";
    templates_found++;
    LOG: \`  ‚úÖ Template available: \${name} (\${path})\`;
  } else {
    template_status[name] = "MISSING";
    templates_missing++;
    WARNING: \`  ‚ö†Ô∏è Template missing: \${name} (\${path}) - will generate from scratch\`;
  }
}

LOG: "";
LOG: \`Template Availability: \${templates_found} found, \${templates_missing} missing\`;

if (templates_missing > 0) {
  WARNING: "";
  WARNING: \`‚ö†Ô∏è \${templates_missing} template(s) missing - activating generation fallback\`;
  WARNING: "This is NOT a failure - configuration files will be generated from scratch";
  WARNING: "";
}

LOG: "";
\`\`\`

**Rec 13: Context Size Monitoring**
\`\`\`javascript
LOG: "Monitoring context size...";

const juno_report_content = Read("${audit_report_path}");
const juno_full_size = juno_report_content.length;

// Find Section C boundaries
const section_c_start = juno_report_content.indexOf("## SECTION C:");
const section_end = juno_report_content.length;

let section_c_size = 0;
if (section_c_start !== -1) {
  section_c_size = section_end - section_c_start;
}

LOG: \`  Full JUNO report: \${(juno_full_size / 1024).toFixed(2)} KB (\${juno_full_size} chars)\`;
LOG: \`  Section C (my section): \${(section_c_size / 1024).toFixed(2)} KB (\${section_c_size} chars)\`;
LOG: \`  Context overhead: This prompt + report section = ~\${((section_c_size + 12000) / 1024).toFixed(2)} KB\`;

if (section_c_size > 50000) {
  WARNING: "";
  WARNING: \`‚ö†Ô∏è Large context detected: Section C is \${(section_c_size / 1024).toFixed(2)} KB\`;
  WARNING: "Consider JUNO optimization if this causes performance issues";
  WARNING: "";
}

LOG: "";
\`\`\`

## Step 2: Generate Each Required File

For EACH file marked "Required: YES" in Section C:

### Process for .env.example:

\`\`\`javascript
// 1. Read template from SECTION C
const template_path = "trinity/templates/documentation/config/env-example-generator.md.template";
const template = Read(template_path);

// 2. Extract variables from SECTION C
const env_keys = file_spec.variables.ENV_KEYS; // From JUNO SECTION C
const project_name = file_spec.variables.PROJECT_NAME;
const port = file_spec.variables.PORT;

// 3. Apply rule-based generation from template
let env_example_content = "";
for (const key of env_keys) {
  const original_value = process.env[key] || "";
  const example_value = applyEnvRules(key, original_value, {
    project_name, 
    port, 
    discovered_endpoints: file_spec.variables.DISCOVERED_ENDPOINTS
  });
  env_example_content += \`\${key}=\${example_value}\n\`;
}

// 4. Write output
Write(".env.example", env_example_content);
LOG: "‚úÖ Created: .env.example";
\`\`\`

**Note:** Template contains all 11 rules. Apply in priority order (Rule 1 = highest). Fallback activates if keys missing from SECTION C.

### Process for README update:

\`\`\`javascript
// 1. Wait for filesystem stabilization (APO-2 runs in parallel)
await new Promise(resolve => setTimeout(resolve, 500));

// 2. Discover documentation files
const doc_files = [
  ...Glob({pattern: "docs/guides/*.md"}),
  ...Glob({pattern: "docs/api/*.md"}),
  ...Glob({pattern: "docs/images/*.md"})
];

// 3. Validate file count matches JUNO expectations
const juno_report = Read("${audit_report_path}");
const expected_count = (juno_report.match(/Output: docs\//g) || []).length;
if (doc_files.length < expected_count) {
  ERROR: \`‚ùå File check failed: Expected \${expected_count}, found \${doc_files.length}\`;
  return { status: "FAILED", agent: "APO-3", reason: "Documentation files missing" };
}

// 4. Build documentation section
let doc_section = "\n## Documentation\n\n";
for (const file_path of doc_files) {
  const content = Read(file_path);
  const title = content.match(/^#\s+(.+)$/m)?.[1] || path.basename(file_path, '.md');
  doc_section += \`- [\${title}](\${file_path})\n\`;
}

// 5. Update README
let readme = Read("README.md");
if (readme.includes("## Documentation")) {
  readme = readme.replace(/## Documentation[\s\S]*?(?=\n## |$)/, doc_section);
} else {
  readme += "\n" + doc_section;
}
Write("README.md", readme);

LOG: \`‚úÖ Updated README.md with \${doc_files.length} documentation links\`;
\`\`\`

**Note:** Waits 500ms for APO-2 file writes. Validates file count before adding links. No broken links possible (only existing files linked).
## Step 3: Self-Validation (Rec 6)

After generating all files, you MUST verify:

\`\`\`javascript
LOG: "";
LOG: "=== APO-3 SELF-VALIDATION ===";
LOG: "";

// Validation checks
const validation_results = {
  env_example_created: false,
  readme_updated: false,
  no_placeholders: true,
  min_content_length: true,
  readme_links_valid: true
};

// Check 1: .env.example created
const env_example_paths = [".env.example", "server/.env.example"];
for (const path of env_example_paths) {
  if (exists(path)) {
    validation_results.env_example_created = true;

    const env_content = Read(path);

    // Check for placeholders
    if (env_content.includes("{{") || env_content.includes("[YOUR_")) {
      validation_results.no_placeholders = false;
      ERROR: \`‚ùå Placeholders remaining in \${path}\`;
    }

    // Check for substantial content
    if (env_content.length < 50) {
      validation_results.min_content_length = false;
      ERROR: \`‚ùå .env.example too short (\${env_content.length} chars)\`;
    }
  }
}

// Check 2: README.md updated with Documentation section
const readme = Read("README.md");
validation_results.readme_updated = readme.includes("## Documentation");

if (!validation_results.readme_updated) {
  ERROR: "‚ùå README.md does not contain Documentation section";
}

// Check 3: README links valid (all referenced files should exist or be expected)
const readme_links = readme.matchAll(/\[([^\]]+)\]\(docs\/([^)]+)\)/g);
let broken_count = 0;

for (const link of readme_links) {
  const link_path = "docs/" + link[2];
  const link_text = link[1];

  // File should exist OR be in expected files list from JUNO
  const juno_report = Read("${audit_report_path}");
  const is_expected = juno_report.includes(link_path);

  if (!exists(link_path) && !is_expected) {
    broken_count++;
    WARNING: \`‚ö†Ô∏è README link target uncertain: \${link_text} -> \${link_path}\`;
  }
}

validation_results.readme_links_valid = broken_count === 0;

// Overall validation
const all_passed = Object.values(validation_results).every(v => v === true);

LOG: "Self-Validation Results:";
LOG: \`  .env.example created: \${validation_results.env_example_created ? "‚úÖ" : "‚ùå"}\`;
LOG: \`  README.md updated: \${validation_results.readme_updated ? "‚úÖ" : "‚ùå"}\`;
LOG: \`  No placeholders: \${validation_results.no_placeholders ? "‚úÖ" : "‚ùå"}\`;
LOG: \`  Content length: \${validation_results.min_content_length ? "‚úÖ" : "‚ùå"}\`;
LOG: \`  README links: \${validation_results.readme_links_valid ? "‚úÖ" : "‚ö†Ô∏è"}\`;
LOG: "";

if (!all_passed && (!validation_results.env_example_created || !validation_results.readme_updated || !validation_results.no_placeholders || !validation_results.min_content_length)) {
  ERROR: "";
  ERROR: "‚ùå APO-3 SELF-VALIDATION FAILED";
  ERROR: "";
  ERROR: "Validation Failures:";

  if (!validation_results.env_example_created) {
    ERROR: "   - .env.example file not created";
  }
  if (!validation_results.readme_updated) {
    ERROR: "   - README.md not updated";
  }
  if (!validation_results.no_placeholders) {
    ERROR: "   - Template placeholders remaining in output";
  }
  if (!validation_results.min_content_length) {
    ERROR: "   - Files with insufficient content detected";
  }

  ERROR: "";
  ERROR: "ABORTING APO-3 EXECUTION";
  ERROR: "Cannot proceed with invalid documentation.";
  ERROR: "";
  ERROR: "Root Cause Analysis:";
  ERROR: "This failure indicates one of:";
  ERROR: "  1. JUNO report was incomplete (missing data)";
  ERROR: "  2. Template access failed (file not found)";
  ERROR: "  3. Variable replacement logic failed";
  ERROR: "  4. File write operation failed";
  ERROR: "";
  ERROR: "Recommended Action:";
  ERROR: "  1. Review JUNO report completeness";
  ERROR: "  2. Verify template paths exist";
  ERROR: "  3. Check disk space and permissions";
  ERROR: "";

  // CRITICAL: Actually abort by returning error status
  return {
    status: "FAILED",
    agent: "APO-3",
    reason: "Self-validation failed",
    details: validation_results,
    files_created: 0
  };
}

// Only reach this point if validation passed
LOG: "";
LOG: "‚úÖ APO-3 SELF-VALIDATION PASSED";
LOG: "";

if (!validation_results.readme_links_valid) {
  WARNING: "";
  WARNING: "‚ö†Ô∏è Some README links may be broken (will be verified in Phase 3)";
  WARNING: "";
}
\`\`\`

## Critical Requirements

- ‚úÖ **Read JUNO's report** - All information should be pre-filled
- ‚úÖ **Activate fallback** if information missing (don't ABORT)
- ‚úÖ **Create EVERY file** marked "Required: YES"
- ‚úÖ **Use templates** when available - follow rule-based generation
- ‚úÖ **No empty values** - All .env keys must have sensible defaults
- ‚úÖ **Write to correct paths** - Use output paths from report
- ‚úÖ **Validate README links** - Ensure linked files exist or will exist
- ‚úÖ **Self-validate** - Run validation checks before returning
- ‚úÖ **Handle errors** per tier system (ABORT/WARN/LOG)

## Completion

Return a summary of what you created:

\`\`\`
APO-3: Configuration Files Complete

Files Created/Updated:
- .env.example (15 keys with sensible defaults)
- README.md (added Documentation section with [N] links)

Total: 2 files created/updated

Self-Validation: ‚úÖ PASSED

README Link Validation: [N] links validated, [N] expected from APO-2

Fallback Usage: [Yes/No] ([Description if used])

Status: Section C complete
\`\`\`
  `
});

LOG: "";
LOG: "‚è≥ Waiting for all 3 APO instances to complete...";
LOG: "";
```

### Step 2.2: Capture APO Results

```javascript
// After all 3 APO instances complete, capture their responses
const apo1_response = [APO-1's returned message];
const apo2_response = [APO-2's returned message];
const apo3_response = [APO-3's returned message];

// Track performance
global.trinity_docs_session.performance_metrics.apo_end = Date.now();

global.trinity_docs_session.apo_results = {
  diagrams: apo1_response,
  docs: apo2_response,
  config: apo3_response
};

// Rec 20: Graceful Degradation Mode
// Optional flag to allow partial success (default: false - strict mode)
const ALLOW_PARTIAL_SUCCESS = false; // Set to true to continue despite APO failures

LOG: "";
LOG: "=== APO FAILURE HANDLING MODE ===";
LOG: \`Mode: \${ALLOW_PARTIAL_SUCCESS ? "GRACEFUL DEGRADATION (partial success allowed)" : "STRICT (all APOs must succeed)"}\`;
LOG: "";

// Check for failure status (Rec 6: Enforce APO Self-Validation Abort)
function apo_failed(response) {
  return typeof response === 'object' && response.status === 'FAILED';
}

const failures = {
  apo1: apo_failed(apo1_response),
  apo2: apo_failed(apo2_response),
  apo3: apo_failed(apo3_response)
};

const failure_count = Object.values(failures).filter(f => f).length;

if (failure_count > 0 && !ALLOW_PARTIAL_SUCCESS) {
  // STRICT MODE: Any failure causes ABORT
  LOG: "Strict mode enabled - any APO failure causes ABORT";
  LOG: "";
}

if (failures.apo1 && !ALLOW_PARTIAL_SUCCESS) {
  ERROR: "";
  ERROR: "‚ùå APO-1 FAILED - Documentation generation aborted";
  ERROR: \`Reason: \${apo1_response.reason}\`;
  ERROR: \`Details: \${JSON.stringify(apo1_response.details, null, 2)}\`;
  ERROR: "";
  ABORT_COMMAND();
}

if (failures.apo2 && !ALLOW_PARTIAL_SUCCESS) {
  ERROR: "";
  ERROR: "‚ùå APO-2 FAILED - Documentation generation aborted";
  ERROR: \`Reason: \${apo2_response.reason}\`;
  ERROR: \`Details: \${JSON.stringify(apo2_response.details, null, 2)}\`;
  ERROR: "";
  ABORT_COMMAND();
}

if (failures.apo3 && !ALLOW_PARTIAL_SUCCESS) {
  ERROR: "";
  ERROR: "‚ùå APO-3 FAILED - Documentation generation aborted";
  ERROR: \`Reason: \${apo3_response.reason}\`;
  ERROR: \`Details: \${JSON.stringify(apo3_response.details, null, 2)}\`;
  ERROR: "";
  ABORT_COMMAND();
}

// Handle graceful degradation mode (Rec 20)
if (ALLOW_PARTIAL_SUCCESS && failure_count > 0) {
  WARNING: "";
  WARNING: "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó";
  WARNING: "‚ïë  ‚ö†Ô∏è GRACEFUL DEGRADATION MODE ACTIVE                    ‚ïë";
  WARNING: "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù";
  WARNING: "";
  WARNING: \`\${failure_count} APO(s) failed but partial success mode is enabled\`;
  WARNING: "Continuing with available documentation...";
  WARNING: "";

  if (failures.apo1) {
    WARNING: "  ‚ùå APO-1 (Diagrams) FAILED";
    WARNING: \`     Reason: \${apo1_response.reason}\`;
  }
  if (failures.apo2) {
    WARNING: "  ‚ùå APO-2 (Guides) FAILED";
    WARNING: \`     Reason: \${apo2_response.reason}\`;
  }
  if (failures.apo3) {
    WARNING: "  ‚ùå APO-3 (Config) FAILED";
    WARNING: \`     Reason: \${apo3_response.reason}\`;
  }

  WARNING: "";
  WARNING: "IMPACT:";
  WARNING: "  - Quality score will reflect incomplete deliverables";
  WARNING: "  - Verification will show missing sections";
  WARNING: "  - Manual completion may be required for failed sections";
  WARNING: "";
  WARNING: "Continuing to verification phase with partial results...";
  WARNING: "";
}

// All APOs succeeded (or graceful degradation active) - continue to verification
if (failure_count === 0) {
  LOG: "‚úÖ All 3 APO instances completed successfully";
} else {
  LOG: \`‚ö†Ô∏è Partial success: \${3 - failure_count}/3 APO instances succeeded\`;
}
LOG: "";
LOG: "‚úÖ All 3 APO instances completed successfully";
LOG: "";
if (!failures.apo1) LOG: "APO-1: Architecture diagrams generated";
if (!failures.apo2) LOG: "APO-2: API documentation and guides generated";
if (!failures.apo3) LOG: "APO-3: Configuration files generated";
LOG: "";

// Rec 8: APO Coordination Mechanism - Synchronization Barrier
LOG: "=== SYNCHRONIZATION BARRIER ===";
LOG: "";
LOG: "Ensuring all APO-generated files are available before verification...";
LOG: "";

// Wait for filesystem stabilization (parallel execution may have race conditions)
await new Promise(resolve => setTimeout(resolve, 500));

// Verify file availability
const expected_files = {
  diagrams: Glob({pattern: "docs/images/*.md"}),
  guides: Glob({pattern: "docs/guides/*.md"}),
  api_docs: Glob({pattern: "docs/api/*.md"}),
  config: Glob({pattern: "**/.env.example"})
};

const file_counts = {
  diagrams: expected_files.diagrams.length,
  guides: expected_files.guides.length,
  api_docs: expected_files.api_docs.length,
  config: expected_files.config.length
};

LOG: `File Availability Check:`;
LOG: `  - Diagrams: ${file_counts.diagrams} files`;
LOG: `  - Guides: ${file_counts.guides} files`;
LOG: `  - API Docs: ${file_counts.api_docs} files`;
LOG: `  - Config: ${file_counts.config} files`;
LOG: `  - Total: ${file_counts.diagrams + file_counts.guides + file_counts.api_docs + file_counts.config} files`;
LOG: "";

// Check if any files are missing (basic sanity check)
const total_files = file_counts.diagrams + file_counts.guides + file_counts.api_docs + file_counts.config;

if (total_files === 0) {
  ERROR: "";
  ERROR: "‚ùå SYNCHRONIZATION BARRIER FAILED";
  ERROR: "No documentation files detected after APO execution.";
  ERROR: "This indicates APOs may have failed silently or files are not being created.";
  ERROR: "";
  ERROR: "File counts detected:";
  ERROR: `  - Diagrams: ${file_counts.diagrams}`;
  ERROR: `  - Guides: ${file_counts.guides}`;
  ERROR: `  - API Docs: ${file_counts.api_docs}`;
  ERROR: `  - Config: ${file_counts.config}`;
  ERROR: "";
  ABORT_COMMAND();
}

LOG: "‚úÖ Synchronization barrier passed - files are available";
LOG: "";
```

---

## Phase 3: Enhanced Verification (Rec 7)

**Purpose:** Verify all documentation from checklist was created AND validate content quality

### Step 3.1: Read JUNO's Audit Report

```javascript
LOG: "=== PHASE 3: ENHANCED VERIFICATION ===";
LOG: "";
LOG: "Reading JUNO's audit report to verify completeness...";
LOG: "";

// Track performance
global.trinity_docs_session.performance_metrics.verification_start = Date.now();

const audit_report = Read(audit_report_path);

// Parse expected file counts from report
let expected_diagrams = 0;
let expected_guides = 0;
let expected_api_docs = 0;
let expected_config = 0;

// Count "Required: YES" items in each section
const section_a = audit_report.match(/SECTION A:.*?(?=SECTION B:)/s);
const section_b = audit_report.match(/SECTION B:.*?(?=SECTION C:)/s);
const section_c = audit_report.match(/SECTION C:.*$/s);

if (section_a) {
  expected_diagrams = (section_a[0].match(/Required: YES/g) || []).length;
}

if (section_b) {
  const required_count = (section_b[0].match(/Required: YES/g) || []).length;
  // Separate guides from API docs
  expected_guides = required_count > 0 ? required_count - 1 : 0; // Assume 1 API doc + N guides
  expected_api_docs = required_count > 0 ? 1 : 0;
}

if (section_c) {
  expected_config = (section_c[0].match(/Required: YES/g) || []).length;
}

LOG: `Expected documentation:`;
LOG: `  - Diagrams: ${expected_diagrams} files`;
LOG: `  - Guides: ${expected_guides} files`;
LOG: `  - API Docs: ${expected_api_docs} files`;
LOG: `  - Config: ${expected_config} files`;
LOG: `  - Total: ${expected_diagrams + expected_guides + expected_api_docs + expected_config} files`;
LOG: "";
```

### Step 3.2: Verify File Creation (Tier 1: Completion)

```javascript
LOG: "=== TIER 1: FILE COMPLETION VERIFICATION ===";
LOG: "";
LOG: "Checking if all expected files were created...";
LOG: "";

// Check diagrams
const diagram_files = Glob({pattern: "docs/images/*.md"});
const diagrams_ok = diagram_files.length === expected_diagrams;

LOG: `Diagrams: ${diagram_files.length}/${expected_diagrams} ${diagrams_ok ? "‚úÖ" : "‚ùå"}`;
for (const file of diagram_files) {
  LOG: `  ‚úÖ ${file}`;
}

if (!diagrams_ok) {
  ERROR: "";
  ERROR: `‚ùå Diagram count mismatch: expected ${expected_diagrams}, got ${diagram_files.length}`;
}

// Check guides
const guide_files = Glob({pattern: "docs/guides/*.md"});
const guides_ok = guide_files.length === expected_guides;

LOG: `Guides: ${guide_files.length}/${expected_guides} ${guides_ok ? "‚úÖ" : "‚ùå"}`;
for (const file of guide_files) {
  LOG: `  ‚úÖ ${file}`;
}

if (!guides_ok) {
  ERROR: "";
  ERROR: `‚ùå Guide count mismatch: expected ${expected_guides}, got ${guide_files.length}`;
}

// Check API docs
const api_doc_files = Glob({pattern: "docs/api/*.md"});
const api_docs_ok = api_doc_files.length === expected_api_docs;

LOG: `API Docs: ${api_doc_files.length}/${expected_api_docs} ${api_docs_ok ? "‚úÖ" : "‚ùå"}`;
for (const file of api_doc_files) {
  LOG: `  ‚úÖ ${file}`;
}

if (!api_docs_ok) {
  ERROR: "";
  ERROR: `‚ùå API doc count mismatch: expected ${expected_api_docs}, got ${api_doc_files.length}`;
}

// Check config files
const env_example_exists = Glob({pattern: "**/.env.example"}).length > 0;
const config_ok = env_example_exists;

LOG: `Config: ${config_ok ? "1/1" : "0/1"} ${config_ok ? "‚úÖ" : "‚ùå"}`;
if (env_example_exists) {
  LOG: "  ‚úÖ .env.example";
}

if (!config_ok) {
  ERROR: "";
  ERROR: "‚ùå .env.example file missing";
}

// Tier 1 overall
const tier1_passed = diagrams_ok && guides_ok && api_docs_ok && config_ok;

LOG: "";
if (tier1_passed) {
  LOG: "‚úÖ TIER 1 (COMPLETION): PASSED";
} else {
  ERROR: "‚ùå TIER 1 (COMPLETION): FAILED";
  ERROR: "";
  ERROR: "Not all expected files were created.";
  ERROR: "Review APO execution logs to identify failures.";
  ERROR: "";
  ABORT_COMMAND();
}

LOG: "";
```

### Step 3.3: Content Quality Verification (Tier 2)

```javascript
LOG: "=== TIER 2: CONTENT QUALITY VERIFICATION ===";
LOG: "";

const all_docs = [...diagram_files, ...guide_files, ...api_doc_files];

const verification_issues = {
  template_placeholders: [],
  broken_links: [],
  mermaid_errors: [],
  short_content: [],
  stub_content: [] // Rec 22: Stub content detection
};

// Check 1: Template Placeholder Detection
LOG: "Checking for template placeholders ({{VARIABLE}} syntax)...";

for (const file of all_docs) {
  const content = Read(file);
  const placeholders = content.match(/\{\{[^}]+\}\}/g);

  if (placeholders) {
    for (const ph of placeholders) {
      verification_issues.template_placeholders.push({
        file: file,
        placeholder: ph
      });
    }
  }
}

if (verification_issues.template_placeholders.length === 0) {
  LOG: "  ‚úÖ No template placeholders found";
} else {
  LOG: `  ‚ùå Found ${verification_issues.template_placeholders.length} template placeholders`;
  for (const issue of verification_issues.template_placeholders) {
    ERROR: `     ${issue.file}: ${issue.placeholder}`;
  }
}

// Check 2: Internal Link Validation
LOG: "";
LOG: "Validating internal markdown links...";

for (const file of all_docs) {
  const content = Read(file);
  const markdown_links = content.matchAll(/\[([^\]]+)\]\(([^)]+)\)/g);

  for (const link of markdown_links) {
    const link_text = link[1];
    const link_target = link[2];

    // Skip external links and anchors
    if (link_target.startsWith('http') || link_target.startsWith('#')) {
      continue;
    }

    // Resolve relative path
    const file_dir = file.split('/').slice(0, -1).join('/');
    let resolved_path = link_target;

    // Handle ../
    if (link_target.startsWith('../')) {
      const parts = link_target.split('/');
      const up_levels = parts.filter(p => p === '..').length;
      const dir_parts = file_dir.split('/');
      const base = dir_parts.slice(0, dir_parts.length - up_levels).join('/');
      const rest = parts.filter(p => p !== '..').join('/');
      resolved_path = base + '/' + rest;
    } else if (link_target.startsWith('./')) {
      resolved_path = file_dir + '/' + link_target.slice(2);
    } else if (!link_target.startsWith('/')) {
      resolved_path = file_dir + '/' + link_target;
    } else {
      resolved_path = link_target.slice(1); // Remove leading /
    }

    // Check if target exists
    if (!exists(resolved_path)) {
      verification_issues.broken_links.push({
        file: file,
        link_text: link_text,
        target: link_target,
        resolved: resolved_path
      });
    }
  }
}

if (verification_issues.broken_links.length === 0) {
  LOG: "  ‚úÖ All internal links valid";
} else {
  LOG: `  ‚ùå Found ${verification_issues.broken_links.length} broken links`;
  for (const issue of verification_issues.broken_links) {
    ERROR: `     ${issue.file}: [${issue.link_text}](${issue.target}) -> ${issue.resolved} (NOT FOUND)`;
  }
}

// Check 3: Mermaid Syntax Validation
LOG: "";
LOG: "Validating Mermaid diagram syntax...";

for (const file of diagram_files) {
  const content = Read(file);
  const mermaid_match = content.match(/```mermaid([\s\S]+?)```/);

  if (!mermaid_match) {
    verification_issues.mermaid_errors.push({
      file: file,
      error: "No Mermaid code block found (missing ```mermaid)"
    });
    continue;
  }

  const mermaid_block = mermaid_match[1].trim();

  // Validate diagram type
  const valid_types = ['graph', 'flowchart', 'sequenceDiagram', 'erDiagram', 'classDiagram', 'stateDiagram', 'journey', 'gantt'];
  const has_valid_type = valid_types.some(type => mermaid_block.startsWith(type));

  if (!has_valid_type) {
    verification_issues.mermaid_errors.push({
      file: file,
      error: `Invalid diagram type. Must start with one of: ${valid_types.join(', ')}`
    });
    continue;
  }

  // Check for minimum content
  if (mermaid_block.length < 50) {
    verification_issues.mermaid_errors.push({
      file: file,
      error: `Mermaid block too short (${mermaid_block.length} chars, expected 50+)`
    });
    continue;
  }

  // Check for placeholders in Mermaid
  if (mermaid_block.includes("{{") || mermaid_block.includes("[Add ") || mermaid_block.includes("[Define ")) {
    verification_issues.mermaid_errors.push({
      file: file,
      error: "Mermaid block contains placeholders or incomplete syntax"
    });
    continue;
  }
}

if (verification_issues.mermaid_errors.length === 0) {
  LOG: "  ‚úÖ All Mermaid diagrams valid";
} else {
  LOG: `  ‚ùå Found ${verification_issues.mermaid_errors.length} Mermaid errors`;
  for (const issue of verification_issues.mermaid_errors) {
    ERROR: `     ${issue.file}: ${issue.error}`;
  }
}

// Check 4: Content Length (short files may indicate incomplete generation)
LOG: "";
LOG: "Checking content length...";

for (const file of all_docs) {
  const content = Read(file);
  const min_length = file.includes('/images/') ? 100 : 200; // Diagrams can be shorter

  if (content.length < min_length) {
    verification_issues.short_content.push({
      file: file,
      length: content.length,
      expected: min_length
    });
  }
}

if (verification_issues.short_content.length === 0) {
  LOG: "  ‚úÖ All files have substantial content";
} else {
  LOG: `  ‚ö†Ô∏è Found ${verification_issues.short_content.length} short files`;
  for (const issue of verification_issues.short_content) {
    WARNING: `     ${issue.file}: ${issue.length} chars (expected ${issue.expected}+)`;
  }
}

// Check 5: Stub Content Detection (Rec 22)
LOG: "";
LOG: "Checking for stub content (coming soon, TODO, etc.)...";

verification_issues.stub_content = [];

const stub_patterns = [
  /coming soon/gi,
  /to be added/gi,
  /will be added/gi,
  /\[TODO\]/gi,
  /\[TBD\]/gi,
  /to be documented/gi,
  /see .* \(coming soon\)/gi,
  /placeholder/gi,
  /under construction/gi,
  /work in progress/gi
];

for (const file of all_docs) {
  const content = Read(file);

  for (const pattern of stub_patterns) {
    const matches = content.match(pattern);
    if (matches) {
      // Check if stub content is in acceptable context (Future Enhancements section)
      const has_future_section = content.match(/##+ Future Enhancements|##+ Roadmap|##+ Coming Soon/i);

      // If stub content found, check context
      let in_future_section = false;
      if (has_future_section) {
        // Simple heuristic: check if match is after Future Enhancements heading
        const future_section_index = content.search(/##+ Future Enhancements|##+ Roadmap|##+ Coming Soon/i);
        const match_index = content.search(pattern);
        in_future_section = match_index > future_section_index;
      }

      if (!in_future_section) {
        verification_issues.stub_content.push({
          file: file,
          pattern: matches[0],
          context: content.substring(Math.max(0, content.search(pattern) - 50), Math.min(content.length, content.search(pattern) + 100))
        });
      }
    }
  }
}

if (verification_issues.stub_content.length === 0) {
  LOG: "  ‚úÖ No stub content detected";
} else {
  LOG: `  ‚ùå Found ${verification_issues.stub_content.length} instances of stub content`;
  for (const issue of verification_issues.stub_content) {
    ERROR: `     ${issue.file}: "${issue.pattern}"`;
  }
}

// Rec 16: Fail-Fast Logic - ABORT immediately on first critical failure
// Check each issue type and ABORT with specific error messages

LOG: "";

// Check 1: Template Placeholders (CRITICAL)
if (verification_issues.template_placeholders.length > 0) {
  ERROR: "";
  ERROR: "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó";
  ERROR: "‚ïë  ‚ùå CRITICAL FAILURE: TEMPLATE PLACEHOLDERS DETECTED     ‚ïë";
  ERROR: "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù";
  ERROR: "";
  ERROR: `Found ${verification_issues.template_placeholders.length} unreplaced template variables in documentation:`;
  ERROR: "";
  for (const issue of verification_issues.template_placeholders) {
    ERROR: `  File: ${issue.file}`;
    ERROR: `  Placeholder: ${issue.placeholder}`;
    ERROR: "";
  }
  ERROR: "ROOT CAUSE ANALYSIS:";
  ERROR: "  1. APO did not replace all {{VARIABLE}} placeholders";
  ERROR: "  2. JUNO report may have incomplete variable values";
  ERROR: "  3. Template files may have undocumented variables";
  ERROR: "";
  ERROR: "RESOLUTION:";
  ERROR: "  - Check JUNO report for missing variable values";
  ERROR: "  - Verify APO read and processed JUNO report correctly";
  ERROR: "  - Ensure templates use only documented variables";
  ERROR: "";
  ERROR: "Documentation generation ABORTED - placeholders must be resolved.";
  ERROR: "";
  ABORT_COMMAND();
}

// Check 2: Broken Links (CRITICAL)
if (verification_issues.broken_links.length > 0) {
  ERROR: "";
  ERROR: "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó";
  ERROR: "‚ïë  ‚ùå CRITICAL FAILURE: BROKEN LINKS DETECTED              ‚ïë";
  ERROR: "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù";
  ERROR: "";
  ERROR: `Found ${verification_issues.broken_links.length} broken internal links in documentation:`;
  ERROR: "";
  for (const issue of verification_issues.broken_links) {
    ERROR: `  File: ${issue.file}`;
    ERROR: `  Link: [${issue.link_text}](${issue.target})`;
    ERROR: `  Resolved Path: ${issue.resolved}`;
    ERROR: `  Status: NOT FOUND`;
    ERROR: "";
  }
  ERROR: "ROOT CAUSE ANALYSIS:";
  ERROR: "  1. APO created links to files that don't exist";
  ERROR: "  2. JUNO report listed files that APO didn't create";
  ERROR: "  3. File paths in documentation don't match actual structure";
  ERROR: "";
  ERROR: "RESOLUTION:";
  ERROR: "  - Verify all expected files were created by APOs";
  ERROR: "  - Check JUNO report file paths match actual output paths";
  ERROR: "  - Ensure APO-3 README validation passed";
  ERROR: "";
  ERROR: "Documentation generation ABORTED - broken links unacceptable.";
  ERROR: "";
  ABORT_COMMAND();
}

// Check 3: Mermaid Syntax Errors (CRITICAL)
if (verification_issues.mermaid_errors.length > 0) {
  ERROR: "";
  ERROR: "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó";
  ERROR: "‚ïë  ‚ùå CRITICAL FAILURE: INVALID MERMAID SYNTAX            ‚ïë";
  ERROR: "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù";
  ERROR: "";
  ERROR: `Found ${verification_issues.mermaid_errors.length} Mermaid syntax errors in diagrams:`;
  ERROR: "";
  for (const issue of verification_issues.mermaid_errors) {
    ERROR: `  File: ${issue.file}`;
    ERROR: `  Error: ${issue.error}`;
    ERROR: "";
  }
  ERROR: "ROOT CAUSE ANALYSIS:";
  ERROR: "  1. APO-1 generated invalid Mermaid syntax";
  ERROR: "  2. Template files contain invalid Mermaid structure";
  ERROR: "  3. JUNO report provided malformed data for diagrams";
  ERROR: "";
  ERROR: "RESOLUTION:";
  ERROR: "  - Verify templates have valid Mermaid syntax";
  ERROR: "  - Check JUNO report entity/relationship data is well-formed";
  ERROR: "  - Ensure APO-1 self-validation caught this before completion";
  ERROR: "";
  ERROR: "Documentation generation ABORTED - invalid diagrams unacceptable.";
  ERROR: "";
  ABORT_COMMAND();
}

// Check 4: Stub Content (CRITICAL) - Rec 22
if (verification_issues.stub_content.length > 0) {
  ERROR: "";
  ERROR: "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó";
  ERROR: "‚ïë  ‚ùå CRITICAL FAILURE: STUB CONTENT DETECTED              ‚ïë";
  ERROR: "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù";
  ERROR: "";
  ERROR: `Found ${verification_issues.stub_content.length} instances of stub content in documentation:`;
  ERROR: "";
  for (const issue of verification_issues.stub_content) {
    ERROR: `  File: ${issue.file}`;
    ERROR: `  Pattern: "${issue.pattern}"`;
    ERROR: `  Context: ${issue.context.substring(0, 100)}...`;
    ERROR: "";
  }
  ERROR: "ROOT CAUSE ANALYSIS:";
  ERROR: "  1. APO-2 generated incomplete documentation with placeholder text";
  ERROR: "  2. JUNO report provided insufficient data for complete documentation";
  ERROR: "  3. Documentation was rushed and contains 'TODO' or 'coming soon' markers";
  ERROR: "";
  ERROR: "RESOLUTION:";
  ERROR: "  - Ensure JUNO report provides complete, actionable data";
  ERROR: "  - Verify APO-2 completes all documentation sections";
  ERROR: "  - Remove all stub content - documentation must be production-ready";
  ERROR: "  - Only 'Future Enhancements' sections may reference future features";
  ERROR: "";
  ERROR: "Documentation generation ABORTED - stub content unacceptable for production.";
  ERROR: "";
  ABORT_COMMAND();
}

// Check 5: Short Content (WARNING only - not critical)
if (verification_issues.short_content.length > 0) {
  WARNING: "";
  WARNING: `‚ö†Ô∏è WARNING: ${verification_issues.short_content.length} files have minimal content`;
  for (const issue of verification_issues.short_content) {
    WARNING: `  ${issue.file}: ${issue.length} chars (expected ${issue.expected}+)`;
  }
  WARNING: "";
  WARNING: "This may indicate incomplete documentation but does not block generation.";
  WARNING: "";
}

// All Tier 2 checks passed
LOG: "‚úÖ TIER 2 (CONTENT QUALITY): PASSED - No critical issues detected";
LOG: "";
```

### Step 3.4: Accuracy Verification (Tier 3 - Warnings Only)

```javascript
LOG: "=== TIER 3: ACCURACY VERIFICATION (NON-BLOCKING) ===";
LOG: "";

const accuracy_warnings = [];

// Check 1: API Endpoint Count Accuracy (Rec 14: Enhanced Regex Patterns)
LOG: "Checking API endpoint count accuracy...";

// Count documented endpoints in API docs (using multiple patterns)
let documented_endpoint_count = 0;
if (api_doc_files.length > 0) {
  const api_content = Read(api_doc_files[0]);

  // Rec 14: Multiple endpoint detection patterns
  const endpoint_patterns = [
    // Markdown list format: - GET /api/users
    /^[-*]\s+(GET|POST|PUT|PATCH|DELETE)\s+\/[^\s\n]+/gm,
    // Direct format: GET /api/users
    /^(GET|POST|PUT|PATCH|DELETE)\s+\/[^\s\n]+/gm,
    // Heading format: ### GET /api/users
    /^#{1,6}\s+(GET|POST|PUT|PATCH|DELETE)\s+\/[^\s\n]+/gm,
    // Bold format: **GET /api/users**
    /\*\*(GET|POST|PUT|PATCH|DELETE)\s+\/[^\s\n]+\*\*/gm,
    // Code format: `GET /api/users`
    /`(GET|POST|PUT|PATCH|DELETE)\s+\/[^\s\n]+`/gm
  ];

  const found_endpoints = new Set();

  for (const pattern of endpoint_patterns) {
    const matches = api_content.matchAll(pattern);
    for (const match of matches) {
      // Extract method and path
      const full_match = match[0];
      const method_match = full_match.match(/(GET|POST|PUT|PATCH|DELETE)/);
      const path_match = full_match.match(/\/[^\s\n`*]+/);

      if (method_match && path_match) {
        const endpoint_key = `${method_match[0]} ${path_match[0]}`;
        found_endpoints.add(endpoint_key);
      }
    }
  }

  documented_endpoint_count = found_endpoints.size;

  LOG: `  Detection patterns used: ${endpoint_patterns.length}`;
  LOG: `  Unique endpoints found: ${documented_endpoint_count}`;
}

// Count actual endpoints in codebase
const route_patterns = [
  "server/routes/**/*.{ts,js}",
  "src/routes/**/*.{ts,js}",
  "api/**/*.{ts,js}",
  "server/api/**/*.{ts,js}"
];

let actual_endpoint_count = 0;
for (const pattern of route_patterns) {
  const route_files = Glob({pattern: pattern});

  for (const route_file of route_files) {
    const content = Read(route_file);
    const http_methods = ['get', 'post', 'put', 'patch', 'delete'];

    for (const method of http_methods) {
      const regex = new RegExp(`\\.(${method})\\(['"\`]([^'"\`]+)['"\`]`, 'g');
      const matches = content.match(regex);
      actual_endpoint_count += matches ? matches.length : 0;
    }
  }
}

const endpoint_diff = Math.abs(documented_endpoint_count - actual_endpoint_count);

// Rec 14: Increased tolerance from ¬±1 to ¬±5 (reduces false warnings)
if (endpoint_diff > 5) {
  accuracy_warnings.push({
    severity: "MEDIUM",
    category: "API Documentation",
    issue: `Endpoint count mismatch: documented ${documented_endpoint_count}, actual ${actual_endpoint_count} (diff: ${endpoint_diff})`
  });
}

LOG: `  Documented endpoints: ${documented_endpoint_count}`;
LOG: `  Actual endpoints: ${actual_endpoint_count}`;
LOG: `  Difference: ${endpoint_diff} ${endpoint_diff <= 5 ? "‚úÖ" : "‚ö†Ô∏è"} (tolerance: ¬±5)`;

// Check 2: Component Count Accuracy (if frontend detected)
LOG: "";
LOG: "Checking component count accuracy...";

// Count components mentioned in component hierarchy diagram
let documented_component_count = 0;
const component_diagrams = diagram_files.filter(f => f.includes('component-hierarchy'));

if (component_diagrams.length > 0) {
  const diagram_content = Read(component_diagrams[0]);
  // Count nodes in Mermaid flowchart (rough estimate)
  const node_matches = diagram_content.match(/[A-Z][a-zA-Z0-9_]+(?=\[|-->)/g);
  documented_component_count = node_matches ? new Set(node_matches).size : 0;
}

// Count actual component files
const component_patterns = [
  "client/**/*.{tsx,jsx}",
  "src/**/*.{tsx,jsx}",
  "client/**/*.vue",
  "src/**/*.vue"
];

let actual_component_count = 0;
for (const pattern of component_patterns) {
  const files = Glob({pattern: pattern});
  // Filter out test files, main files, index files
  const actual = files.filter(f =>
    !f.includes('.test.') &&
    !f.includes('.spec.') &&
    !f.endsWith('main.tsx') &&
    !f.endsWith('index.tsx')
  );
  actual_component_count += actual.length;
}

const component_diff = Math.abs(documented_component_count - actual_component_count);

if (component_diff > 2) {
  accuracy_warnings.push({
    severity: "LOW",
    category: "Component Documentation",
    issue: `Component count mismatch: documented ${documented_component_count}, actual ${actual_component_count} (diff: ${component_diff})`
  });
}

LOG: `  Documented components: ${documented_component_count}`;
LOG: `  Actual components: ${actual_component_count}`;
LOG: `  Difference: ${component_diff} ${component_diff <= 2 ? "‚úÖ" : "‚ö†Ô∏è"}`;

// Check 3: Testing Framework Accuracy
LOG: "";
LOG: "Checking testing framework accuracy...";

// Check what's mentioned in getting-started guide
let documented_framework = "None";
const getting_started = guide_files.find(f => f.includes('getting-started'));

if (getting_started) {
  const guide_content = Read(getting_started);

  if (guide_content.includes("Jest")) {
    documented_framework = "Jest";
  } else if (guide_content.includes("Vitest")) {
    documented_framework = "Vitest";
  } else if (guide_content.includes("Mocha")) {
    documented_framework = "Mocha";
  }
}

// Detect actual testing framework
let actual_framework = "None";
const pkg = JSON.parse(Read("package.json"));

if (pkg.devDependencies?.jest || pkg.dependencies?.jest) {
  actual_framework = "Jest";
} else if (pkg.devDependencies?.vitest || pkg.dependencies?.vitest) {
  actual_framework = "Vitest";
} else if (pkg.devDependencies?.mocha || pkg.dependencies?.mocha) {
  actual_framework = "Mocha";
}

if (documented_framework !== actual_framework) {
  accuracy_warnings.push({
    severity: "HIGH",
    category: "Testing Framework",
    issue: `Framework mismatch: documented "${documented_framework}", actual "${actual_framework}"`
  });
}

LOG: `  Documented framework: ${documented_framework}`;
LOG: `  Actual framework: ${actual_framework}`;
LOG: `  Match: ${documented_framework === actual_framework ? "‚úÖ" : "‚ö†Ô∏è"}`;

// Tier 3 Summary
LOG: "";
if (accuracy_warnings.length === 0) {
  LOG: "‚úÖ TIER 3 (ACCURACY): PASSED - No inaccuracies detected";
} else {
  WARNING: "";
  WARNING: `‚ö†Ô∏è TIER 3 (ACCURACY): ${accuracy_warnings.length} WARNINGS`;
  WARNING: "";
  WARNING: "Documentation contains minor inaccuracies (non-blocking):";
  for (const warning of accuracy_warnings) {
    WARNING: `   [${warning.severity}] ${warning.category}: ${warning.issue}`;
  }
  WARNING: "";
  WARNING: "These do not block deployment but should be reviewed.";
  WARNING: "";
}

LOG: "";
```

### Step 3.5: Generate Verification Report

```javascript
LOG: "Generating verification report...";
LOG: "";

const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
const report_path = `trinity/reports/VERIFICATION-REPORT-${timestamp}.md`;

// Rec 15: Performance timing variables (estimated for individual phases)
const apo1_time = "N/A"; // Individual APO times not tracked (parallel execution)
const apo2_time = "N/A";
const apo3_time = "N/A";
const tier1_time = "~1s"; // Estimated based on typical execution
const tier2_time = "~2s";
const tier3_time = "~1s";
const tier4_time = "~0.5s";
const juno_files_analyzed = "Unknown"; // Would need to parse from JUNO report

// Calculate quality score
const tier1_score = tier1_passed ? 40 : 0;
const tier2_score = tier2_critical_issues === 0 ? 40 : 0;

// Tier 3: 15 points, deduct based on severity
let tier3_score = 15;
for (const warning of accuracy_warnings) {
  if (warning.severity === "HIGH") tier3_score -= 5;
  else if (warning.severity === "MEDIUM") tier3_score -= 3;
  else tier3_score -= 1;
}
tier3_score = Math.max(0, tier3_score);

// Tier 4: Excellence (Rec 23: Automated Readability Scoring)
let tier4_score = 0;
const tier4_checks = {
  code_examples: 0,
  clear_explanations: 0,
  step_by_step: 0,
  api_examples: 0,
  professional_presentation: 0
};

// Check 1: Code Examples (count code blocks in guides)
let total_code_blocks = 0;
for (const file of guide_files) {
  const content = Read(file);
  const code_blocks = (content.match(/\`\`\`/g) || []).length / 2; // Each block has opening and closing
  total_code_blocks += code_blocks;
}
if (total_code_blocks >= guide_files.length * 2) {
  tier4_checks.code_examples = 1; // Average 2+ code blocks per guide
  tier4_score += 1;
}

// Check 2: Clear Explanations (check average paragraph length - 50-200 chars is optimal)
let paragraph_lengths = [];
for (const file of guide_files) {
  const content = Read(file);
  const paragraphs = content.split('\n\n').filter(p => p.trim().length > 0 && !p.startsWith('#') && !p.startsWith('```'));
  for (const para of paragraphs) {
    paragraph_lengths.push(para.length);
  }
}
if (paragraph_lengths.length > 0) {
  const avg_length = paragraph_lengths.reduce((a, b) => a + b, 0) / paragraph_lengths.length;
  if (avg_length >= 50 && avg_length <= 300) {
    tier4_checks.clear_explanations = 1; // Optimal paragraph length
    tier4_score += 1;
  }
}

// Check 3: Step-by-Step Instructions (count numbered/bulleted lists)
let total_steps = 0;
for (const file of guide_files) {
  const content = Read(file);
  const numbered_steps = (content.match(/^\d+\./gm) || []).length;
  const bulleted_steps = (content.match(/^- /gm) || []).length;
  total_steps += numbered_steps + bulleted_steps;
}
if (total_steps >= guide_files.length * 5) {
  tier4_checks.step_by_step = 1; // Average 5+ steps per guide
  tier4_score += 1;
}

// Check 4: Complete API Documentation (examples per endpoint)
if (api_doc_files.length > 0) {
  let api_code_examples = 0;
  for (const file of api_doc_files) {
    const content = Read(file);
    api_code_examples += (content.match(/\`\`\`/g) || []).length / 2;
  }

  // Estimate endpoints from JUNO report
  const juno_report = Read(audit_report_path);
  const endpoint_match = juno_report.match(/API Endpoints?:\s*(\d+)/i);
  const endpoint_count = endpoint_match ? parseInt(endpoint_match[1]) : 10; // Default to 10 if not found

  if (api_code_examples >= endpoint_count * 0.5) {
    tier4_checks.api_examples = 1; // At least 50% of endpoints have examples
    tier4_score += 1;
  }
}

// Check 5: Professional Presentation (consistent heading structure)
let consistent_headings = true;
for (const file of all_docs) {
  const content = Read(file);
  const h1_count = (content.match(/^# /gm) || []).length;
  const h2_count = (content.match(/^## /gm) || []).length;

  // Each document should have exactly 1 H1 and at least 2 H2s
  if (h1_count !== 1 || h2_count < 2) {
    consistent_headings = false;
    break;
  }
}
if (consistent_headings) {
  tier4_checks.professional_presentation = 1;
  tier4_score += 1;
}

// Final tier4 score (max 5)
tier4_score = Math.min(5, tier4_score);

const total_score = tier1_score + tier2_score + tier3_score + tier4_score;

let grade = "";
if (total_score >= 95) grade = "Excellent (Production Ready)";
else if (total_score >= 85) grade = "Good (Minor improvements recommended)";
else if (total_score >= 70) grade = "Acceptable (Requires review and fixes)";
else grade = "Poor (Significant issues, re-generation recommended)";

// Build report
let report = `# Trinity Documentation Verification Report

**Generated:** ${new Date().toISOString()}
**Command Version:** 2.0.9
**JUNO Report:** ${audit_report_path}

---

## Executive Summary

**Overall Quality Score:** ${total_score}/100
**Grade:** ${grade}

**Completion:** ${tier1_passed ? "‚úÖ PASSED" : "‚ùå FAILED"}
**Content Quality:** ${tier2_critical_issues === 0 ? "‚úÖ PASSED" : "‚ùå FAILED"}
**Accuracy:** ${accuracy_warnings.length === 0 ? "‚úÖ PASSED" : `‚ö†Ô∏è ${accuracy_warnings.length} WARNINGS`}

---

## Score Breakdown (Rec 17: Detailed Scoring)

### Tier 1: Completion (${tier1_score}/40)

**Scoring Formula:** All files created = 40 points | Any file missing = 0 points

${tier1_passed ? "‚úÖ All expected files created" : "‚ùå Some files missing"}

**File Checklist:**
- Diagrams: ${diagram_files.length}/${expected_diagrams} ${diagrams_ok ? "‚úÖ" : "‚ùå"}
  ${diagram_files.map(f => `  - ${f}`).join('\n')}
- Guides: ${guide_files.length}/${expected_guides} ${guides_ok ? "‚úÖ" : "‚ùå"}
  ${guide_files.map(f => `  - ${f}`).join('\n')}
- API Docs: ${api_doc_files.length}/${expected_api_docs} ${api_docs_ok ? "‚úÖ" : "‚ùå"}
  ${api_doc_files.map(f => `  - ${f}`).join('\n')}
- Config: ${config_ok ? "1/1" : "0/1"} ${config_ok ? "‚úÖ" : "‚ùå"}
  ${config_ok ? "  - .env.example" : "  - (missing)"}

**Total Files Created:** ${all_docs.length + (config_ok ? 1 : 0)}

**Result:** ${tier1_score === 40 ? "PASSED - All files present" : "FAILED - Missing files detected"}

### Tier 2: Content Quality (${tier2_score}/40)

**Scoring Formula:** No critical issues = 40 points | Any critical issue = 0 points (fail-fast)

${tier2_critical_issues === 0 ? "‚úÖ All quality checks passed" : `‚ùå ${tier2_critical_issues} critical issues`}

**Detailed Results:**
1. **Template Placeholders** (CRITICAL): ${verification_issues.template_placeholders.length} ${verification_issues.template_placeholders.length === 0 ? "‚úÖ PASS" : "‚ùå FAIL"}
   - Requirement: Zero placeholders ({{VARIABLE}}) in output
   - Found: ${verification_issues.template_placeholders.length} instances
   ${verification_issues.template_placeholders.length > 0 ? verification_issues.template_placeholders.map(i => `   - ${i.file}: ${i.placeholder}`).join('\n') : ""}

2. **Internal Link Validation** (CRITICAL): ${verification_issues.broken_links.length} ${verification_issues.broken_links.length === 0 ? "‚úÖ PASS" : "‚ùå FAIL"}
   - Requirement: All links must reference existing files
   - Found: ${verification_issues.broken_links.length} broken links
   ${verification_issues.broken_links.length > 0 ? verification_issues.broken_links.map(i => `   - ${i.file}: [${i.link_text}](${i.target})`).join('\n') : ""}

3. **Mermaid Syntax Validation** (CRITICAL): ${verification_issues.mermaid_errors.length} ${verification_issues.mermaid_errors.length === 0 ? "‚úÖ PASS" : "‚ùå FAIL"}
   - Requirement: Valid Mermaid syntax with proper diagram types
   - Found: ${verification_issues.mermaid_errors.length} syntax errors
   ${verification_issues.mermaid_errors.length > 0 ? verification_issues.mermaid_errors.map(i => `   - ${i.file}: ${i.error}`).join('\n') : ""}

4. **Stub Content Detection** (CRITICAL): ${verification_issues.stub_content ? verification_issues.stub_content.length : 0} ${(verification_issues.stub_content ? verification_issues.stub_content.length : 0) === 0 ? "‚úÖ PASS" : "‚ùå FAIL"}
   - Requirement: No "coming soon", "TODO", or stub content
   - Found: ${verification_issues.stub_content ? verification_issues.stub_content.length : 0} instances
   ${verification_issues.stub_content && verification_issues.stub_content.length > 0 ? verification_issues.stub_content.map(i => `   - ${i.file}: "${i.pattern}"`).join('\n') : ""}

5. **Content Length** (WARNING): ${verification_issues.short_content.length} ${verification_issues.short_content.length === 0 ? "‚úÖ PASS" : "‚ö†Ô∏è WARN"}
   - Requirement: Substantial content (diagrams ‚â•100 chars, docs ‚â•200 chars)
   - Found: ${verification_issues.short_content.length} short files (non-blocking)

**Result:** ${tier2_score === 40 ? "PASSED - No critical issues" : "FAILED - Critical quality issues detected"}

### Tier 3: Accuracy (${tier3_score}/15)

**Scoring Formula:** 15 points base | -5 per HIGH severity | -3 per MEDIUM | -1 per LOW (min 0)

${accuracy_warnings.length === 0 ? "‚úÖ No inaccuracies detected" : `‚ö†Ô∏è ${accuracy_warnings.length} warnings (non-blocking)`}

**Scoring Breakdown:**
- Base Score: 15 points
${accuracy_warnings.length > 0 ? accuracy_warnings.map(w => `- Deduction: -${w.severity === 'HIGH' ? 5 : w.severity === 'MEDIUM' ? 3 : 1} (${w.severity}) ${w.category}: ${w.issue}`).join('\n') : "- No deductions"}
- **Final Score: ${tier3_score}/15**

**Warnings:**
${accuracy_warnings.length > 0 ? accuracy_warnings.map(w => `- [${w.severity}] ${w.category}: ${w.issue}`).join('\n') : "None"}

**Result:** ${tier3_score >= 12 ? "GOOD" : tier3_score >= 8 ? "ACCEPTABLE" : "NEEDS REVIEW"}

### Tier 4: Excellence (${tier4_score}/5) - Rec 23: Automated Readability Scoring

**Scoring Criteria (Automated):**
1. **Comprehensive Code Examples** (1 point): ${tier4_checks.code_examples ? "‚úÖ PASS" : "‚ùå FAIL"}
   - Requirement: Average 2+ code blocks per guide
   - Found: ${(total_code_blocks / Math.max(1, guide_files.length)).toFixed(1)} blocks per guide
   - Result: ${tier4_checks.code_examples ? "+1 point" : "+0 points"}

2. **Clear Explanations** (1 point): ${tier4_checks.clear_explanations ? "‚úÖ PASS" : "‚ùå FAIL"}
   - Requirement: Optimal paragraph length (50-300 chars)
   - Average: ${paragraph_lengths.length > 0 ? (paragraph_lengths.reduce((a, b) => a + b, 0) / paragraph_lengths.length).toFixed(0) + " chars" : "N/A"}
   - Result: ${tier4_checks.clear_explanations ? "+1 point" : "+0 points"}

3. **Step-by-Step Instructions** (1 point): ${tier4_checks.step_by_step ? "‚úÖ PASS" : "‚ùå FAIL"}
   - Requirement: Average 5+ steps/lists per guide
   - Found: ${(total_steps / Math.max(1, guide_files.length)).toFixed(1)} steps per guide
   - Result: ${tier4_checks.step_by_step ? "+1 point" : "+0 points"}

4. **Complete API Documentation** (1 point): ${tier4_checks.api_examples ? "‚úÖ PASS" : "‚ùå FAIL"}
   - Requirement: ‚â•50% of endpoints have code examples
   - Found: ${api_doc_files.length > 0 ? (api_code_examples + " examples for ~" + endpoint_count + " endpoints") : "No API docs"}
   - Result: ${tier4_checks.api_examples ? "+1 point" : "+0 points"}

5. **Professional Presentation** (1 point): ${tier4_checks.professional_presentation ? "‚úÖ PASS" : "‚ùå FAIL"}
   - Requirement: Consistent heading structure (1 H1, 2+ H2s per doc)
   - Result: ${tier4_checks.professional_presentation ? "‚úÖ Consistent" : "‚ùå Inconsistent"}
   - Result: ${tier4_checks.professional_presentation ? "+1 point" : "+0 points"}

**Final Score:** ${tier4_score}/5 points

**Result:** ${tier4_score === 5 ? "EXCELLENT" : tier4_score >= 3 ? "GOOD" : "NEEDS IMPROVEMENT"}

---

## Files Created

### Architecture Diagrams (${diagram_files.length})

${diagram_files.map(f => `- ${f}`).join('\n')}

### Developer Guides (${guide_files.length})

${guide_files.map(f => `- ${f}`).join('\n')}

### API Documentation (${api_doc_files.length})

${api_doc_files.map(f => `- ${f}`).join('\n')}

### Configuration Files (${config_ok ? 1 : 0})

${config_ok ? "- .env.example" : "- (none created)"}
- README.md (updated)

---

## Performance Metrics (Rec 15)

### Execution Times

- **JUNO Audit**: ${((global.trinity_docs_session.performance_metrics.juno_end - global.trinity_docs_session.performance_metrics.juno_start) / 1000).toFixed(2)}s
- **APO Parallel Execution**: ${((global.trinity_docs_session.performance_metrics.apo_end - global.trinity_docs_session.performance_metrics.apo_start) / 1000).toFixed(2)}s
  - APO-1 (Diagrams): ${apo1_time}s (estimated)
  - APO-2 (Guides): ${apo2_time}s (estimated)
  - APO-3 (Config): ${apo3_time}s (estimated)
- **Verification**: ${((Date.now() - global.trinity_docs_session.performance_metrics.verification_start) / 1000).toFixed(2)}s
  - Tier 1 (Completion): ${tier1_time}s
  - Tier 2 (Content Quality): ${tier2_time}s
  - Tier 3 (Accuracy): ${tier3_time}s
  - Tier 4 (Excellence): ${tier4_time}s
- **Total Execution**: ${((Date.now() - global.trinity_docs_session.performance_metrics.total_start) / 1000).toFixed(2)}s

### Efficiency Metrics

- **Parallel Efficiency**: ${(((global.trinity_docs_session.performance_metrics.apo_end - global.trinity_docs_session.performance_metrics.apo_start) / (apo1_time + apo2_time + apo3_time)) * 100).toFixed(1)}% (3x theoretical speedup: ${((apo1_time + apo2_time + apo3_time) / (global.trinity_docs_session.performance_metrics.apo_end - global.trinity_docs_session.performance_metrics.apo_start)).toFixed(2)}x)
- **Throughput**: ${(all_docs.length / ((Date.now() - global.trinity_docs_session.performance_metrics.total_start) / 1000)).toFixed(2)} files/second
- **JUNO Analysis Rate**: ${juno_files_analyzed && juno_files_analyzed !== "Unknown" ? (juno_files_analyzed / ((global.trinity_docs_session.performance_metrics.juno_end - global.trinity_docs_session.performance_metrics.juno_start) / 1000)).toFixed(2) + " files/second" : "N/A"}

### Resource Usage

- **Total Files Generated**: ${all_docs.length}
- **Total Documentation Size**: ${(all_docs.reduce((acc, f) => acc + Read(f).length, 0) / 1024).toFixed(2)} KB
- **Average File Size**: ${(all_docs.reduce((acc, f) => acc + Read(f).length, 0) / all_docs.length / 1024).toFixed(2)} KB
- **JUNO Report Size**: ${(Read(audit_report_path).length / 1024).toFixed(2)} KB

---

## Recommendations

${total_score >= 95 ? "‚úÖ Documentation is production-ready. No action required." : ""}
${total_score >= 85 && total_score < 95 ? "‚ö†Ô∏è Documentation is good but has minor issues. Review warnings above." : ""}
${total_score >= 70 && total_score < 85 ? "‚ö†Ô∏è Documentation requires review and fixes before deployment." : ""}
${total_score < 70 ? "‚ùå Documentation quality is insufficient. Re-generation recommended." : ""}

${accuracy_warnings.length > 0 ? "\n### Action Items:\n\n" + accuracy_warnings.map((w, i) => `${i + 1}. ${w.category}: ${w.issue}`).join('\n') : ""}

---

**Report Generated by:** Trinity Documentation Generator v2.0.9
**Architecture:** Multi-agent orchestration (JUNO + 3 parallel APOs)
`;

Write(report_path, report);

LOG: `‚úÖ Verification report saved: ${report_path}`;
LOG: "";

global.trinity_docs_session.verification = {
  score: total_score,
  grade: grade,
  report_path: report_path
};
```

---

## Phase 4: Completion Report

```javascript
// Track final performance
global.trinity_docs_session.performance_metrics.verification_end = Date.now();
global.trinity_docs_session.performance_metrics.total_end = Date.now();

const perf = global.trinity_docs_session.performance_metrics;

LOG: "=== TRINITY DOCUMENTATION GENERATION COMPLETE ===";
LOG: "";
LOG: "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó";
LOG: "‚ïë                   üéâ SUCCESS                               ‚ïë";
LOG: "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù";
LOG: "";
LOG: "Quality Score: " + global.trinity_docs_session.verification.score + "/100";
LOG: "Grade: " + global.trinity_docs_session.verification.grade;
LOG: "";
LOG: "Documentation Summary:";
LOG: `  Architecture Diagrams: ${diagram_files.length} files`;
LOG: `  Developer Guides: ${guide_files.length} files`;
LOG: `  API Documentation: ${api_doc_files.length} files`;
LOG: `  Configuration Files: ${config_ok ? 1 : 0} files`;
LOG: `  Total: ${diagram_files.length + guide_files.length + api_doc_files.length + (config_ok ? 1 : 0)} files`;
LOG: "";
LOG: "üìÅ Documentation Structure:";
LOG: "  docs/";
LOG: "  ‚îú‚îÄ‚îÄ images/        (Architecture diagrams)";
LOG: "  ‚îú‚îÄ‚îÄ guides/        (Developer guides)";
LOG: "  ‚îú‚îÄ‚îÄ api/           (API reference)";
LOG: "  ‚îî‚îÄ‚îÄ README.md      (Documentation home)";
LOG: "";
LOG: "‚è±Ô∏è Performance Metrics:";
LOG: `  JUNO Audit: ${((perf.juno_end - perf.juno_start) / 1000).toFixed(2)}s`;
LOG: `  APO Parallel Execution: ${((perf.apo_end - perf.apo_start) / 1000).toFixed(2)}s`;
LOG: `  Verification: ${((perf.verification_end - perf.verification_start) / 1000).toFixed(2)}s`;
LOG: `  Total Time: ${((perf.total_end - perf.total_start) / 1000).toFixed(2)}s`;
LOG: "";
LOG: "üöÄ Next Steps:";
LOG: "  1. Review generated documentation in docs/ directory";
LOG: "  2. Verify Mermaid diagrams render correctly";
LOG: "  3. Check API documentation accuracy";
LOG: "  4. Update .env.example with project-specific values if needed";
LOG: "";
LOG: "üìä Reports:";
LOG: `  Audit Report: ${audit_report_path}`;
LOG: `  Verification Report: ${global.trinity_docs_session.verification.report_path}`;
LOG: "";
LOG: "‚ú® Documentation generated using Trinity Method v2.0.9 (Orchestration Architecture)";
LOG: "";
```

---

## Architecture Notes

### Why This Approach Works

**Context Isolation:**
- JUNO reads codebase (focused analysis task)
- Each APO reads <100 lines (their specific section from report)
- No single agent reads massive context

**Parallel Execution:**
- APO-1, APO-2, APO-3 run simultaneously
- 3x faster than sequential execution
- Independent sections prevent blocking

**Quality Gates:**
- JUNO self-validation ensures report completeness (Rec 3)
- JUNO report validation catches incomplete audits (Rec 1)
- APO self-validation ensures file creation and quality (Rec 6)
- Enhanced verification enforces content quality (Rec 7)
- 4-tier success criteria with objective scoring (Rec 9)

**Resilience:**
- APO fallback mechanisms handle incomplete JUNO reports (Rec 4)
- Error handling protocol prevents silent failures (Rec 5)
- README link validation prevents broken references (Rec 8)

**Intelligence:**
- Testing framework detection prevents inaccuracies (Rec 11)
- Component discovery ensures accurate diagrams (Rec 12)
- Enhanced JUNO prompt clarity improves report quality (Rec 2)

**Observability:**
- Performance tracking across all phases (Rec 10)
- Verification report with quality score
- Clear ABORT vs WARN vs LOG distinction

### Comparison to Previous Architecture

| Metric | v2.0.x (Sequential) | v3.0.0 (Orchestrated) | v3.1 (Enhanced) |
|--------|---------------------|------------------------|-----------------|
| Command Size | 4,656 lines | 888 lines | ~1,800 lines |
| Largest Context | 4,656 lines (APO) | ~300 lines (JUNO) | ~400 lines (APO-1) |
| Execution | Sequential | Parallel (3x) | Parallel (3x) |
| Quality Gates | After generation | JUNO validation | JUNO + APO + Verification |
| Failure Mode | Silent skips | File count check | Content quality ABORT |
| Success Rate | 0% (v2.0.8 test) | 94% (v3.0.0 test) | 98-100% (expected) |
| Fallback | None | Undocumented | Documented (Phase 1.5) |
| Self-Validation | None | None | JUNO + 3 APOs |
| Link Validation | None | None | APO-3 + Verification |
| Accuracy Checks | None | None | Verification Tier 3 |

### Quality Improvements (v3.1)

**Issues Resolved:**
1. ‚úÖ JUNO incomplete reports (Rec 1: validation with ABORT/WARN)
2. ‚úÖ Broken README links (Rec 8: comprehensive link validation)
3. ‚úÖ Template placeholders (Rec 7: verification with ABORT)
4. ‚úÖ Invalid Mermaid syntax (Rec 7: validation with ABORT)
5. ‚úÖ Testing framework inaccuracies (Rec 11: detection in JUNO)
6. ‚úÖ Non-existent components (Rec 12: discovery in JUNO)

**New Capabilities:**
1. ‚úÖ Objective quality scoring (0-100) (Rec 9)
2. ‚úÖ Performance tracking across phases (Rec 10)
3. ‚úÖ APO fallback architecture (Rec 4)
4. ‚úÖ Error handling protocol (Rec 5)
5. ‚úÖ Self-validation at all levels (Rec 3, 6)
6. ‚úÖ Enhanced verification with 4 tiers (Rec 7)

---

## Error Handling

### If Verification Fails

**Tier 1 Failure (Completion):**
- ABORT command immediately
- Review JUNO's audit report (lists what should exist)
- Review APO execution logs (shows what was attempted)
- Check for APO errors or exceptions
- Re-run command if transient failure

**Tier 2 Failure (Content Quality):**
- ABORT command immediately
- Review specific issues:
  - Template placeholders: APO didn't replace variables
  - Broken links: APO-3 created links to non-existent files
  - Mermaid errors: APO-1 generated invalid syntax
- Fix underlying APO issue or JUNO report incompleteness
- Re-run command

**Tier 3 Warnings (Accuracy):**
- Command completes successfully
- Review warnings in verification report
- Manually fix inaccuracies if needed
- No re-run required

### If JUNO Fails

**Incomplete Report:**
- JUNO validation catches this (Rec 1)
- Warnings logged, APO fallback activates
- Documentation still generated (may be lower quality)

**No Report Created:**
- Command ABORTs in Phase 1
- Check codebase structure (package.json exists?)
- Verify framework detection logic
- Check JUNO agent availability

---

**Command Version:** 2.0.9
**Last Updated:** 2026-01-14
**Architecture:** Multi-agent orchestration with enhanced quality gates
**Improvements:** 13 architectural recommendations implemented (WO-1.5)
