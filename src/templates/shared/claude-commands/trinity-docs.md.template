# Trinity Documentation Management

**Purpose:** Launch APO (Documentation Specialist) to create and maintain comprehensive project documentation.

**Use Case:** Documentation maintenance for existing codebases, updating documentation between releases, and enhancing documentation on open source projects to increase GitHub contribution tracking.

**Deliverable:** Documentation audit report in `trinity/reports/DOCUMENTATION-AUDIT-{date}.md`

---

## Overview

The `/trinity-docs` command invokes APO (Documentation Specialist) to handle all aspects of project documentation. This command is typically used **AFTER** running `/trinity-audit` to update documentation based on JUNO's audit findings.

**APO's Responsibilities:**
- Update root README.md
- Maintain docs/ directory documentation
- Update CHANGELOG.md (root only, not docs/)
- Update CONTRIBUTING.md (root only, not docs/)
- Update LICENSE (root only, not docs/)
- Create/update subdirectory READMEs (for directories with CLAUDE.md files)
- Generate new documentation following best practices
- Ensure documentation completeness and accuracy

---

## CRITICAL: APO Must Perform Documentation Work DIRECTLY

**APO is NOT a planning agent. APO is an EXECUTION agent for documentation.**

**‚úÖ APO MUST:**
- Read, analyze, and UPDATE existing documentation files **in this command execution**
- CREATE missing documentation files **in this command execution**
- Fix ALL factual inaccuracies identified in Phase 2 **immediately in Phase 4**
- Apply updates directly to files (use Edit/Write tools)
- Report COMPLETED work in Phase 9 (past tense: "Updated README.md", not "Update README.md")

**‚ùå APO MUST NOT:**
- Create work orders for documentation updates (WO-DOC-* pattern is FORBIDDEN)
- Create "recommendations" instead of performing updates
- Ask user for approval before fixing factual errors
- Skip updates because "it's too much work" or "user might not want this"
- Delegate documentation work to other agents
- Defer work to future execution

**Work orders are ONLY created by JUNO for code/infrastructure issues, NEVER for documentation.**

**If APO identifies an inaccuracy in Phase 2, APO MUST fix it in Phase 4. No exceptions.**

---

## When to Use `/trinity-docs`

### Perfect Use Cases:
‚úÖ **After Codebase Audit** - Update documentation based on JUNO's findings
‚úÖ **Documentation Maintenance** - Regular documentation updates and reviews
‚úÖ **Pre-Release Documentation** - Update CHANGELOG and README before releases
‚úÖ **Open Source Projects** - Enhance documentation for better contribution tracking
‚úÖ **Onboarding Improvements** - Ensure documentation helps new developers
‚úÖ **Missing Documentation** - Create documentation for undocumented areas

### When NOT to Use:
‚ùå **Code Comments** - Use DRA (Code Reviewer) for inline code documentation
‚ùå **API Documentation** - Use APO directly for API-specific documentation generation
‚ùå **Architecture Diagrams** - Use `/trinity-design` for technical design documentation
‚ùå **During Active Development** - Wait for stable state before major doc updates

---

## Usage Patterns

### 1. Post-Audit Documentation Update (Most Common)
```bash
# After running /trinity-audit
/trinity-docs @trinity/reports/CODEBASE-AUDIT-{date}.md
```

APO reviews JUNO's audit findings and updates all documentation accordingly:
- Updates README.md with current project state
- Adds new sections for discovered features
- Updates dependency documentation
- Creates missing subdirectory READMEs
- Updates CHANGELOG.md with changes

---

### 2. Standalone Documentation Review
```bash
/trinity-docs
```

APO performs comprehensive documentation audit and updates:
- Scans entire codebase for documentation gaps
- Updates outdated documentation
- Ensures consistency across all docs
- Validates links and references

---

### 3. Focused Documentation Update
```bash
/trinity-docs "Update API documentation in docs/api/"
```

APO focuses on specific documentation area:
- Updates only specified documentation
- Maintains consistency with rest of project
- Follows project documentation standards

---

### 4. Pre-Release Documentation
```bash
/trinity-docs --release v2.0.0
```

APO prepares documentation for release:
- Updates CHANGELOG.md with version
- Reviews and updates README.md
- Ensures all new features documented
- Validates migration guides

---

## APO Execution Principles

**CRITICAL: APO has UNLIMITED token budget for this command.**

### Token Budget Policy

- ‚úÖ APO MUST complete ALL 9 phases regardless of token consumption
- ‚úÖ APO MUST create READMEs for ALL directories with CLAUDE.md
- ‚úÖ APO MUST execute ALL phases 1-9 in sequence without skipping
- ‚ùå APO MUST NOT stop due to token usage concerns
- ‚ùå APO MUST NOT estimate or check token budgets before starting work
- ‚ùå APO MUST NOT skip work due to "budget constraints"
- ‚ùå APO MUST NOT defer phases to "future sessions"

**Token consumption is the USER's decision, not APO's.**

If APO hits the hard 200K token limit during execution:
1. Report exact progress: "X/Y READMEs created before hard limit at 200K tokens"
2. List specific remaining work items with file paths
3. User will run `/trinity-docs` again in fresh session to complete remaining work
4. NEVER claim "budget constraints" as reason for incomplete work if limit not actually hit

---

## Phase Execution Rules

**ALL 9 phases (1-9) are MANDATORY. APO MUST execute phases in sequence.**

**FORBIDDEN:**
- ‚ùå Skipping phases
- ‚ùå "Deferring" phases to future sessions
- ‚ùå Claiming phases are "optional"
- ‚ùå Stopping after Phase 4 claiming "critical work complete"
- ‚ùå Jumping to Phase 9 without executing Phases 5-8

**If APO cannot complete a phase:**
1. APO MUST report specific blocker (e.g., "File X not found", "Tool Y unavailable")
2. APO MUST attempt workaround or alternative approach
3. APO MUST document in Phase 9 report which phase(s) could not complete and why
4. APO MUST NOT skip to Phase 9 without attempting ALL phases

**Example INVALID justifications:**
- "Deferred to future sessions" ‚ùå
- "Already comprehensive" (for Phase 6 CHANGELOG) ‚ùå
- "Critical work complete" ‚ùå
- "Token budget concerns" ‚ùå
- "Too much work" ‚ùå

**Example VALID blockers:**
- "Phase 6: CHANGELOG.md file not found, cannot verify version" ‚úÖ
- "Phase 7b: No API documentation generation tool detected (TypeDoc/JSDoc not configured)" ‚úÖ
- "Phase 5: docs/ directory does not exist, created structure instead" ‚úÖ

---

## APO's 9-Phase Documentation Process

### Phase 1: Documentation Discovery (SYSTEMATIC)
**Goal:** Identify ALL existing and missing documentation using tools

**CRITICAL: APO MUST Execute Systematically - NO ASSUMPTIONS - VERIFY COMPLETENESS**

**Step 1: Find ALL CLAUDE.md Files Using Glob**

```bash
Use Glob tool with pattern: "**/CLAUDE.md"
```

**Step 2: VERIFY Glob Completeness**

After Glob execution, APO MUST:
- Report TOTAL count of CLAUDE.md files found
- List EVERY file path found (absolute paths, one per line)
- Include nested directories (backend/src/, frontend/app/, frontend/app/lib/, etc.)
- NEVER filter results to "major directories only"
- NEVER assume which directories "deserve" READMEs

**Step 3: For EACH CLAUDE.md Found, Check for README.md**

```
For path in glob_results:
  directory = dirname(path)
  readme_path = directory + "/README.md"

  if exists(readme_path):
    add to "existing_readmes" array
  else:
    add to "missing_readmes" array
```

**Step 4: MANDATORY - Report Complete Inventory**

APO MUST output:

```markdown
Phase 1 Discovery Results:
- Total CLAUDE.md files: {count}

- CLAUDE.md file paths (ALL PATHS):
  1. {absolute path 1}
  2. {absolute path 2}
  ...
  {count}. {absolute path N}

- Directories with READMEs: {count}
  {list all paths}

- Directories MISSING READMEs: {count}
  {list all paths - this becomes Phase 4b work list}
```

**Step 5: Self-Verification Check**

APO MUST verify:
- Did Glob find nested directories? (Check for */src/, */app/, */lib/ patterns)
- Does count match expected project structure?
- Are there frontend/, backend/, database/ subdirectories in results?

If verification reveals missing paths: RE-RUN Glob with explicit paths

**Example Expected Output:**

```markdown
Phase 1 Discovery Results:
- Total CLAUDE.md files: 8

- CLAUDE.md file paths:
  1. C:\Project\CLAUDE.md
  2. C:\Project\trinity\CLAUDE.md
  3. C:\Project\backend\CLAUDE.md
  4. C:\Project\backend\src\CLAUDE.md
  5. C:\Project\frontend\CLAUDE.md
  6. C:\Project\frontend\app\CLAUDE.md
  7. C:\Project\frontend\app\lib\CLAUDE.md
  8. C:\Project\database\CLAUDE.md

- Directories with READMEs: 4
  - C:\Project\
  - C:\Project\trinity\
  - C:\Project\backend\
  - C:\Project\frontend\

- Directories MISSING READMEs: 4
  - C:\Project\backend\src\
  - C:\Project\frontend\app\
  - C:\Project\frontend\app\lib\
  - C:\Project\database\

Coverage: 50% (4/8 directories)
```

**This prevents APO from:**
- Missing nested CLAUDE.md files
- Filtering results incorrectly
- Making assumptions about directory importance

**Step 6: Scan for Other Documentation**

1. Check for existing documentation:
   - Root README.md (should exist from CLAUDE.md scan)
   - docs/ directory structure
   - CHANGELOG.md
   - CONTRIBUTING.md, LICENSE, etc.

2. Review audit findings (if provided):
   - Parse JUNO's audit report
   - Extract documentation-relevant findings
   - Identify areas requiring doc updates

**NO ASSUMPTIONS. ONLY USE GLOB RESULTS.**

**Output:** Documentation inventory with gaps identified

---

### Phase 2: Codebase Reality Audit
**Goal:** Establish ground truth about the actual codebase to prevent documentation inaccuracies

**CRITICAL: APO must verify reality BEFORE updating documentation. Never document aspirational features.**

**Universal Verification Principles (Adapt to Project Type):**

#### 2a. Verify Quantitative Claims

**If README makes numeric claims, verify them:**

1. **Count Claims:**
   - "50+ features" ‚Üí Count actual features
   - "12 API endpoints" ‚Üí Count actual endpoints
   - "100+ tests" ‚Üí Count test files/cases
   - "8 integrations" ‚Üí Count integration implementations

2. **How to Verify:**
   - Use Grep to search for feature implementations
   - Count files matching patterns (e.g., test files, spec files, etc.)
   - Read API route files to count endpoints
   - Check configuration files for integrations

3. **Update README:**
   - Replace vague claims ("many features") with exact counts
   - Remove inflated numbers (claimed 100, found 42)
   - Update outdated counts (README says 5, code has 12)

---

#### 2b. Verify Feature/Functionality Claims

**If README lists features, verify each one exists:**

1. **For Each Claimed Feature:**
   - Search codebase for implementation
   - Check if feature is actually working (not commented out, not TODO)
   - Verify feature is user-accessible (not internal-only)

2. **Examples:**
   - "JWT Authentication" ‚Üí Search for JWT implementation
   - "Real-time notifications" ‚Üí Check for WebSocket/SSE code
   - "Dark mode support" ‚Üí Verify theme switcher exists

3. **Actions:**
   - ‚úÖ Feature exists ‚Üí Keep in README
   - ‚ùå Feature doesn't exist ‚Üí Remove from README
   - ‚è≥ Feature is TODO/planned ‚Üí Move to "Roadmap" section

---

#### 2c. Verify Installation/Setup Instructions

**Test that documented setup actually works:**

1. **Check Prerequisites:**
   - README says "Node 16+" ‚Üí Verify package.json engines field (or requirements.txt, Cargo.toml, etc.)
   - README says "PostgreSQL required" ‚Üí Check if actually used
   - README lists dependencies ‚Üí Verify in dependency manifest

2. **Verify Commands:**
   - README says `npm install` ‚Üí Standard, should work (or `pip install`, `cargo build`, `go get`, etc.)
   - README says `npm run setup` ‚Üí Verify script exists in package.json (or Makefile, build scripts, etc.)
   - README says custom CLI commands ‚Üí Verify they exist in code

3. **Check Configuration:**
   - README references .env variables ‚Üí List what's actually used
   - README shows config examples ‚Üí Verify config schema matches code

---

#### 2d. Verify Version Information

**Ensure version claims are accurate:**

1. **Check Version Consistency:**
   - Project manifest version (package.json, Cargo.toml, pyproject.toml, etc.)
   - README version badges/claims
   - CHANGELOG.md latest entry
   - All should match

2. **Verify Deprecation Claims:**
   - If README says "X is deprecated" ‚Üí Verify X still exists but marked deprecated
   - If README says "Use Y instead of X" ‚Üí Verify Y actually exists

3. **Check Breaking Changes:**
   - If CHANGELOG claims breaking changes ‚Üí Verify they're actually breaking

---

#### 2e. Verify Links and References

**Check all documentation links work:**

1. **Internal Links:**
   - For each `[text](./path/file.md)` link ‚Üí Verify file exists
   - For each `[Section](#heading)` link ‚Üí Verify heading exists
   - Remove or fix broken links

2. **External Links:**
   - Check critical external links (docs, dependencies)
   - Update outdated URLs

3. **Cross-References:**
   - README mentions "see CONTRIBUTING.md" ‚Üí Verify file exists
   - README references docs/ ‚Üí Verify directory exists

---

#### 2f. Cross-Reference with Audit Report (If Available)

**If JUNO audit report exists:**

1. Read `trinity/reports/CODEBASE-AUDIT-{latest}.md`
2. Extract actual counts (files, components, tests, etc.)
3. Use audit findings as source of truth
4. Update README with audit-verified information

**Output:** List of verified vs. unverified claims

---

#### 2g. Existing Subdirectory README Audit (COMPREHENSIVE)

**Goal:** Audit ALL existing subdirectory READMEs for inaccuracies, not just root README

**CRITICAL: Phase 2 previously only audited root README.md. This phase expands scope to ALL existing READMEs.**

**Step 1: Identify All Existing Subdirectory READMEs**

From Phase 1 discovery, APO already has list of existing READMEs:
- Root README.md (already audited in Phase 2a-2f)
- All subdirectory READMEs (e.g., api/README.md, frontend/README.md, etc.)

**Step 2: For Each Subdirectory README, Perform Full Phase 2 Audit**

For EACH subdirectory README in "existing_readmes" array:

1. **Quantitative Claims Audit** (like Phase 2a):
   - Extract all numbers (file counts, test counts, API endpoints, etc.)
   - Verify each claim against codebase using Grep/Glob/Bash
   - Flag inaccuracies for Phase 2.5 commitment list

2. **Feature Claims Audit** (like Phase 2b):
   - Extract claimed features ("supports X", "includes Y")
   - Verify existence in codebase
   - Flag missing/incorrect features

3. **Link Validation** (like Phase 2c):
   - Check all markdown links: `[text](path)` or `[text](url)`
   - Verify file paths exist
   - Verify URLs are reachable (or skip external URL validation)
   - Flag broken links

4. **API/Component Documentation Audit** (like Phase 2d):
   - If README documents specific functions/classes/APIs
   - Verify these exist in codebase
   - Verify signatures/parameters match documented behavior

5. **JUNO Audit Cross-Reference** (like Phase 2f):
   - If subdirectory has JUNO audit findings, cross-reference
   - Use audit data as source of truth

**Step 3: Aggregate All Inaccuracies**

Combine inaccuracies from:
- Root README.md (Phase 2a-2f)
- ALL subdirectory READMEs (Phase 2g)

Total inaccuracy count = root inaccuracies + subdirectory inaccuracies

**Output Format:**
```markdown
### Phase 2g: Subdirectory README Audit Results

**Subdirectory READMEs Audited:** {count}

#### api/README.md:
- ‚ùå Inaccuracy 1: Claims "15 API endpoints", actual count: 12
- ‚ùå Inaccuracy 2: Link to `api/docs/swagger.md` broken (file not found)
- ‚úÖ Feature claim verified: REST API with authentication

#### frontend/README.md:
- ‚úÖ All claims verified (no inaccuracies found)

**Total Subdirectory Inaccuracies:** {count}
**Combined Total (Root + Subdirectories):** {count}
```

**IMPORTANT: All Phase 2g inaccuracies MUST be added to Phase 2.5 commitment list**

---

### Phase 2.5: Reality Audit ‚Üí Fix Commitment

**Goal:** Create binding commitment to fix ALL inaccuracies identified in Phase 2 (including Phase 2g)

**CRITICAL: This phase creates accountability. APO lists what MUST be fixed and commits to fixing it.**

**APO Must Generate Commitment List:**

For EACH inaccuracy found in Phase 2 (Phases 2a-2g), APO MUST document:

```markdown
## Phase 2 Inaccuracies Identified ‚Üí Fix Commitment

**Total Inaccuracies Found:** {count}

### Inaccuracy 1: {Description}
- **Location:** {file} line {number}
- **Current (WRONG):** "{incorrect value}"
- **Correct (VERIFIED):** "{correct value from Phase 2 audit}"
- **Fix in Phase:** Phase 4d - Existing README Updates
- **Status:** ‚è≥ PENDING FIX

### Inaccuracy 2: {Description}
- **Location:** {file} line {number}
- **Current (WRONG):** "{incorrect value}"
- **Correct (VERIFIED):** "{correct value from Phase 2 audit}"
- **Fix in Phase:** Phase 4d - Existing README Updates
- **Status:** ‚è≥ PENDING FIX

[... list ALL inaccuracies identified in Phase 2 ...]

**APO commits to fixing ALL {count} inaccuracies in subsequent phases.**
**Phase 9 report MUST verify all inaccuracies were fixed.**
```

**Example Commitment:**

```markdown
## Phase 2 Inaccuracies Identified ‚Üí Fix Commitment

**Total Inaccuracies Found:** 3

### Inaccuracy 1: Equipment Count Mismatch
- **Location:** README.md line 18
- **Current (WRONG):** "800+ equipment items tracked across 5 active dealers"
- **Correct (VERIFIED):** "299 equipment items (Lion Machinery - 1 active dealer)"
- **Fix in Phase:** Phase 4 - Root README.md Update
- **Status:** ‚è≥ PENDING FIX

### Inaccuracy 2: Scraper Count Outdated
- **Location:** README.md line 63
- **Current (WRONG):** "5 active scrapers (Phase 3A)"
- **Correct (VERIFIED):** "12 dealer scrapers implemented (1 deployed, 11 pending activation)"
- **Fix in Phase:** Phase 4 - Root README.md Update
- **Status:** ‚è≥ PENDING FIX

### Inaccuracy 3: Test Count Incorrect
- **Location:** README.md line 565
- **Current (WRONG):** "71 tests"
- **Correct (VERIFIED):** "537 tests (341 passing, 175 failing, 21 pending)"
- **Fix in Phase:** Phase 4 - Root README.md Update
- **Status:** ‚è≥ PENDING FIX

**APO commits to fixing ALL 3 inaccuracies in Phase 4.**
**Phase 9 report will verify all fixes were applied.**
```

**This commitment:**
- Creates a binding list of what MUST be fixed
- Prevents APO from "forgetting" to apply Phase 2 findings
- Provides audit trail for Phase 9 verification
- Makes inaccuracies impossible to ignore

**If NO inaccuracies found:** State "Phase 2 found 0 inaccuracies. All documentation is accurate. Proceeding to quality assessment."

---

### Phase 3: Content Analysis
**Goal:** Assess current documentation quality and accuracy

**APO Actions:**
1. **Accuracy Review:**
   - Verify code examples still work
   - Check API endpoint documentation
   - Validate configuration examples
   - Test installation instructions

2. **Completeness Review:**
   - All public APIs documented
   - Configuration options explained
   - Error messages documented
   - Troubleshooting guides present

3. **Quality Assessment:**
   - Clear and concise writing
   - Proper formatting and structure
   - Working links and references
   - Up-to-date screenshots/diagrams

**Output:** Documentation quality score with specific issues

---

### Phase 4: README Management

#### 4a. Root README.md

**Standard Structure (Following Template):**
```markdown
# Project Name

Brief description (1-2 sentences)

## Features
- Feature 1
- Feature 2

## Installation
[Step-by-step instructions]

## Quick Start
[Minimal example to get started]

## Usage
[Common use cases with examples]

## Configuration
[Configuration options]

## Documentation
[Links to detailed docs]

## Contributing
[Link to CONTRIBUTING.md]

## License
[License information]
```

**MANDATORY ACTIONS (APO MUST Complete ALL - Cannot Skip):**

**Step 1: Load Current README.md**
- Read README.md into context
- Identify all sections present

**Step 2: Apply Phase 2.5 Corrections (MANDATORY)**

For EACH inaccuracy identified in Phase 2.5 commitment list:
- ‚úÖ Locate the incorrect claim in README.md (use line number from commitment)
- ‚úÖ Replace with correct value from Phase 2.5 audit
- ‚úÖ Mark as ‚úÖ FIXED in Phase 9 report

**Example Phase 2.5 ‚Üí Phase 4 Fix:**

```markdown
# Phase 2.5 Commitment:
‚ùå README.md line 18: Claims "800+ items" ‚Üí Reality: 299 items

# Phase 4 Action (MANDATORY):
1. Read README.md
2. Find line 18: "Current Inventory: 800+ equipment items tracked across 5 active dealers"
3. Edit line 18 to: "Current Inventory: 299 equipment items (Lion Machinery - 1 active dealer)"
4. Save README.md using Edit tool
5. Update commitment status: ‚è≥ PENDING FIX ‚Üí ‚úÖ FIXED
```

**Step 3: Update Remaining Sections**
- Ensure all standard sections present (Features, Installation, Usage, Configuration, etc.)
- Update feature list from audit findings (add new features discovered in Phase 2)
- Add badges if missing (build status, coverage, version)
- Verify installation instructions are accurate
- Update links to documentation

**Step 4: Save Updated README.md**
- Use Edit tool to apply ALL changes
- Do NOT create WO-DOC-* work order recommendations
- Do NOT defer to future work
- Apply changes NOW in this command execution

**Valid Skip Reasons (ONLY):**
- ‚úÖ Value already 100% correct (no update needed)
- ‚úÖ Requires user input APO doesn't have (e.g., license choice, API keys)
- ‚úÖ Requires code changes (documentation follows code, not vice versa)

**Invalid Skip Reasons (FORBIDDEN):**
- ‚ùå "Too much work"
- ‚ùå "User might not want this"
- ‚ùå "Will create work order recommendation instead"
- ‚ùå "Too many changes to make"
- ‚ùå "Documentation is outdated but functional"

**If APO skips ANY Phase 2.5 inaccuracy fix, APO MUST explain WHY with valid skip reason in Phase 9 report "Skipped Updates" section.**

---

#### 4b. Subdirectory READMEs

**Rule:** Every directory with CLAUDE.md gets a README.md

**CRITICAL: APO MUST:**
1. Scan entire codebase for ALL CLAUDE.md files (use Glob tool: `**/*CLAUDE.md`)
2. For EACH directory containing CLAUDE.md, create/update README.md in THAT directory
3. ONLY create READMEs in directories with CLAUDE.md (never assume src/, lib/, etc.)

**Example Scan:**
```
Found CLAUDE.md files:
- CLAUDE.md (root - already has root README.md)
- api/CLAUDE.md ‚Üí CREATE/UPDATE api/README.md
- web/CLAUDE.md ‚Üí CREATE/UPDATE web/README.md
- web/components/CLAUDE.md ‚Üí CREATE/UPDATE web/components/README.md
- cli/CLAUDE.md ‚Üí CREATE/UPDATE cli/README.md

Do NOT create:
- src/README.md (no src/CLAUDE.md found)
- lib/README.md (no lib/CLAUDE.md found)
- utils/README.md (no utils/CLAUDE.md found)
```

**CRITICAL: APO MUST USE PHASE 1 DISCOVERY RESULTS - NO HARDCODING**

**For EACH directory in Phase 1 "missing_readmes" list:**

1. **Read the corresponding CLAUDE.md file** to understand directory purpose
2. **Detect directory type** using path analysis (see rules below)
3. **Generate README.md** using appropriate template
4. **Create the README.md file** using Write tool

**Directory Type Detection Rules:**

**Type A: Source Code Directory (src/, lib/, app/)**
- **Detection:** Path contains "src", "lib", or "app" (e.g., `api/src`, `web/app`, `cli/lib`)
- **README Template:**
  ```markdown
  # {Directory Name}

  {Purpose extracted from CLAUDE.md}

  ## Directory Structure

  {Use ls or tree to show actual subdirectories and key files}

  ## Key Components

  {List major files/modules with descriptions from filesystem}

  ## Architecture

  {Extract from CLAUDE.md - framework, patterns, organization}

  ## Development

  See [{directory}/CLAUDE.md](CLAUDE.md) for development patterns and debugging.
  ```

**Type B: Database Directory**
- **Detection:** Directory name is "database", "db", or "migrations"
- **README Template:**
  ```markdown
  # Database

  {Extract database info from CLAUDE.md}

  ## Schema Files

  {List actual files from filesystem - init.sql, migrations/, etc.}

  ## Database Info

  {Extract from CLAUDE.md - database type, version, tables}

  ## Setup

  {Extract setup instructions from CLAUDE.md or show standard setup}

  ## Documentation

  See [database/CLAUDE.md](CLAUDE.md) for database patterns.
  ```

**Type C: Trinity Directory**
- **Detection:** Directory name is "trinity"
- **README Template:**
  ```markdown
  # Trinity Method

  Trinity Method v2.0 implementation for {project name}.

  ## Directory Structure

  {Use ls to show actual trinity/ subdirectories}

  ## Key Files

  {List actual files in trinity/knowledge-base/ with line counts}

  ## Trinity Commands

  ```bash
  /trinity-start          # Start workflow guide
  /trinity-audit          # Run codebase audit
  /trinity-docs           # Update documentation
  /trinity-orchestrate    # Workflow orchestration
  ```

  ## Documentation

  See [trinity/CLAUDE.md](CLAUDE.md) for Trinity Method context.
  ```

**Type D: Test Directory**
- **Detection:** Directory name contains "test", "__tests__", "spec"
- **README Template:**
  ```markdown
  # {Directory Name}

  {Extract testing info from CLAUDE.md}

  ## Test Structure

  {Use ls to show actual test files and subdirectories}

  ## Running Tests

  {Extract test commands from CLAUDE.md or package.json scripts}

  ## Coverage

  {If coverage info exists in CLAUDE.md, include it}

  ## Documentation

  See [{directory}/CLAUDE.md](CLAUDE.md) for testing patterns.
  ```

**Type E: Nested Subdirectory (2+ levels deep)**
- **Detection:** Path has 2+ levels (e.g., `backend/src`, `frontend/app`, `frontend/app/lib`)
- **When to Use:** Directory is nested inside another directory (not at root level)
- **README Template:**
  ```markdown
  # {Directory Name}

  {Purpose extracted from CLAUDE.md - usually first paragraph}

  ## Location in Project

  **Path:** `{relative_path_from_root}`
  **Parent:** `{parent_directory_name}`
  **Level:** {depth} levels from root

  ## Directory Contents

  {Use `ls` or `tree` to show actual subdirectories and files}

  ```
  {directory_name}/
  ‚îú‚îÄ‚îÄ {subdirectory1}/
  ‚îú‚îÄ‚îÄ {subdirectory2}/
  ‚îú‚îÄ‚îÄ {file1}
  ‚îú‚îÄ‚îÄ {file2}
  ‚îî‚îÄ‚îÄ ...
  ```

  ## Purpose

  {Extract from CLAUDE.md - what this directory is responsible for}

  ## Key Components

  {List major files/subdirectories with brief descriptions}

  ### {Component 1}
  **Location:** `{path}`
  **Purpose:** {description}

  ### {Component 2}
  **Location:** `{path}`
  **Purpose:** {description}

  ## Architecture Patterns

  {Extract from CLAUDE.md - any architectural patterns specific to this directory}

  ## Usage Examples

  {If CLAUDE.md contains usage examples, include them}

  ```javascript
  // Example from CLAUDE.md
  import { something } from './{this_directory}'
  ```

  ## Development Guidelines

  {Extract from CLAUDE.md - coding standards, conventions, patterns}

  ## Related Documentation

  - Parent directory: [{parent}/README.md](../README.md)
  - Root documentation: [CLAUDE.md](./CLAUDE.md)
  - Project root: [README.md](../../README.md) {adjust path depth}

  ---

  **Developer Guide:** See [CLAUDE.md](CLAUDE.md) for detailed technical context and debugging patterns.
  ```

**Example for backend/src/:**

```markdown
# backend/src/

Core Express.js backend source code for {Project Name}.

## Location in Project

**Path:** `backend/src/`
**Parent:** `backend/`
**Level:** 2 levels from root

## Directory Contents

```
backend/src/
‚îú‚îÄ‚îÄ routes/          # Express route handlers
‚îú‚îÄ‚îÄ services/        # Business logic layer
‚îú‚îÄ‚îÄ middleware/      # Express middleware
‚îú‚îÄ‚îÄ utils/           # Utility functions
‚îú‚îÄ‚îÄ config/          # Configuration management
‚îú‚îÄ‚îÄ server.js        # Express application entry point
‚îî‚îÄ‚îÄ app.js           # Express app configuration
```

## Purpose

Contains all Express.js backend application code including API routes, business logic services, and middleware. This is the core of the backend system.

## Key Components

### routes/
**Location:** `backend/src/routes/`
**Purpose:** Express route handlers organized by resource

### services/
**Location:** `backend/src/services/`
**Purpose:** Business logic layer implementing core functionality

### middleware/
**Location:** `backend/src/middleware/`
**Purpose:** Express middleware for authentication, validation, and error handling

## Architecture Patterns

- **Layered Architecture:** Routes ‚Üí Services ‚Üí Database
- **Dependency Injection:** Services injected into routes via factory pattern
- **Error Handling:** Centralized error middleware catches all route errors

## Development Guidelines

- All routes must use async/await (no callbacks)
- Services must be stateless and testable
- Middleware must call `next()` or send response (never both)

## Related Documentation

- Parent directory: [backend/README.md](../README.md)
- Root documentation: [CLAUDE.md](./CLAUDE.md)
- API Documentation: [../../docs/API.md](../../docs/API.md)

---

**Developer Guide:** See [CLAUDE.md](CLAUDE.md) for Express.js debugging patterns and performance optimization.
```

**APO MUST:**
- ‚úÖ Create README.md for **EVERY** directory in "missing_readmes" list
- ‚úÖ Use appropriate template based on directory type detection
- ‚úÖ Extract real content from CLAUDE.md file (don't invent content)
- ‚úÖ Use filesystem tools (ls, tree, Glob) to list actual files/subdirectories
- ‚úÖ NO HARDCODING of specific paths (api/src, web/app, etc.)
- ‚úÖ Dynamically generate based on Phase 1 discovery

**APO MUST NOT:**
- ‚ùå Skip any directory from "missing_readmes" list
- ‚ùå Hardcode assumed paths (backend/src, frontend/app, etc.)
- ‚ùå Create READMEs for directories WITHOUT CLAUDE.md
- ‚ùå Use placeholder content (all content must be real from CLAUDE.md/filesystem)

---

#### 4c. README Creation Completion Verification (MANDATORY CHECKPOINT)

**CRITICAL: APO CANNOT proceed to Phase 5 until this checkpoint PASSES**

**Goal:** Ensure 100% completion of Phase 4b README creation requirements

**Step 1: Count Missing READMEs (From Phase 1)**
```javascript
missing_readmes_from_phase1 = [list from Phase 1 discovery]
total_missing = missing_readmes_from_phase1.length
```

**Step 2: Count READMEs Created in Phase 4b**
```javascript
readmes_created_in_phase4b = [list of paths created]
total_created = readmes_created_in_phase4b.length
```

**Step 3: Calculate Coverage**
```javascript
coverage_percentage = (total_created / total_missing) * 100
```

**Step 4: Validate Skipped READMEs (if coverage < 100%)**

For EACH README not created (missing from Phase 1 but not created in Phase 4b):
- State skip reason
- Validate against allowed reasons:
  - ‚úÖ README already exists (value 100% correct)
  - ‚úÖ Requires user input APO doesn't have
  - ‚ùå "Token budget" (FORBIDDEN - no token budget limits apply to this command)
  - ‚ùå "Too much work" (FORBIDDEN)
  - ‚ùå "Prioritized other work" (FORBIDDEN)
  - ‚ùå "Deferred to future session" (FORBIDDEN)

**Step 5: Pass/Fail Decision (BINARY - NO "PARTIAL")**

```
if coverage == 100%:
  status = PASS
elif coverage < 100% AND all_skips_valid:
  status = PASS (with valid exceptions)
else:
  status = FAIL
```

**ONLY TWO VALID STATUSES:**
- ‚úÖ **PASSED** - Coverage = 100% OR (Coverage < 100% AND all skips valid)
- ‚ùå **FAILED** - Coverage < 100% AND any skip has invalid reason

**FORBIDDEN STATUSES:**
- ‚ö†Ô∏è "PARTIAL" (not defined in specification)
- ‚è≥ "IN PROGRESS" (checkpoint is binary evaluation)
- üîÑ "PENDING" (not applicable)

**APO MUST use ONLY ‚úÖ PASSED or ‚ùå FAILED.**

**APO MUST Output Checkpoint Report:**

```markdown
### Phase 4c Checkpoint: README Creation Completeness

**Missing READMEs (Phase 1):** {total_missing}
**READMEs Created (Phase 4b):** {total_created}
**Coverage:** {coverage_percentage}% ({total_created}/{total_missing})

**Checkpoint Status:** {‚úÖ PASS | ‚ùå FAIL}

**If PASS:**
‚úÖ All required READMEs created OR all skips have valid reasons.
Proceeding to Phase 5.

**If FAIL:**
‚ùå Phase 4c CHECKPOINT FAILED
Reason: {X} READMEs skipped with INVALID reasons

Invalid Skip Reasons:
- {directory1}: "{invalid_reason}" (FORBIDDEN - see valid reasons above)
- {directory2}: "{invalid_reason}" (FORBIDDEN - see valid reasons above)

**ACTION REQUIRED:**
APO MUST immediately return to Phase 4b and create the missing READMEs.
DO NOT proceed to Phase 5 until Phase 4c checkpoint PASSES.
```

**Step 6: Checkpoint Action (ENFORCED)**

```python
if status == PASS:
  print("‚úÖ Phase 4c Checkpoint PASSED - Proceeding to Phase 4d")
  goto Phase_4d

elif status == FAIL:
  print("‚ùå Phase 4c Checkpoint FAILED")
  print("Invalid skip reasons detected. Returning to Phase 4b.")

  # MANDATORY LOOP-BACK
  goto Phase_4b
  # Create ALL READMEs with invalid skip reasons
  # Re-run Phase 4c
  # Repeat until PASS
```

**APO CANNOT execute Phase 4d or Phase 5 until this checkpoint returns PASS.**

**Example Checkpoint Failure Scenario:**

```
Phase 4c Checkpoint Results:
- Missing READMEs (Phase 1): 4
- READMEs Created (Phase 4b): 2
- Coverage: 50% (2/4)

Skipped READMEs:
1. frontend/README.md - Reason: "Token budget constraints"
   Validation: ‚ùå INVALID (no token budget limits apply)

2. database/README.md - Reason: "Too much work"
   Validation: ‚ùå INVALID (all work must be completed)

Checkpoint Status: ‚ùå FAILED

ACTION: Returning to Phase 4b to create 2 missing READMEs
[APO creates frontend/README.md]
[APO creates database/README.md]
[APO re-runs Phase 4c]

Phase 4c Re-Check:
- Missing READMEs (Phase 1): 4
- READMEs Created (Phase 4b): 4
- Coverage: 100% (4/4)

Checkpoint Status: ‚úÖ PASSED

Proceeding to Phase 4d...
```

**This prevents APO from:**
- Bypassing checkpoint without completing work
- Reporting "PARTIAL" when specification defines PASS/FAIL only
- Skipping to Phase 9 when work incomplete

---

#### 4d. Existing README Updates (PHASE 2 INACCURACY FIXES)

**Goal:** Apply ALL Phase 2.5 inaccuracy corrections to existing subdirectory READMEs

**CRITICAL: Phase 4b created NEW missing READMEs. Phase 4d updates EXISTING subdirectory READMEs with corrections.**

**Step 1: Review Phase 2.5 Commitment List**

From Phase 2.5, APO has a list of ALL inaccuracies found:
- Root README.md inaccuracies (from Phase 2a-2f)
- Subdirectory README inaccuracies (from Phase 2g)

**Step 2: Group Inaccuracies by File**

Organize Phase 2.5 commitment list by README file:

```markdown
### Root README.md Fixes:
- Inaccuracy 1: {description}
- Inaccuracy 2: {description}

### api/README.md Fixes:
- Inaccuracy 3: {description}
- Inaccuracy 4: {description}

### frontend/README.md Fixes:
- Inaccuracy 5: {description}
```

**Step 3: Update Each README File**

For EACH existing README with inaccuracies:

1. **Read current README content**
2. **Apply ALL fixes from Phase 2.5 for this file**:
   - Correct quantitative claims (file counts, test counts, etc.)
   - Fix broken links
   - Update feature descriptions to match reality
   - Correct API/component documentation
3. **Use Edit tool to apply corrections**
4. **Mark Phase 2.5 inaccuracy as ‚úÖ FIXED**

**Step 4: Verify All Phase 2.5 Fixes Applied**

After updating all READMEs, verify:
- Every inaccuracy from Phase 2.5 is now marked ‚úÖ FIXED
- No inaccuracies remain as ‚è≥ PENDING FIX

**Output Format:**
```markdown
### Phase 4d: Existing README Update Results

**READMEs Updated:** {count}

#### Root README.md:
- ‚úÖ Fixed: Corrected "50 components" ‚Üí "42 components"
- ‚úÖ Fixed: Updated broken link to `docs/api.md` ‚Üí `docs/api/README.md`
- **Total Fixes Applied:** 2

#### api/README.md:
- ‚úÖ Fixed: Corrected "15 API endpoints" ‚Üí "12 API endpoints"
- ‚úÖ Fixed: Fixed link to `api/docs/swagger.md`
- **Total Fixes Applied:** 2

#### frontend/README.md:
- ‚ÑπÔ∏è No fixes needed (no inaccuracies found in Phase 2g)

**Total Phase 2.5 Inaccuracies Fixed:** {count}
**Remaining Unfixed:** {should be 0}
```

**Validation:**

APO MUST verify:
- ‚úÖ All Phase 2.5 inaccuracies = ‚úÖ FIXED status
- ‚úÖ No ‚è≥ PENDING FIX items remain
- ‚úÖ All existing READMEs now contain verified, accurate information

**If any inaccuracies remain unfixed:**
1. Report which inaccuracies were not fixed and why
2. Loop back to Step 3 and fix remaining items
3. Re-run verification

---

### Phase 5: docs/ Directory Management

**Standard docs/ Structure:**
```
docs/
‚îú‚îÄ‚îÄ api/              # API documentation
‚îú‚îÄ‚îÄ architecture/     # Architecture diagrams and docs
‚îú‚îÄ‚îÄ guides/           # User guides and tutorials
‚îÇ   ‚îú‚îÄ‚îÄ getting-started.md
‚îÇ   ‚îú‚îÄ‚îÄ configuration.md
‚îÇ   ‚îî‚îÄ‚îÄ troubleshooting.md
‚îú‚îÄ‚îÄ development/      # Developer documentation
‚îÇ   ‚îú‚îÄ‚îÄ setup.md
‚îÇ   ‚îú‚îÄ‚îÄ testing.md
‚îÇ   ‚îî‚îÄ‚îÄ contributing.md
‚îî‚îÄ‚îÄ README.md         # Docs navigation

# NOTE: CHANGELOG.md, CONTRIBUTING.md, LICENSE go in root, not docs/
```

**APO Actions:**
1. **Create Missing Documentation:**
   - Getting started guide
   - Configuration guide
   - Troubleshooting guide
   - API documentation (if applicable)
   - Architecture documentation

2. **Update Existing Documentation:**
   - Add new features from audit
   - Update outdated examples
   - Fix broken links
   - Improve clarity

3. **Organize Documentation:**
   - Ensure proper categorization
   - Create docs/README.md for navigation
   - Add table of contents to long docs
   - Cross-reference related documents

---

### Phase 6: CHANGELOG Management

**Location:** `CHANGELOG.md` (root only, NOT docs/CHANGELOG.md)

**CRITICAL: APO must generate comprehensive, accurate CHANGELOGs by comparing actual version changes, NOT just summarizing commits.**

---

#### 6a. Version Comparison Workflow

**For New Version Releases (e.g., v1.0 ‚Üí v2.0):**

**Step 1: Identify Version Baseline**
1. Read project manifest (package.json, Cargo.toml, pyproject.toml, etc.) ‚Üí current version
2. Read `CHANGELOG.md` ‚Üí find previous version entry
3. Identify baseline version for comparison (e.g., v1.0.0 as baseline for v2.0.0)

**Step 2: Locate Previous Version Reference Documentation**

**Search for previous version documentation in this order:**
1. Check for version-tagged README (any naming pattern: `V1.0.0 Read Me.md`, `README-v1.0.0.md`, `docs/v1.0/README.md`, etc.)
2. Check git tags for previous version: `git show v{previous}:README.md`
3. Check `docs/` or `archive/` directories for versioned documentation
4. If none found: Use previous CHANGELOG entry as baseline (least preferred)

**Step 3: Systematic Comparison Categories**

APO MUST compare these aspects between versions (adapt categories to project type):

**A. Core Component Changes (Universal):**
- Count major components/modules in previous version
- Count major components/modules in current version
- Calculate: Added, removed, renamed, reorganized
- Document each new component with its purpose
- **Examples**: Classes, modules, services, agents, plugins, libraries, packages

**B. Public API/Interface Changes (Universal):**
- Previous version public APIs/commands/endpoints
- Current version public APIs/commands/endpoints
- Calculate: New, deprecated, removed, renamed
- Document purpose and signature of each new API
- **Examples**: CLI commands, REST endpoints, function exports, class methods

**C. Feature/Capability Changes (Universal):**
- Previous version feature list (from README/docs)
- Current version feature list (from Phase 2 audit)
- Calculate: New features, removed features, enhanced features
- Document user-facing impact
- **Examples**: Authentication, caching, workflows, integrations, UI components

**D. Architecture/System Design Changes (Universal):**
- Previous system architecture (from docs/README)
- Current system architecture (from codebase audit)
- Document fundamental design shifts
- **Examples**: Monolith‚ÜíMicroservices, Sync‚ÜíAsync, Client-side‚ÜíServer-side

**E. Breaking Changes (Universal):**
- API signature changes (function/method signatures)
- Configuration format changes (config file structures, env vars)
- Dependency changes (minimum versions, dropped support)
- Removed features (functionality in v{previous} but not current)
- Behavioral changes (same API, different behavior)

**F. Bug Fixes & Improvements (Universal):**
- Review interim CHANGELOG "Fixed" sections
- Review git commits with "fix:", "bug:", "patch:" prefixes
- Document resolved issues with issue numbers if available

---

#### 6b. CHANGELOG Entry Generation Protocol

**For MAJOR version bump (e.g., v1.0 ‚Üí v2.0):**

APO MUST create comprehensive entry with these sections:

```markdown
## [X.0.0] - YYYY-MM-DD

### Changed (BREAKING)

**Major Architectural Changes:**
- [Describe fundamental system redesign]
- [Component expansion: v{previous} had X ‚Üí v{current} has Y]
- [Architecture transformation: old approach ‚Üí new approach]
- [API changes: breaking interface modifications]

**Breaking Changes:**
For each breaking change, document:
- **What changed**: Specific API/feature/behavior modification
- **Why it changed**: Technical or design rationale
- **Impact on users**: Who is affected and how
- **Migration path**: Steps to adapt (reference Migration Guide below)

### Added

**New Components/Modules:**
- Component Name - Purpose and responsibility
[List ALL new major components]

**New Public APIs:**
- `api.method()` - Purpose and signature
[List ALL new public interfaces]

**New Features:**
- Feature name - User-facing description
[List ALL new user-facing features]

### Removed

**Deprecated/Removed:**
- Feature/API name - Reason for removal
- Replacement (if any): [name and migration path]

### Fixed

**Bug Fixes:**
- Issue description - How it was resolved
- Reference issue numbers if available (#123)

### Migration Guide

**From v{previous} to v{current}:**

1. **Breaking Change Category 1:**
   - **Old behavior**: [description]
   - **New behavior**: [description]
   - **Migration steps**:
     1. [Step-by-step instructions]
     2. [Code examples if applicable]

2. **Breaking Change Category 2:**
   - **Old API**: `oldMethod(params)`
   - **New API**: `newMethod(params)`
   - **Migration**: [why changed, how to update]

[Continue for each breaking change category]

[Unreleased]: https://github.com/user/repo/compare/v{current}...HEAD
[{current}]: https://github.com/user/repo/compare/v{previous}...v{current}
[{previous}]: https://github.com/user/repo/releases/tag/v{previous}
```

---

#### 6c. Completeness Validation Checklist

**Before finalizing CHANGELOG entry, APO MUST verify:**

- ‚úÖ **Component/module accuracy**: If components changed, every new component is listed with purpose
- ‚úÖ **API/interface accuracy**: If public APIs changed, every new/modified API is documented
- ‚úÖ **Feature completeness**: All new user-facing features are documented
- ‚úÖ **Breaking changes completeness**: Every breaking change has migration guidance
- ‚úÖ **Comparison against baseline**: Compared current version against previous version documentation
- ‚úÖ **No trivial minimization**: Don't reduce major redesigns to vague summaries
- ‚úÖ **Migration guide present**: For MAJOR versions with breaking changes, migration guide is required
- ‚úÖ **Version links work**: All version comparison links are valid repository URLs
- ‚úÖ **[Unreleased] section exists**: Always maintain [Unreleased] section at top

---

#### 6d. Version Comparison Examples

**Example 1: SDK/CLI Project - Major Version (v1.0 ‚Üí v2.0)**

APO locates v1.0 documentation (previous README or git tag):
- v1.0 had 7 core modules
- v1.0 had 8 CLI commands
- v1.0 deployed 49 components

APO runs Phase 2 audit on current codebase:
- v2.0 has 19 core modules (12 new)
- v2.0 has 17 CLI commands (9 new)
- v2.0 deploys 75+ components (26+ new)

**CHANGELOG Result**:
```markdown
## [2.0.0] - YYYY-MM-DD

### Changed (BREAKING)
- Module system expanded from 7 to 19 core modules
- CLI command set expanded from 8 to 17 commands
- Deployment scope increased from 49 to 75+ components

### Added
**New Modules (12 total):**
- ModuleName1 - Purpose
- ModuleName2 - Purpose
[...list all 12]

**New CLI Commands (9 total):**
- `command-name` - Purpose
[...list all 9]

### Migration Guide
1. **Module Changes**: [migration steps]
2. **Command Changes**: [migration steps]
```

**Example 2: Web API Project - Minor Version (v2.0 ‚Üí v2.1)**

APO compares v2.0 documentation with current audit:
- No endpoint count change
- 1 new REST endpoint
- 2 new features (rate limiting, caching)
- 3 bug fixes

**CHANGELOG Result**:
```markdown
## [2.1.0] - YYYY-MM-DD

### Added
- `POST /api/v2/new-endpoint` - Purpose and description
- Rate limiting system for API endpoints
- Response caching for improved performance

### Fixed
- Fixed authentication token expiration bug (#123)
- Resolved database connection pool leak (#124)
- Corrected JSON serialization for nested objects (#125)
```

**Example 3: Library Project - Patch Version (v2.1.0 ‚Üí v2.1.1)**

APO compares:
- No API changes
- 1 critical bug fix
- 1 documentation update

**CHANGELOG Result**:
```markdown
## [2.1.1] - YYYY-MM-DD

### Fixed
- Fixed memory leak in event handler cleanup (#126)

### Documentation
- Updated installation guide with Node 18+ requirement
```

---

#### 6e. Anti-Patterns to Avoid

**‚ùå DON'T:**
- Summarize major redesign as "refactored X functions" or "improved code quality"
- Omit new components/APIs because "there are too many to list"
- Use vague statements like "Updated to v2.0" without explaining what changed
- Skip migration guide for breaking changes (MAJOR versions require migration)
- Copy git commit messages verbatim without user-facing context
- Document internal refactoring as if it were a user-facing feature

**‚úÖ DO:**
- List every significant user-facing change with details
- Explain WHY changes were made (technical rationale, user benefit)
- Provide clear migration steps for breaking changes with code examples
- Compare against previous version explicitly using baseline documentation
- Include user-facing impact for each change (who benefits, how)
- Group related changes logically (e.g., all API changes together)

---

#### 6f. Standard Format Template

**APO MUST follow Keep-a-Changelog format:**

```markdown
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

### Added
- Features added but not yet released

### Changed
- Changes to existing functionality (non-breaking for minor/patch)

### Fixed
- Bug fixes

---

## [X.Y.Z] - YYYY-MM-DD

[Use templates from 6b based on version type]

---

## [Previous Version] - YYYY-MM-DD

[Previous version entries remain unchanged]

[Unreleased]: https://github.com/user/repo/compare/vX.Y.Z...HEAD
[X.Y.Z]: https://github.com/user/repo/compare/vA.B.C...vX.Y.Z
[A.B.C]: https://github.com/user/repo/releases/tag/vA.B.C
```

---

**APO Output for Phase 6:**
- Complete CHANGELOG entry with all changes documented
- Version comparison summary (what changed from previous version)
- Completeness validation report (checklist confirmation)

---

### Phase 8: Documentation Best Practices

**APO Ensures:**

1. **Consistency:**
   - Same terminology throughout
   - Consistent code style in examples
   - Uniform heading structure
   - Standardized formatting

2. **Accessibility:**
   - Clear language (avoid jargon)
   - Examples for all concepts
   - Progressive difficulty (simple ‚Üí complex)
   - Search-friendly headings

3. **Maintainability:**
   - DRY principle (Don't Repeat Yourself)
   - Links instead of duplication
   - Versioned documentation
   - Clear update dates

4. **Completeness:**
   - All public APIs documented
   - Error messages explained
   - Edge cases covered
   - Migration guides for breaking changes

---

### Phase 7: Documentation Completeness Validation

**Goal:** Guarantee no documentation gaps through systematic validation

**APO Must Execute These Checks:**

#### 7a. CLAUDE.md ‚Üí README.md Coverage Validation

**CRITICAL: Re-run Phase 1 discovery to verify ALL READMEs were created**

**Step 1: Re-run Glob**
```bash
Use Glob tool with pattern: "**/CLAUDE.md"
```

**Step 2: Verify Each Directory Has README.md**

```javascript
missing_readmes = []

For each CLAUDE.md path:
  directory = dirname(path)
  readme_path = directory + "/README.md"

  if NOT exists(readme_path):
    missing_readmes.append(directory)
```

**Step 3: Calculate Coverage**

APO MUST output:
```
Phase 7a CLAUDE.md Coverage Validation:
- Total CLAUDE.md directories: {count}
- READMEs created: {count}
- Coverage: {percentage}%
```

**Expected Result:**
- Coverage: **100%** (ALL directories with CLAUDE.md have README.md)

**If coverage < 100%:**
- ‚ùå **FAIL validation**
- List missing READMEs: {directories}
- **Action Required:** Return to Phase 4 and create missing READMEs
- Re-run Phase 7a validation until coverage = 100%

**Only proceed to 7b if coverage = 100%**

---

#### 7b. API Documentation Validation (If Project Has API Docs)

**Check if project generates API documentation:**

**Common patterns to check:**
- `docs:generate` or `docs:build` script in package.json/Makefile/build scripts
- API documentation tool (TypeDoc, JSDoc, Sphinx, Javadoc, Godoc, RustDoc, etc.)
- docs/ directory with generated API references

**If API docs generation exists:**

1. **Run Generation Command:**
   - Try: `npm run docs:generate`, `make docs`, `cargo doc`, `go doc`, etc.
   - Verify command completes without errors
   - Check for warnings about missing documentation

2. **Verify Output:**
   - API documentation files exist in docs/ or similar
   - All public APIs/functions/classes are documented
   - Generated docs are up-to-date with current code

3. **Update README:**
   - Link to API documentation
   - Explain how to regenerate docs
   - Note any API coverage metrics

**If NO API docs generation:**
- Skip this check (not all projects need generated API docs)
- Focus on README examples and inline code comments

---

#### 7c. Root Documentation Files Validation

**Required Files (Must Exist in Root):**
- ‚úÖ `README.md` - Project overview with current features
- ‚úÖ `CHANGELOG.md` - Version history (Keep-a-Changelog format)
- ‚úÖ `CONTRIBUTING.md` - Contribution guidelines
- ‚úÖ `LICENSE` - License file

**Validation Checks:**
1. **README.md:**
   - Has installation instructions
   - Lists all major features (cross-reference with audit)
   - Includes usage examples that match current API
   - Links to detailed documentation work
   - Has badges (build status, coverage, version)

2. **CHANGELOG.md:**
   - Has entry for current version (from project manifest)
   - Follows Keep-a-Changelog format
   - [Unreleased] section exists for ongoing work
   - Links to release tags work

3. **CONTRIBUTING.md:**
   - Describes development setup process
   - Documents testing requirements
   - Explains PR process
   - Matches actual project workflow

4. **LICENSE:**
   - Contains valid license text
   - Matches project manifest license field

---

#### 7d. Documentation Consistency Validation

**Cross-Reference Checks:**

1. **Version Consistency:**
   - Project manifest version matches CHANGELOG.md latest version
   - README.md badges show correct version
   - All documentation references current version

2. **API Consistency:**
   - README.md examples use current API
   - Code examples in docs match actual function signatures
   - No references to deprecated/removed features

3. **Link Validation:**
   - All internal links work (README ‚Üí docs/, CONTRIBUTING ‚Üí docs/, etc.)
   - All cross-references between docs are valid
   - No 404s or broken relative paths

4. **File Structure Consistency:**
   - Every directory with CLAUDE.md has a README.md
   - docs/adr/ files follow ADR template
   - No duplicate files (e.g., CONTRIBUTING.md in both root and docs/)

---

#### 7e. Documentation Coverage Metrics

**APO Must Calculate:**

1. **API Documentation Coverage:**
   - Total exported functions/classes: {count}
   - Documented with JSDoc: {count}
   - Coverage percentage: {percentage}%
   - **Minimum Required: 80%**

2. **Feature Documentation Coverage:**
   - Features identified in audit: {count}
   - Features documented in README: {count}
   - Coverage percentage: {percentage}%
   - **Minimum Required: 100%**

3. **File Documentation Coverage:**
   - Directories with CLAUDE.md: {count}
   - Directories with README.md: {count}
   - Coverage percentage: {percentage}%
   - **Minimum Required: 100%**

**If Coverage Below Minimum:**
- Identify specific gaps
- Create missing documentation
- Re-validate until requirements met

---

### Phase 8: Documentation Best Practices

**APO Ensures:**

1. **Consistency:**
   - Same terminology throughout
   - Consistent code style in examples
   - Uniform heading structure
   - Standardized formatting

2. **Accessibility:**
   - Clear language (avoid jargon)
   - Examples for all concepts
   - Progressive difficulty (simple ‚Üí complex)
   - Search-friendly headings

3. **Maintainability:**
   - DRY principle (Don't Repeat Yourself)
   - Links instead of duplication
   - Versioned documentation
   - Clear update dates

4. **Completeness:**
   - All public APIs documented
   - Error messages explained
   - Edge cases covered
   - Migration guides for breaking changes

---

## Work Completion Criteria

**APO's work is COMPLETE when ALL criteria below are met:**

### Hard Requirements (MUST be 100%)

1. **‚úÖ Phase Execution:** All 9 phases executed (1, 2, 2.5, 3, 4a-4d, 5, 6, 7, 8, 9)
2. **‚úÖ README Coverage:** 100% (every directory with CLAUDE.md has README.md)
3. **‚úÖ Phase 2.5 Fixes:** 100% (all inaccuracies identified in Phase 2 are fixed in Phase 4)
4. **‚úÖ Phase 4c Checkpoint:** PASSED (not FAILED, not PARTIAL)
5. **‚úÖ Phase 7a Validation:** PASSED (100% coverage confirmed)

### Soft Requirements (SHOULD be addressed)

6. **‚úÖ docs/ Management:** docs/ directory organized and updated
7. **‚úÖ CHANGELOG Verified:** CHANGELOG.md verified or updated per Phase 6
8. **‚úÖ Documentation Consistency:** All versions, APIs, links validated per Phase 7d

### APO Work Status Determination

```python
hard_requirements_met = (
    phases_executed == 9 AND
    readme_coverage == 100 AND
    phase_2_5_fixes == 100 AND
    phase_4c_status == "PASSED" AND
    phase_7a_status == "PASSED"
)

if hard_requirements_met AND soft_requirements_met:
    status = "‚úÖ SUCCESS"
elif hard_requirements_met:
    status = "‚ö†Ô∏è PARTIAL SUCCESS" (valid use of PARTIAL - hard requirements met, soft requirements incomplete)
else:
    status = "‚ùå FAILED"
```

### Example SUCCESS

```
Work Completion Criteria:
1. Phase Execution: 9/9 phases ‚úÖ
2. README Coverage: 100% (8/8) ‚úÖ
3. Phase 2.5 Fixes: 100% (8/8) ‚úÖ
4. Phase 4c Checkpoint: PASSED ‚úÖ
5. Phase 7a Validation: PASSED ‚úÖ
6. docs/ Management: Complete ‚úÖ
7. CHANGELOG Verified: Up-to-date ‚úÖ
8. Documentation Consistency: Validated ‚úÖ

Overall Status: ‚úÖ SUCCESS
```

### Example FAILURE

```
Work Completion Criteria:
1. Phase Execution: 5/9 phases ‚ùå (Phases 5-8 skipped)
2. README Coverage: 50% (4/8) ‚ùå
3. Phase 2.5 Fixes: 100% (8/8) ‚úÖ
4. Phase 4c Checkpoint: FAILED ‚ùå
5. Phase 7a Validation: NOT EXECUTED ‚ùå

Overall Status: ‚ùå FAILED
Reason: Hard requirements not met (1, 2, 4, 5 failed)
```

**This prevents:**
- Ambiguous "partial success" when work fundamentally incomplete
- APO claiming success with 50% coverage
- User confusion about what "partial" means

---

### Phase 9: Documentation Audit Report

**APO Generates:** `trinity/reports/DOCUMENTATION-AUDIT-{date}.md`

**CRITICAL: Report MUST document COMPLETED work, not future recommendations or work orders.**

**Required Report Structure:**

```markdown
# Documentation Audit Report

**Project:** {project-name}
**Audit Date:** {date}
**Auditor:** APO (Documentation Specialist)

## Executive Summary
**Documentation Score:** {score}/10
**Files Created:** {count}
**Files Updated:** {count}
**Phase 2.5 Inaccuracies Fixed:** {fixed}/{total}
**Phase 2.5 Completion:** {percentage}%
**CLAUDE.md ‚Üí README.md Coverage:** {count}/{total} ({percentage}%)

**COMMAND EXECUTION STATUS:** {‚úÖ SUCCESS | ‚ö†Ô∏è PARTIAL SUCCESS | ‚ùå FAILED}

### Hard Requirements Status
1. **Phase Execution:** {executed}/{total} phases ‚úÖ/‚ùå
2. **README Coverage:** {percentage}% ({count}/{total}) ‚úÖ/‚ùå (Target: 100%)
3. **Phase 2.5 Fixes:** {percentage}% ({fixed}/{total}) ‚úÖ/‚ùå (Target: 100%)
4. **Phase 4c Checkpoint:** {‚úÖ PASSED | ‚ùå FAILED}
5. **Phase 7a Validation:** {‚úÖ PASSED | ‚ùå FAILED | ‚è∏Ô∏è NOT EXECUTED}

**If ALL 5 hard requirements = ‚úÖ AND all soft requirements met: STATUS = ‚úÖ SUCCESS**
**If ALL 5 hard requirements = ‚úÖ BUT some soft requirements missing: STATUS = ‚ö†Ô∏è PARTIAL SUCCESS**
**If ANY hard requirement = ‚ùå: STATUS = ‚ùå FAILED**

## Phase 2.5 Inaccuracies ‚Üí Fixes Applied

**MANDATORY: Report ALL Phase 2.5 inaccuracies with fix status**

### Inaccuracy 1: {Description} ‚úÖ FIXED
- **Was (WRONG):** "{incorrect value}" (file line X)
- **Now (CORRECT):** "{correct value}"
- **Action Taken:** Updated {file} line X via Edit tool
- **Status:** ‚úÖ APPLIED

### Inaccuracy 2: {Description} ‚úÖ FIXED
- **Was (WRONG):** "{incorrect value}" (file line Y)
- **Now (CORRECT):** "{correct value}"
- **Action Taken:** Updated {file} line Y via Edit tool
- **Status:** ‚úÖ APPLIED

[... list ALL Phase 2.5 inaccuracies with fix status ...]

**Phase 2.5 Completion:** ‚úÖ All {count} inaccuracies fixed
OR
**Phase 2.5 Completion:** ‚ö†Ô∏è {fixed}/{total} inaccuracies fixed ({skipped} skipped - see Skipped Updates section)

## CLAUDE.md ‚Üí README.md Coverage

**Total CLAUDE.md Files:** {count}
**Directories with READMEs:** {count}/{total} ({percentage}%)

### Created READMEs ({count} total):
- ‚úÖ `api/src/README.md` (source code directory)
- ‚úÖ `database/README.md` (database directory)
- ‚úÖ `web/app/README.md` (application directory)
- ‚úÖ `web/app/lib/README.md` (utilities directory)
- ‚úÖ `trinity/README.md` (Trinity Method directory)
- ‚úÖ `api/tests/README.md` (backend testing)
- ‚úÖ `web/__tests__/README.md` (frontend testing)

### Existing READMEs ({count} total):
- ‚úÖ `README.md` (root - updated with Phase 4d corrections)
- ‚úÖ `api/README.md` (API overview - updated with Phase 4d corrections)
- ‚úÖ `web/README.md` (web interface overview - no corrections needed)

**Note:** Existing READMEs were updated in Phase 4d with ALL Phase 2.5 inaccuracy corrections.

**Coverage:** {percentage}% ({count}/{total} directories)

**Expected:** 100% coverage (every directory with CLAUDE.md must have README.md)

## Files Created (Past Tense - COMPLETED Work)
- ‚úÖ CONTRIBUTING.md (373 lines) - Created contributor guidelines with code of conduct
- ‚úÖ api/README.md (415 lines) - Created API architecture overview
- ‚úÖ docs/guides/configuration.md (250 lines) - Created configuration guide

## Files Updated (Past Tense - COMPLETED Work)
- ‚úÖ README.md - Fixed 3 inaccuracies (equipment count 800+‚Üí299, scraper count 5‚Üí12, test count 71‚Üí537)
- ‚úÖ CHANGELOG.md - Added [1.3.1] Phase 3B entry documenting 12 scraper implementations
- ‚úÖ docs/guides/getting-started.md - Updated installation steps for Node 18+

## Files Verified (No Changes Needed)
- ‚úÖ LICENSE - Already accurate (MIT license), no changes needed
- ‚úÖ docs/API.md - Already current with v1.3.1 endpoints, no updates required
- ‚úÖ .gitignore - Already includes node_modules, .env, no changes needed

## Skipped Updates (With Justification)

**ONLY use this section if updates were skipped with VALID reasons**

### {File} - {Section/Line}
- **Inaccuracy:** "{what was wrong}"
- **Correct Value:** "{what it should be}"
- **Skip Reason (MUST be valid):** {reason}
- **Valid Reasons Only:**
  - ‚úÖ Requires user input APO doesn't have (e.g., API keys, license choice)
  - ‚úÖ Requires code changes (documentation follows code)
  - ‚úÖ Already 100% accurate (false positive from Phase 2)

**FORBIDDEN Skip Reasons (Report as ERROR if used):**
- ‚ùå "Too much work"
- ‚ùå "User might not want this"
- ‚ùå "Created work order recommendation instead"

## Quality Improvements

### Before
- Documentation Score: 4/10
- Phase 2 Inaccuracies: {count}
- Missing READMEs: 5
- Broken Links: 12

### After
- Documentation Score: 9/10
- Phase 2 Inaccuracies: 0 (all fixed)
- Missing READMEs: 0 (all created)
- Broken Links: 0 (all fixed)

## Recommendations (Future Work - NOT Completed)

**This section is for FUTURE work, not work that should have been done now**

### Short Term
1. Add API documentation for v2.0 endpoints (requires v2.0 release)
2. Create video tutorials (requires screen recording tools)
3. Add architecture diagrams (requires diagramming tool access)

### Long Term
1. Setup automated documentation generation (TypeDoc/JSDoc integration)
2. Add documentation tests (verify code examples compile)
3. Consider Docusaurus migration for better docs site

## Next Steps
1. Review updated documentation for accuracy
2. Commit documentation changes to git
3. Update docs deployment if applicable
```

**FORBIDDEN PATTERNS (APO Must NOT Use):**

‚ùå **"Work Orders Created" section** - APO does NOT create work orders, only JUNO does
‚ùå **"WO-DOC-###" identifiers** - This pattern is ONLY used by JUNO for code issues
‚ùå **Recommendations listed as completed work** - "Recommendations" are FUTURE work, not COMPLETED work
‚ùå **Future tense for work not done** - Use past tense ("Updated") not future tense ("Update")
‚ùå **Claiming work orders were "created as files"** - Work orders are recommendations in report, not actual files

**Validation Checklist (APO MUST verify before finalizing report):**

- ‚úÖ All Phase 2.5 inaccuracies have "‚úÖ FIXED" status OR valid skip justification
- ‚úÖ "Files Created" section uses PAST TENSE ("Created", not "Create")
- ‚úÖ "Files Updated" section uses PAST TENSE ("Updated", "Fixed", not "Update", "Fix")
- ‚úÖ NO "Work Orders Created" section exists anywhere in report
- ‚úÖ NO "WO-DOC-###" identifiers appear in report
- ‚úÖ Skipped updates have VALID justifications (user input needed, code changes required)
- ‚úÖ "Recommendations" section clearly states "Future Work - NOT Completed"
- ‚úÖ Phase 2.5 completion percentage is accurate (fixed/total * 100)
- ‚úÖ CLAUDE.md ‚Üí README.md coverage is 100% (all directories with CLAUDE.md have READMEs)
- ‚úÖ Coverage section lists ALL created and existing READMEs
- ‚úÖ Phase 4c checkpoint PASSED
```

**Final Step: Command Execution Assessment**

APO MUST add this section at the end of the report:

```markdown
## Command Execution Assessment

### Hard Requirements Evaluation

1. **Phase Execution:** {executed}/9 phases {‚úÖ COMPLETE | ‚ùå INCOMPLETE}
2. **README Coverage:** {percentage}% ({count}/{total}) {‚úÖ 100% | ‚ùå < 100%}
3. **Phase 2.5 Fixes:** {percentage}% ({fixed}/{total}) {‚úÖ 100% | ‚ùå < 100%}
4. **Phase 4c Checkpoint:** {‚úÖ PASSED | ‚ùå FAILED}
5. **Phase 7a Validation:** {‚úÖ PASSED | ‚ùå FAILED | ‚è∏Ô∏è NOT EXECUTED}

### Overall Execution Status

**‚úÖ SUCCESS** - All 5 hard requirements met AND all soft requirements met:
- Phase Execution: 9/9 phases complete ‚úÖ
- README Coverage: 100% ({count}/{total}) ‚úÖ
- Phase 2.5 Fixes: 100% ({fixed}/{total}) ‚úÖ
- Phase 4c Checkpoint: PASSED ‚úÖ
- Phase 7a Validation: PASSED ‚úÖ
- docs/ Management: Complete ‚úÖ
- CHANGELOG Verified: Up-to-date ‚úÖ
- Documentation Consistency: Validated ‚úÖ

**‚ö†Ô∏è PARTIAL SUCCESS** - All 5 hard requirements met BUT some soft requirements incomplete:
- Hard Requirements: ALL PASSED (5/5) ‚úÖ
- Soft Requirements: PARTIALLY MET
- Gaps: {describe which soft requirements were not fully met}
- Impact: Core documentation complete, optional enhancements incomplete
- User Action: Can use current documentation; optionally re-run /trinity-docs for soft requirement completion

**‚ùå FAILED** - One or more hard requirements NOT met:
- Phase Execution: {executed}/9 ‚ùå (Phases {list skipped} not executed)
- README Coverage: {percentage}% ({count}/{total}) ‚ùå (Target: 100%)
- Phase 2.5 Fixes: {percentage}% ({fixed}/{total}) ‚ùå (Target: 100%)
- Phase 4c Checkpoint: FAILED ‚ùå
- Phase 7a Validation: NOT EXECUTED ‚ùå
- Root Cause: {describe specific violation}
- User Action: MUST re-run /trinity-docs in fresh session to complete work
```

---

## Example Workflow: Documentation Update After Audit

**User runs audit:**
```
/trinity-audit
```

**JUNO generates:** `trinity/reports/CODEBASE-AUDIT-2025-12-22.md`

**User requests documentation update:**
```
/trinity-docs @trinity/reports/CODEBASE-AUDIT-2025-12-22.md
```

**APO executes 9-phase workflow:**

1. **Phase 1: Discovery** - Uses Glob to find ALL CLAUDE.md files, identifies missing READMEs systematically
2. **Phase 2: Reality Audit** - Verifies feature counts, tests installation steps, checks links
3. **Phase 2.5: Fix Commitment** - Lists ALL inaccuracies found, commits to fixing them
4. **Phase 3: Content Analysis** - Assesses documentation quality (scores current state)
5. **Phase 4: README Management** - Updates root README.md + dynamically creates ALL subdirectory READMEs (applies Phase 2.5 fixes)
6. **Phase 5: docs/ Management** - Creates/updates guides, API docs, architecture docs
7. **Phase 6: CHANGELOG Management** - Generates comprehensive version comparison CHANGELOG entry
8. **Phase 7: Validation** - Verifies 100% CLAUDE.md coverage, all files exist, links work, versions match
9. **Phase 8: Best Practices** - Ensures consistency, accessibility, maintainability
10. **Phase 9: Audit Report** - Generates `trinity/reports/DOCUMENTATION-AUDIT-{date}.md` with coverage metrics

**Result:**
- ‚úÖ README.md updated with Phase 2.5 corrections (fixed 3 inaccuracies)
- ‚úÖ CHANGELOG.md created/updated with version comparison
- ‚úÖ CONTRIBUTING.md created
- ‚úÖ ALL subdirectory READMEs created (100% CLAUDE.md coverage - 10/10 directories)
- ‚úÖ docs/ structure created with guides
- ‚úÖ All links validated, all versions consistent
- ‚úÖ Documentation audit report generated with coverage metrics

**Key Principle:** APO performs ALL updates directly (never creates work orders, never defers work)

---

## Summary

**Use `/trinity-docs` when:**
- After running `/trinity-audit` to update docs based on findings
- Regular documentation maintenance and reviews
- Pre-release documentation preparation
- Improving open source project documentation

**APO will:**
- **Phase 1: Systematic discovery** using Glob to find ALL CLAUDE.md files
  - NO assumptions about directory structure
  - Build complete inventory of missing READMEs
  - 100% coverage guarantee
- **Phase 2: Audit codebase reality** to ensure documentation accuracy
  - Verify quantitative claims (feature counts, API endpoint counts, test counts)
  - Validate feature/functionality claims against actual code
  - Check installation instructions and prerequisites
  - Validate version claims and deprecation statements
  - Check all documentation links are valid
  - Cross-reference with JUNO audit if available
- **Phase 4: Dynamic README creation** for ALL directories with CLAUDE.md
  - Detect directory type (src/, database/, trinity/, tests/, nested modules)
  - Generate appropriate README template for each type
  - Extract real content from CLAUDE.md and filesystem
  - NO hardcoded paths or assumptions
- Update root README.md with accurate, verified project state
- Maintain docs/ directory structure
- Create/update CHANGELOG.md (root only)
- Create/update CONTRIBUTING.md (root only)
- Create/update LICENSE (root only)
- Create subdirectory READMEs (for CLAUDE.md directories)
- **Phase 7: Run systematic validation checks:**
  - **CLAUDE.md ‚Üí README.md coverage validation** (MUST be 100%)
  - API documentation validation (if project generates API docs)
  - Root file validation (README, CHANGELOG, CONTRIBUTING, LICENSE)
  - Documentation consistency (versions, APIs, links)
  - Coverage metrics (ensure all features are documented)
- Generate comprehensive documentation audit report with validation results

**Deliverable:**
- Updated documentation across project
- **Validated documentation** (all Phase 7 checks passed, reality-checked in Phase 2)
- Documentation audit report in `trinity/reports/DOCUMENTATION-AUDIT-{date}.md`
- Improved GitHub contribution tracking through better documentation

---

**Trinity Principle:** "Documentation is code that explains code. Keep it accurate, complete, and maintainable."
