# Trinity Documentation Update

**Command:** `/maintenance:trinity-docs-update`
**Purpose:** Update existing documentation to reflect codebase changes
**Architecture:** JUNO Audit → 3 Parallel APOs → JUNO Verification Loop (max 3 iterations until 100% alignment)
**Trinity Version:** 2.0.9
**Last Updated:** 2026-01-16

---

## Overview

This command updates existing documentation to achieve 100% alignment with codebase reality through an iterative verification loop system.

**Key Difference from `/maintenance:trinity-docs`:**
- `trinity-docs`: Generate NEW documentation from scratch
- `trinity-docs-update`: UPDATE EXISTING documentation to reflect changes

**How It Works:**
1. JUNO audits existing `docs/` AND codebase (ALL levels: architecture, module, function)
2. JUNO reports 3 categories of work needed
3. Up to 3 parallel APOs execute updates/creations
4. JUNO verifies 100% alignment
5. If not 100%, repeat steps 1-4 (max 3 iterations)
6. JUNO final report, move all reports to `trinity/sessions/`

---

## Critical Rules

### Rule 1: No Self-Serving Trinity Documentation

**NEVER document Trinity Method itself in this command's output.**

This command updates documentation about the USER'S codebase, not about Trinity Method.

**Examples of FORBIDDEN content:**
- Trinity Method agent descriptions
- Trinity Method workflow explanations
- Trinity Method work orders
- Trinity Method investigation processes
- Any content from `trinity/` directory

**If you find Trinity content in docs/:**
- IGNORE it (do not update or verify Trinity Method documentation)
- Focus only on repository-specific business logic and architecture

---

### Rule 2: Continuous Execution Protocol

**Stop ONLY for these 3 conditions:**
1. `docs/` directory does not exist → ABORT with instruction to run `/maintenance:trinity-docs` first
2. 3 iterations completed without achieving 100% alignment → ABORT with detailed report
3. 100% alignment achieved → SUCCESS, generate final report

**Continue execution regardless of:**
- Time constraints
- Token constraints
- Context window approaching limit

**Context Recovery Protocol:**
If interrupted mid-execution:
1. Read global state object from most recent report
2. Identify last completed phase and iteration number
3. Resume from next phase in sequence AUTOMATICALLY
4. Continue until one of the 3 stop conditions is met

**⚠️ RECOVERY IS AUTOMATIC - NO USER INTERACTION:**
- DO NOT ask user "Should I resume from where we left off?"
- DO NOT ask user "Which phase should I start from?"
- DO NOT wait for user confirmation to continue
- Read the global state and RESUME IMMEDIATELY
- User does not need to tell you to continue - you continue automatically

**DO NOT stop for:**
- User review (unless 100% alignment reached or max iterations hit)
- Approval gates during iterations
- Manual confirmation
- Any reason other than the 3 stop conditions

---

## Phase 0: Pre-Flight Check & State Initialization


**⚠️ AUTONOMOUS EXECUTION MODE:**
- Execute all Phase 0 steps automatically without user confirmation
- Only stop if docs/ directory does not exist (Stop Condition 1)
- If all checks pass, proceed directly to Phase 1
- DO NOT ask user for approval to continue

---
### Step 0.1: Verify docs/ Directory Exists

```bash
if [ ! -d "docs/" ]; then
  echo "❌ ABORT: docs/ directory not found"
  echo ""
  echo "This command updates EXISTING documentation."
  echo "To generate NEW documentation, run:"
  echo "  /maintenance:trinity-docs"
  exit 1
fi
```

**If docs/ does not exist:**
- **STOP IMMEDIATELY**
- Report to user that `/maintenance:trinity-docs` must be run first
- **DO NOT PROCEED** with any further steps

---

### Step 0.2: Initialize Global State Object

Create a global state tracking object for context recovery:

```typescript
interface GlobalState {
  command: "trinity-docs-update";
  startTime: string; // ISO timestamp
  currentIteration: number; // 1, 2, or 3
  maxIterations: 3;
  currentPhase: "audit" | "apo_execution" | "verification" | "complete" | "aborted";

  alignmentHistory: {
    iteration: number;
    alignmentPercentage: number;
    discrepanciesFound: number;
  }[];

  apoAssignments: {
    iteration: number;
    apo1Files: string[];
    apo2Components: string[];
    apo3Components: string[];
  }[];

  reportsGenerated: string[];

  stopCondition: null | "docs_missing" | "max_iterations" | "100_percent_aligned";
}
```

**Initialize state:**
```json
{
  "command": "trinity-docs-update",
  "startTime": "{{CURRENT_TIMESTAMP}}",
  "currentIteration": 1,
  "maxIterations": 3,
  "currentPhase": "audit",
  "alignmentHistory": [],
  "apoAssignments": [],
  "reportsGenerated": [],
  "stopCondition": null
}
```

**State Persistence:**
- Embed state snapshot in every report generated
- If interrupted, read state from most recent report's state snapshot
- Use state to resume from correct phase and iteration

---

## Phase 1: JUNO Comprehensive Audit

**Agent:** JUNO (Quality Auditor)
**Mode:** READ-ONLY (No changes made in this phase)
**Output:** Audit report in `trinity/reports/DOCS-UPDATE-AUDIT-iteration-{{ITERATION}}-{{DATE}}.md`


**⚠️ AUTONOMOUS EXECUTION - NO USER CONFIRMATION NEEDED:**
- JUNO audit executes automatically without user approval
- Proceed to Phase 2 immediately after audit report generation
- DO NOT stop to ask user to review audit results
- User can review reports later if desired

---
---

### Step 1.1: Scan Existing Documentation

**Scan `docs/` directory recursively:**

```bash
find docs/ -type f -name "*.md" | sort
```

**Catalog all documentation files:**
- Architecture documentation (e.g., `docs/architecture/`, `docs/system-design/`)
- API documentation (e.g., `docs/api/`, `docs/endpoints/`)
- Guides and tutorials (e.g., `docs/guides/`, `docs/tutorials/`)
- Configuration documentation (e.g., `docs/configuration/`, `docs/setup/`)
- Component documentation (e.g., `docs/components/`, `docs/modules/`)

**For each file, analyze:**
- **Content type:** Architecture, API, guide, tutorial, reference, configuration
- **Accuracy:** Does content match codebase reality?
- **Completeness:** Are there gaps or missing information?
- **Staleness:** Does it reference outdated code, APIs, or structures?

---

### Step 1.2: Scan Codebase for Business Logic

**ALL-LEVEL GRANULARITY REQUIRED:**
- **Architecture Level:** System design, project structure, major components
- **Module Level:** Services, controllers, models, utilities, middleware
- **Function Level:** Individual functions, methods, APIs, endpoints

**Business Logic Detection Patterns:**

**Directory Patterns (varies by framework):**
```
Common patterns across frameworks:
- controllers/, routes/, handlers/     (Request handling)
- services/, business/, domain/        (Business logic)
- models/, entities/, schemas/         (Data models)
- repositories/, data-access/, dao/    (Data layer)
- middleware/, interceptors/, guards/  (Request processing)
- utils/, helpers/, lib/               (Utilities)
- config/, configuration/              (Configuration)
```

**File Naming Patterns:**
```
*Controller.ts, *Controller.js
*Service.ts, *Service.js
*Repository.ts, *Repository.js
*Model.ts, *Model.js
*Helper.ts, *Helper.js
*Util.ts, *Util.js
*Middleware.ts, *Middleware.js
*Handler.ts, *Handler.js
*Provider.ts, *Provider.js
```

**Code Structure Markers:**
```typescript
// Classes (business logic)
export class UserService { ... }
export class PaymentProcessor { ... }

// Interfaces (data contracts)
export interface User { ... }
export interface PaymentRequest { ... }

// Enums (business constants)
export enum OrderStatus { ... }
export enum PaymentMethod { ... }

// Custom functions (business rules)
export function calculateTax(...) { ... }
export function validateOrder(...) { ... }
```

**Framework-Specific Patterns:**

**Express.js:**
```javascript
// Route handlers
app.get('/api/users', (req, res) => { ... })
router.post('/orders', orderController.create)

// Middleware
app.use(authMiddleware)
```

**NestJS:**
```typescript
@Controller('users')
@Injectable()
@Module({ ... })
```

**React/Next.js:**
```typescript
// Components
export function UserDashboard() { ... }

// Hooks
export function useAuth() { ... }

// API routes (Next.js)
export default function handler(req, res) { ... }
```

**Django:**
```python
# Views
class UserViewSet(viewsets.ModelViewSet):
    ...

# Models
class User(models.Model):
    ...
```

**Ruby on Rails:**
```ruby
# Controllers
class UsersController < ApplicationController
  ...
end

# Models
class User < ApplicationRecord
  ...
end
```

**What Makes Code "Business Logic":**
- **Unique to this repository:** Not generic framework boilerplate
- **Implements business rules:** Tax calculation, order validation, payment processing
- **Defines data models:** User schema, Order structure, Product catalog
- **Handles domain logic:** Authentication flow, authorization rules, workflow state machines

**Exclude:**
- Generic framework setup (config/webpack.config.js, etc.)
- Node modules and dependencies
- Build artifacts and dist/
- Test fixtures and mocks (unless they define API contracts)

---

### Step 1.3: Cross-Reference Documentation with Codebase

**For each documentation file, verify:**

**Architecture-Level Verification:**
- Does architecture diagram match actual directory structure?
- Are major components documented correctly?
- Are system boundaries accurate?
- Are data flows correct?

**Module-Level Verification:**
- Does API documentation match actual API routes/endpoints?
- Are service responsibilities accurately described?
- Are controller actions documented correctly?
- Are model schemas up-to-date?

**Function-Level Verification:**
- Do function signatures match documentation?
- Are parameters documented correctly?
- Are return types accurate?
- Are error cases covered?
- Are edge cases documented?

**Example Cross-Reference:**
```typescript
// CODE: src/services/payment.service.ts
export class PaymentService {
  async processPayment(
    orderId: string,
    amount: number,
    method: PaymentMethod
  ): Promise<PaymentResult> {
    // Implementation
  }
}

// DOCS: docs/api/payment.md
Should document:
✅ Function name: processPayment
✅ Parameters: orderId (string), amount (number), method (PaymentMethod)
✅ Return type: Promise<PaymentResult>
✅ Behavior: Processes payment for given order
✅ Error cases: InvalidAmount, PaymentDeclined, NetworkError

If docs say processPayment takes (userId, amount) → DISCREPANCY (wrong parameter)
If docs don't mention error cases → INCOMPLETENESS (missing info)
If docs reference deprecated processCreditCard method → STALENESS (outdated)
```

---

### Step 1.4: Generate 3-Part Audit Report

**Use template:** `trinity/templates/documentation/reports/docs-update-audit.md`

**Part 1: Base Documentation Updates Needed**

List all documentation files requiring updates:
- **File:** `docs/architecture/system-design.md`
  - **Current State:** References old monolith architecture
  - **Required Update:** Update to reflect microservices migration
  - **Reason:** Codebase now has services/users, services/orders, services/payments
  - **Priority:** HIGH

**Part 2: Existing Business Logic Requiring Updates**

List all business logic components with existing docs that need updates:
- **Component:** UserService (`src/services/user.service.ts`)
  - **Current Documentation:** `docs/api/user-service.md`
  - **Issues:** Missing new `suspendUser()` method, incorrect parameter for `updateUser()`
  - **Required Updates:** Add suspendUser docs, fix updateUser signature
  - **Dependency Analysis:**
    - Tied systems: AuthService, EmailService, AuditLogService
    - Routing: APO-2 (update existing docs - tightly coupled)
  - **Priority:** HIGH

**Part 3: Missing Business Logic Requiring New Documentation**

List all business logic components without documentation:
- **Component:** NotificationService (`src/services/notification.service.ts`)
  - **Why Undocumented:** New feature added in recent sprint
  - **Uniqueness:** Implements multi-channel notifications (email, SMS, push) with templating
  - **Modularity Analysis:**
    - Independent: Can be used standalone
    - No tight coupling: Uses dependency injection
    - Routing: APO-3 (create new docs - modular component)
  - **Priority:** MEDIUM

---

### Step 1.5: APO Work Assignment

**Assign work to 3 parallel APOs:**

**APO-1: Base Documentation Updates**
- Architecture docs
- Setup/configuration docs
- Guides and tutorials
- General repository documentation

**APO-2: Update Existing Business Logic Documentation**
- Components with DIRECT TIES to other systems
- Decision logic: "Is this component directly tied to X system?"
  - YES → APO-2 updates existing documentation
  - NO → Check if modular (APO-3)

**Example (APO-2):**
```
Q: Is RefundService directly tied to PaymentService?
A: YES - refunds can only happen after payments
→ APO-2 updates existing docs/api/refund-service.md

Q: Is AuthMiddleware directly tied to UserService?
A: YES - authentication requires user validation
→ APO-2 updates existing docs/middleware/auth.md
```

**APO-3: Create New Business Logic Documentation**
- Components that are MODULAR and INDEPENDENT
- Decision logic: "Is this component modular and reusable?"
  - YES → APO-3 creates new documentation
  - NO → Check if tied (APO-2)

**Example (APO-3):**
```
Q: Is CacheHelper modular?
A: YES - can be used independently, no tight coupling
→ APO-3 creates new docs/utilities/cache-helper.md

Q: Is RateLimiter modular?
A: YES - middleware that works independently
→ APO-3 creates new docs/middleware/rate-limiter.md
```

---

### Step 1.6: Zero-Tolerance Policy Check

**ABORT immediately if any of these are found:**

1. **Fake Components in Documentation**
   - Documentation references components that don't exist in codebase
   - Action: ABORT with list of fake components

2. **Security Violations in Documentation**
   - Documentation exposes secrets, API keys, passwords
   - Documentation contains insecure code examples
   - Action: ABORT with security violation details

3. **Stub Content in Documentation**
   - Documentation has "TODO", "Coming soon", "To be implemented"
   - Placeholder sections without real content
   - Action: ABORT with list of stub sections

**If any zero-tolerance violation found:**
```
❌ ABORT: Zero-Tolerance Policy Violation

Violation Type: Fake Components
Details:
- docs/api/blockchain-service.md documents BlockchainService
- BlockchainService does not exist in codebase
- Located at: docs/api/blockchain-service.md:15-45

Action Required:
1. Remove fake documentation or
2. Implement the component
3. Re-run trinity-docs-update

Aborting documentation update.
```

---

### Step 1.7: Save Audit Report

**Generate report:**
- File: `trinity/reports/DOCS-UPDATE-AUDIT-iteration-{{ITERATION}}-{{DATE}}.md`
- Template: `trinity/templates/documentation/reports/docs-update-audit.md`

**Update global state:**
```json
{
  "currentPhase": "apo_execution",
  "apoAssignments": [{
    "iteration": 1,
    "apo1Files": ["docs/architecture/system-design.md", ...],
    "apo2Components": ["UserService", "PaymentService", ...],
    "apo3Components": ["NotificationService", "CacheHelper", ...]
  }],
  "reportsGenerated": ["DOCS-UPDATE-AUDIT-iteration-1-2026-01-16.md"]
}
```

---

### Step 1.7A: Validate APO Assignment Specificity

**CRITICAL: Validate assignments have specific details BEFORE APOs begin work.**

This step prevents vague assignments like "FrontendComponents" that led to production failures.

---

#### Step 1.7A.1: Review All APO Assignments

**For each item in Parts 1, 2, and 3 of the audit report, verify specificity:**

---

**Part 1: APO-1 Base Documentation Updates**

Each assignment MUST include:
- ✅ **Full file path:** `docs/architecture/system-design.md` (NOT "system design docs")
- ✅ **Current state description:** What's wrong with current docs
- ✅ **Required update description:** What needs to be changed
- ✅ **Priority level:** HIGH, MEDIUM, or LOW

**Invalid Example:**
```markdown
- **Assignment:** Update architecture docs
  ❌ VAGUE - Which architecture docs? What needs updating?
```

**Valid Example:**
```markdown
- **File:** docs/architecture/system-design.md
  - **Current State:** References old monolith architecture
  - **Required Update:** Update to reflect microservices migration
  - **Reason:** Codebase now has services/users, services/orders, services/payments
  - **Priority:** HIGH
  ✅ SPECIFIC - Clear file, clear issue, clear fix
```

---

**Part 2: APO-2 Existing Business Logic Updates**

Each assignment MUST include:
- ✅ **Component name:** "UserService" (NOT "User-related services")
- ✅ **Source file path:** `src/services/user.service.ts`
- ✅ **Target doc path:** `docs/api/user-service.md`
- ✅ **Specific issues:** What methods are missing/incorrect
- ✅ **Dependency ties:** What other systems it connects to

**Invalid Example (Production Failure):**
```markdown
- **Assignment:** FrontendComponents
  - **Location:** frontend/
  - **Target docs:** docs/frontend/
  ❌ VAGUE - Which components? How many? What are their names?

This vague assignment led APO-2 to skip 8 frontend components:
- DealerFilter, EquipmentCard, ComparisonModal, DealershipList,
  EquipmentList, SearchBar, FilterPanel, PriceDisplay
```

**Valid Example:**
```markdown
- **Component:** UserService
  - **Source:** src/services/user.service.ts
  - **Target Doc:** docs/api/user-service.md
  - **Issues:** Missing suspendUser() method, incorrect updateUser() signature
  - **Required Updates:** Add suspendUser docs, fix updateUser signature
  - **Dependencies:** AuthService, EmailService, AuditLogService
  - **Priority:** HIGH
  ✅ SPECIFIC - Clear component, clear source/target, clear issues
```

---

**Part 3: APO-3 Missing Business Logic (New Docs)**

Each assignment MUST include:
- ✅ **Component name:** "NotificationService"
- ✅ **Source file path:** `src/services/notification.service.ts`
- ✅ **Target doc path:** `docs/services/notification-service.md` (proposed location)
- ✅ **Why undocumented:** Reason it's missing docs
- ✅ **Uniqueness analysis:** What makes it documentation-worthy
- ✅ **Modularity analysis:** Why APO-3 vs APO-2

**Invalid Example:**
```markdown
- **Assignment:** Utility functions
  - **Location:** src/utils/
  ❌ VAGUE - Which utilities? How many? What are their names?
```

**Valid Example:**
```markdown
- **Component:** NotificationService
  - **Source:** src/services/notification.service.ts
  - **Target Doc:** docs/services/notification-service.md
  - **Why Undocumented:** New feature added in recent sprint
  - **Uniqueness:** Implements multi-channel notifications (email, SMS, push) with templating
  - **Modularity:** Independent, uses dependency injection, no tight coupling
  - **Priority:** MEDIUM
  ✅ SPECIFIC - Clear component, clear paths, clear rationale
```

---

#### Step 1.7A.2: Count Total Assignments

**Document exact counts for JUNO verification (Step 3.1A):**

```json
{
  "assignmentCounts": {
    "apo1": {
      "count": 12,
      "files": [
        "docs/architecture/system-design.md",
        "docs/setup/installation.md",
        // ... all 12 files listed explicitly
      ]
    },
    "apo2": {
      "count": 33,
      "components": [
        "UserService (src/services/user.service.ts → docs/api/user-service.md)",
        "PaymentService (src/services/payment.service.ts → docs/api/payment-service.md)",
        // ... all 33 components listed explicitly with source/target paths
        "DealerFilter (frontend/components/DealerFilter.tsx → docs/frontend/dealer-filter.md)",
        "EquipmentCard (frontend/components/EquipmentCard.tsx → docs/frontend/equipment-card.md)",
        // ... all frontend components EXPLICITLY LISTED (not vague "FrontendComponents")
      ]
    },
    "apo3": {
      "count": 8,
      "components": [
        "NotificationService (src/services/notification.service.ts → docs/services/notification-service.md)",
        "CacheHelper (src/utils/cache.helper.ts → docs/utilities/cache-helper.md)",
        // ... all 8 components listed explicitly with source/target paths
      ]
    },
    "total": 53
  }
}
```

---

#### Step 1.7A.3: Validation Check

**IF any assignment lacks specificity:**
- ❌ **ABORT** with validation failure report
- List all vague assignments
- Explain why each is insufficient
- **Do NOT proceed to Phase 2**
- Orchestrator must revise assignments with specific details

**Example Validation Failure:**
```
❌ ABORT: Vague Assignment Detected

Assignment: APO-2 - "FrontendComponents"
Issues:
1. No specific component names provided
2. No source file paths
3. No target documentation paths
4. Count is unclear (how many components?)

Required Fix:
List each frontend component explicitly:
- Component name: DealerFilter
- Source: frontend/components/DealerFilter.tsx
- Target: docs/frontend/dealer-filter.md

Repeat for EACH component (DealerFilter, EquipmentCard, ComparisonModal, etc.)

Vague assignments lead to skipped work and false success reports.
Specificity is mandatory.
```

---

#### Step 1.7A.4: If Validation Passes

**IF all assignments are specific:**
- ✅ Validation PASS
- Record assignment details in audit report
- Proceed to Phase 2 (APO Execution)
- APOs will have clear, unambiguous assignments

---

**Why This Step Is Critical:**

In production failure:
- JUNO assigned "FrontendComponents" to APO-2 (vague)
- APO-2 interpreted this as "optional" or "future scope"
- APO-2 skipped 8 frontend components
- No specific list to cross-check against
- Result: 8 components never documented

With Step 1.7A:
- JUNO MUST list all 8 components explicitly
- APO-2 knows exactly what to document (no ambiguity)
- JUNO Step 3.1A cross-checks against explicit list
- Impossible to skip without detection

**Proceed to Phase 2.**

---

## Phase 2: Parallel APO Execution

**3 APO agents execute in parallel** (if possible in implementation)

Each APO generates a completion report upon finishing their assigned work.


**⚠️ AUTONOMOUS EXECUTION - EXECUTE ALL APOs AUTOMATICALLY:**
- Launch all 3 APO agents without user confirmation
- APOs execute assigned work automatically
- Proceed to Phase 3 immediately after all APO completion reports generated
- DO NOT stop to ask user to review APO work during execution
- DO NOT ask user whether to continue after APO completion

---
---

### APO-1: Base Documentation Updates

**Agent:** APO-1 (Documentation Specialist)
**Assignment:** Update architecture, setup, configuration, and guide documentation
**Mode:** UPDATE existing files
**Output:** `trinity/reports/APO-1-BASE-UPDATE-COMPLETE-iteration-{{ITERATION}}-{{DATE}}.md`

---

## ⚠️ CRITICAL REQUIREMENTS FOR APO-1 ⚠️

**YOU MUST DOCUMENT 100% OF ASSIGNED FILES.**

**This is not a suggestion. This is a hard requirement.**

### Mandatory Self-Audit Before Completion Report

Before generating your completion report, you MUST perform this self-audit:

1. **Count Assigned Items:**
   - Read audit report: `DOCS-UPDATE-AUDIT-iteration-{{ITERATION}}-{{DATE}}.md`
   - Extract "Part 1: Base Documentation Updates Needed"
   - Count total files assigned to you: `assignedCount`

2. **Count Completed Items:**
   - Review your work during this iteration
   - Count files you actually updated/created: `completedCount`

3. **Verify 100% Completion:**
   ```typescript
   if (completedCount !== assignedCount) {
     // ABORT - DO NOT GENERATE COMPLETION REPORT
     // Instead, generate INCOMPLETE WORK REPORT
     throw new Error(
       `APO-1 INCOMPLETE: Assigned ${assignedCount}, completed ${completedCount}` +
       `Missing ${assignedCount - completedCount} files`
     );
   }
   ```

4. **If Incomplete Work Detected:**
   - **DO NOT** rationalize skipping as "future scope"
   - **DO NOT** rationalize skipping as "lower priority"
   - **DO NOT** rationalize skipping as "not critical"
   - **DO NOT** generate completion report claiming success
   - **INSTEAD:** Generate incomplete report listing missing items
   - **THEN:** Continue working until 100% complete

**Partial completion = FAILURE, not success.**

**If you skip assigned work, JUNO will detect it in Step 3.1A and create HIGH severity discrepancies.**

---

#### APO-1 Step 1: Read Assignment from JUNO Audit

Read the audit report's "Part 1: Base Documentation Updates Needed" section.

Extract list of files assigned to APO-1:
- File paths
- Current state descriptions
- Required updates
- Priorities

---

#### APO-1 Step 2: Update Each Assigned File

**For each file in assignment:**

1. **Read current documentation**
   - Use Read tool to read entire file
   - Understand current structure and content

2. **Read referenced codebase sections**
   - If docs reference `src/config/database.ts`, read that file
   - If docs reference architecture, scan relevant directories
   - Verify claims against actual code

3. **Identify specific changes needed**
   - What is inaccurate?
   - What is missing?
   - What is outdated?

4. **Apply updates using Edit tool**
   - Fix inaccuracies
   - Add missing information
   - Update outdated references
   - Preserve correct manual edits (validate truth, keep if accurate)

5. **Verify changes**
   - Re-read updated file
   - Cross-reference with codebase
   - Ensure accuracy

---

#### APO-1 Step 3: Validate Against Codebase

**For every claim in updated documentation, verify:**

```typescript
Documentation claims: "The API uses JWT tokens with 24-hour expiration"

Verification:
1. Search codebase for JWT configuration
2. Find: src/config/auth.ts
3. Read: JWT_EXPIRATION = '24h' ✅
4. Validation: ACCURATE
```

**If documentation claim cannot be verified:**
- Mark as UNVERIFIED in completion report
- Flag for review

---

#### APO-1 Step 4: Web Search for Framework Standards (if applicable)

**If updating framework-specific documentation:**

Use WebSearch tool to find official standards:

**Example: NestJS project**
```
WebSearch: "NestJS official documentation structure 2025"
→ Find official NestJS docs standards
→ Apply consistent formatting
→ Use official terminology
```

**Example: React project**
```
WebSearch: "React hooks documentation best practices 2025"
→ Find React docs conventions
→ Apply consistent example patterns
```

**Frameworks to search for:**
- Express, NestJS, Fastify (Node.js)
- React, Vue, Angular, Svelte (Frontend)
- Django, Flask, FastAPI (Python)
- Ruby on Rails (Ruby)
- Spring Boot (Java)
- Laravel (PHP)

---

#### APO-1 Step 5: Generate Completion Report

**Use template:** `trinity/templates/documentation/reports/apo-base-update-completion.md`

**Report includes:**
- All files updated
- Changes made (before/after)
- Codebase cross-references validated
- Issues encountered
- Quality metrics
- Files modified list

**Save to:** `trinity/reports/APO-1-BASE-UPDATE-COMPLETE-iteration-{{ITERATION}}-{{DATE}}.md`

---

### APO-2: Update Existing Business Logic Documentation

**Agent:** APO-2 (Documentation Specialist)
**Assignment:** Update documentation for existing business logic with dependency ties
**Mode:** UPDATE existing files
**Output:** `trinity/reports/APO-2-BUSINESS-UPDATE-COMPLETE-iteration-{{ITERATION}}-{{DATE}}.md`

---

## ⚠️ CRITICAL REQUIREMENTS FOR APO-2 ⚠️

**YOU MUST DOCUMENT 100% OF ASSIGNED COMPONENTS.**

**This is not a suggestion. This is a hard requirement.**

### Mandatory Self-Audit Before Completion Report

Before generating your completion report, you MUST perform this self-audit:

1. **Count Assigned Items:**
   - Read audit report: `DOCS-UPDATE-AUDIT-iteration-{{ITERATION}}-{{DATE}}.md`
   - Extract "Part 2: Existing Business Logic Requiring Updates"
   - Count total components assigned to you: `assignedCount`
   - **IMPORTANT:** If audit says 33 components, you MUST document all 33

2. **Count Completed Items:**
   - Review your work during this iteration
   - Count components you actually documented: `completedCount`
   - **DO NOT COUNT** components you rationalized as "future scope"
   - **DO NOT COUNT** components you skipped for any reason

3. **Verify 100% Completion:**
   ```typescript
   if (completedCount !== assignedCount) {
     // ABORT - DO NOT GENERATE COMPLETION REPORT
     // Instead, generate INCOMPLETE WORK REPORT
     throw new Error(
       `APO-2 INCOMPLETE: Assigned ${assignedCount}, completed ${completedCount}` +
       `Missing ${assignedCount - completedCount} components: ${missingComponents.join(', ')}`
     );
   }
   ```

4. **If Incomplete Work Detected:**
   - **DO NOT** rationalize frontend components as "outside scope"
   - **DO NOT** rationalize any components as "lower priority"
   - **DO NOT** claim 100% success when you only completed 25/33 components
   - **DO NOT** generate completion report claiming success
   - **INSTEAD:** Generate incomplete report listing ALL missing components
   - **THEN:** Continue working until 100% complete

**Real Production Failure:**
- APO-2 was assigned 33 components
- APO-2 documented 25 components (75.76%)
- APO-2 rationalized 8 frontend components as "future scope"
- APO-2 reported 100% success
- JUNO did not detect incomplete work (before Step 3.1A was added)
- Result: False 100% success report

**This will NOT happen again. Partial completion = FAILURE, not success.**

**If you skip assigned work, JUNO will detect it in Step 3.1A and create HIGH severity discrepancies.**

---

#### APO-2 Step 1: Read Assignment from JUNO Audit

Read the audit report's "Part 2: Existing Business Logic Requiring Updates" section.

Extract list of components assigned to APO-2:
- Component names and locations
- Current documentation files
- Required updates
- Dependency ties (why APO-2 vs APO-3)
- Priorities

---

#### APO-2 Step 2: Dependency Analysis

**For each assigned component, understand its ties:**

**Example: RefundService**
```
Component: RefundService (src/services/refund.service.ts)
Documentation: docs/api/refund-service.md

Dependency Analysis:
1. Read RefundService code
2. Identify imports:
   - import { PaymentService } from './payment.service'
   - import { OrderService } from './order.service'
   - import { EmailService } from '../notifications/email.service'

3. Identify method calls:
   - paymentService.getPaymentById(paymentId)
   - orderService.updateOrderStatus(orderId, 'refunded')
   - emailService.sendRefundConfirmation(userId, amount)

4. Conclusion: RefundService is DIRECTLY TIED to:
   - PaymentService (can't refund without payment)
   - OrderService (must update order status)
   - EmailService (must notify user)

5. Routing Decision: APO-2 (update existing docs)
   - Rationale: Tightly coupled system, update existing unified documentation
```

---

#### APO-2 Step 3: Update Each Assigned Component's Documentation

**For each component:**

1. **Read current documentation**
   - Use Read tool on docs file (e.g., `docs/api/refund-service.md`)
   - **If file does NOT exist:** Note that file must be CREATED (not updated)

2. **Read component source code**
   - Use Read tool on source file (e.g., `src/services/refund.service.ts`)
   - Understand all public methods
   - Note all dependencies
   - Identify business rules

3. **Identify discrepancies**
   - Missing methods in docs
   - Incorrect signatures
   - Outdated behavior descriptions
   - Missing error cases
   - Missing dependencies

4. **Create or Update Documentation File**

   **⚠️ CRITICAL: Physical file creation/modification is MANDATORY**

   **IF file exists** (existing documentation):
   ```typescript
   // Use Edit tool to update existing file
   const current_content = await read_file(target_doc)
   const updated_content = apply_updates(current_content)
   await edit_file(target_doc, old_string, new_string)

   // VERIFY edit succeeded
   const verify_content = await read_file(target_doc)
   if (!verify_content.includes(expected_changes)) {
     throw Error(`Edit failed for ${target_doc}`)
   }
   ```

   **IF file does NOT exist** (new documentation):
   ```typescript
   // Use Write tool to CREATE new file
   const doc_content = generate_documentation(component)
   await write_file(target_doc, doc_content)

   // VERIFY file was created
   const verify_content = await read_file(target_doc)
   if (!verify_content || verify_content.length < 100) {
     throw Error(`Write failed for ${target_doc} - file not created or empty`)
   }
   ```

   **DO NOT ACCEPT:**
   - "Documented component in completion report" ❌
   - "Created documentation plan for component" ❌
   - "Described documentation structure" ❌

   **ONLY ACCEPT:**
   - "Created file at docs/path/file.md using Write tool" ✅
   - "Updated file at docs/path/file.md using Edit tool" ✅
   - "Verified file exists with Read tool" ✅

5. **Update cross-references**
   - If RefundService docs updated, check if PaymentService docs need cross-reference update
   - Add links between related component documentation

---

#### APO-2 Step 4: Validate Against Codebase

**Function-level validation:**

```typescript
// CODE: src/services/refund.service.ts
class RefundService {
  async processRefund(
    paymentId: string,
    amount: number,
    reason: RefundReason
  ): Promise<RefundResult> {
    // Implementation
  }
}

// DOCUMENTATION SHOULD HAVE:
✅ Method name: processRefund
✅ Parameters: paymentId (string), amount (number), reason (RefundReason enum)
✅ Return type: Promise<RefundResult>
✅ Behavior: Processes refund for given payment
✅ Dependencies: Requires PaymentService.getPaymentById()
✅ Error cases: PaymentNotFound, RefundAmountExceedsPayment, PaymentAlreadyRefunded
✅ Business rules: Refunds can only be issued within 30 days of payment
```

**If documentation is missing any of these, UPDATE IT.**

---

#### APO-2 Step 5: Web Search for Framework Standards

Same as APO-1 - search for framework-specific documentation standards if needed.

---

#### APO-2 Step 5A: Physical File Verification Gate (MANDATORY)

**⚠️ THIS IS A BLOCKING GATE - CANNOT PROCEED WITHOUT 100% FILE VERIFICATION**

**Before generating completion report, verify EVERY assigned component's documentation file physically exists:**

1. **Extract assignment list**
   ```typescript
   // From audit report Part 2
   const assigned_components = [
     { name: "UserService", target_doc: "docs/api/user-service.md" },
     { name: "PaymentService", target_doc: "docs/api/payment-service.md" },
     // ... all assigned components
   ]
   const assignedCount = assigned_components.length
   ```

2. **Verify each target documentation file exists**
   ```typescript
   let verified = 0
   let missing = []

   for (const component of assigned_components) {
     const file_exists = await check_file_exists(component.target_doc)

     if (file_exists) {
       const file_size = await get_file_size(component.target_doc)

       if (file_size > 100) {
         console.log(`✅ ${component.name} → ${component.target_doc} (${file_size} bytes)`)
         verified++
       } else {
         console.log(`⚠️ ${component.name} → ${component.target_doc} (${file_size} bytes) [STUB/EMPTY]`)
         missing.push({...component, reason: "stub"})
       }
     } else {
       console.log(`❌ ${component.name} → ${component.target_doc} [MISSING]`)
       missing.push({...component, reason: "missing"})
     }
   }
   ```

3. **Verify 100% completion**
   ```typescript
   console.log(`\nVerification Results:`)
   console.log(`Assigned: ${assignedCount}`)
   console.log(`Verified: ${verified}`)
   console.log(`Missing/Stub: ${missing.length}`)

   if (verified !== assignedCount) {
     console.log(`\n❌ GATE FAILURE: Physical file verification failed`)
     console.log(`Cannot generate completion report`)
     console.log(`\nMissing/Stub files:`)
     for (const item of missing) {
       console.log(`  - ${item.name} → ${item.target_doc} [${item.reason.toUpperCase()}]`)
     }
     console.log(`\nREQUIRED ACTION:`)
     if (missing.some(m => m.reason === "missing")) {
       console.log(`  1. Use Write tool to create missing files`)
     }
     if (missing.some(m => m.reason === "stub")) {
       console.log(`  2. Fill stub files with complete documentation (>100 bytes)`)
     }
     console.log(`  3. Use Read tool to verify each file`)
     console.log(`  4. Re-run this verification`)

     throw new Error(`APO-2 Gate Failure: ${missing.length} files not verified`)
   }

   console.log(`\n✅ GATE PASS: All ${assignedCount} documentation files verified`)
   ```

4. **Only if gate passes, proceed to completion report**
   - Gate ensures 100% physical file creation
   - Prevents false completion reports
   - Forces APO to create all assigned files

---

#### APO-2 Step 6: Generate Completion Report

**Use template:** `trinity/templates/documentation/reports/apo-business-update-completion.md`

**Report includes:**
- All components updated
- Documentation files modified
- Changes made (before/after)
- Dependency ties validated
- Codebase cross-references
- Routing decisions explained
- Issues encountered
- Quality metrics

**Save to:** `trinity/reports/APO-2-BUSINESS-UPDATE-COMPLETE-iteration-{{ITERATION}}-{{DATE}}.md`

---

### APO-3: Create New Business Logic Documentation

**Agent:** APO-3 (Documentation Specialist)
**Assignment:** Create NEW documentation for modular business logic components
**Mode:** CREATE new files
**Output:** `trinity/reports/APO-3-BUSINESS-CREATE-COMPLETE-iteration-{{ITERATION}}-{{DATE}}.md`

---

## ⚠️ CRITICAL REQUIREMENTS FOR APO-3 ⚠️

**YOU MUST DOCUMENT 100% OF ASSIGNED COMPONENTS.**

**This is not a suggestion. This is a hard requirement.**

### Mandatory Self-Audit Before Completion Report

Before generating your completion report, you MUST perform this self-audit:

1. **Count Assigned Items:**
   - Read audit report: `DOCS-UPDATE-AUDIT-iteration-{{ITERATION}}-{{DATE}}.md`
   - Extract "Part 3: Missing Business Logic Requiring New Documentation"
   - Count total components assigned to you: `assignedCount`

2. **Count Completed Items:**
   - Review your work during this iteration
   - Count NEW documentation files you actually created: `completedCount`
   - Verify each file exists and has complete content

3. **Verify 100% Completion:**
   ```typescript
   if (completedCount !== assignedCount) {
     // ABORT - DO NOT GENERATE COMPLETION REPORT
     // Instead, generate INCOMPLETE WORK REPORT
     throw new Error(
       `APO-3 INCOMPLETE: Assigned ${assignedCount}, completed ${completedCount}` +
       `Missing ${assignedCount - completedCount} components`
     );
   }
   ```

4. **If Incomplete Work Detected:**
   - **DO NOT** rationalize skipping as "future scope"
   - **DO NOT** rationalize skipping as "optional documentation"
   - **DO NOT** rationalize skipping as "low priority"
   - **DO NOT** generate completion report claiming success
   - **INSTEAD:** Generate incomplete report listing missing items
   - **THEN:** Continue working until 100% complete

**Partial completion = FAILURE, not success.**

**If you skip assigned work, JUNO will detect it in Step 3.1A and create HIGH severity discrepancies.**

---

#### APO-3 Step 1: Read Assignment from JUNO Audit

Read the audit report's "Part 3: Missing Business Logic Requiring New Documentation" section.

Extract list of components assigned to APO-3:
- Component names and locations
- Why undocumented
- Uniqueness to repository
- Modularity analysis (why APO-3 vs APO-2)
- Priorities

---

#### APO-3 Step 2: Modularity Analysis

**For each assigned component, validate modularity:**

**Example: CacheHelper**
```
Component: CacheHelper (src/utils/cache.helper.ts)
No existing documentation

Modularity Analysis:
1. Read CacheHelper code
2. Check for tight coupling:
   - Uses dependency injection? YES (Redis client injected)
   - Hardcoded dependencies? NO
   - Can work standalone? YES

3. Check reusability:
   - Generic interface? YES (set, get, delete, clear)
   - Business-specific logic? NO (pure caching utility)
   - Testable in isolation? YES

4. Conclusion: CacheHelper is MODULAR
   - Loosely coupled
   - Single responsibility (caching)
   - Reusable across different contexts

5. Routing Decision: APO-3 (create new docs)
   - Rationale: Independent module, deserves standalone documentation
```

---

#### APO-3 Step 3: Create Documentation for Each Component

**For each component, create NEW documentation file using Write tool:**

**⚠️ CRITICAL: You MUST physically CREATE files, not describe them**

**Step-by-Step File Creation:**

1. **Read component source code**
   ```typescript
   const source_file = component.source_file_path
   const source_code = await read_file(source_file)
   ```

2. **Analyze and extract information**
   - Purpose and overview
   - Public methods and their signatures
   - Parameters with types
   - Return values with types
   - Dependencies and integrations
   - Usage examples from actual code

3. **Determine documentation location:**
   ```
   Component: CacheHelper (src/utils/cache.helper.ts)
   Documentation: docs/utilities/cache-helper.md

   Component: RateLimiter (src/middleware/rate-limiter.ts)
   Documentation: docs/middleware/rate-limiter.md

   Component: ValidationPipe (src/pipes/validation.pipe.ts)
   Documentation: docs/pipes/validation-pipe.md
   ```

4. **Generate documentation content**

**Documentation structure (use existing docs/ structure as reference):**

```markdown
# [Component Name]

## Overview
Brief description of what this component does.

## Purpose
Why this component exists. What problem does it solve?

## Usage

### Installation/Setup
How to integrate this component.

### Basic Example
```typescript
// Code example showing basic usage
```

### Advanced Example
```typescript
// Code example showing advanced usage
```

## API Reference

### Methods

#### method1(param1, param2)
Description of method.

**Parameters:**
- `param1` (type): Description
- `param2` (type): Description

**Returns:** `ReturnType` - Description

**Throws:**
- `ErrorType1`: When X happens
- `ErrorType2`: When Y happens

**Example:**
```typescript
// Usage example
```

### Properties

#### property1
Description of property.

**Type:** `PropertyType`
**Default:** `defaultValue`

## Configuration
Any configuration options.

## Error Handling
Common errors and how to handle them.

## Testing
How to test code that uses this component.

## Related Components
Links to related documentation.
```

5. **CREATE physical file using Write tool**
   ```typescript
   const target_doc = component.target_documentation_path

   // WRITE THE FILE
   await write_file(target_doc, doc_content)

   console.log(`✅ Created ${target_doc}`)
   ```

6. **VERIFY file was created**
   ```typescript
   // Use Read tool to verify
   const verify_content = await read_file(target_doc)

   // Check file exists and has content
   if (!verify_content) {
     throw Error(`CRITICAL: File ${target_doc} was not created`)
   }

   if (verify_content.length < 100) {
     throw Error(`CRITICAL: File ${target_doc} is too short (stub/empty)`)
   }

   if (verify_content !== doc_content) {
     throw Error(`CRITICAL: File ${target_doc} content mismatch`)
   }

   console.log(`✅ Verified ${target_doc} (${verify_content.length} bytes)`)
   ```

7. **Only if verification passes, mark as complete**
   ```typescript
   completed_files.push(target_doc)
   ```

**Example Complete Workflow:**
```markdown
Processing: BaseDealerScraper
Source: backend/src/scrapers/BaseDealerScraper.js
Target: docs/scrapers/base-dealer-scraper.md

Step 1: Reading source...
  ✅ Read 465 lines from BaseDealerScraper.js

Step 2: Analyzing...
  ✅ Found 8 methods: initialize(), scrape(), extractEquipmentData(), ...
  ✅ Found dependencies: Playwright, Equipment model, logger

Step 3: Generating documentation (18,432 characters)...
  ✅ Documentation content generated

Step 5: Creating file...
  [Using Write tool]
  ✅ File created: docs/scrapers/base-dealer-scraper.md

Step 6: Verifying...
  [Using Read tool]
  ✅ File exists: docs/scrapers/base-dealer-scraper.md
  ✅ File size: 18,432 bytes
  ✅ Content matches generated documentation

RESULT: ✅ docs/scrapers/base-dealer-scraper.md successfully created
```

**DO NOT ACCEPT:**
```markdown
❌ "Documented BaseDealerScraper in completion report"
❌ "Created documentation plan for BaseDealerScraper"
❌ "BaseDealerScraper documentation described in APO-3 report"
```

**ONLY ACCEPT:**
```markdown
✅ "Created docs/scrapers/base-dealer-scraper.md using Write tool"
✅ "Verified file exists with 18,432 bytes using Read tool"
✅ "File creation confirmed"
```

---

#### APO-3 Step 4: Validate Documentation Against Code

**For each component documented:**

1. **Read source code completely**
   - Use Read tool on component file
   - Verify every public method is documented
   - Verify every public property is documented

2. **Test code examples**
   - If possible, validate that code examples are syntactically correct
   - Verify that examples match actual API

3. **Cross-reference dependencies**
   - If component imports other modules, mention them
   - Link to related documentation if it exists

---

#### APO-3 Step 5: Integration with Existing Documentation

**Update existing documentation to reference new docs:**

1. **Update index/table of contents**
   - If docs have a README or index, add new documentation to list
   - Example: Update `docs/README.md` to include link to new `docs/utilities/cache-helper.md`

2. **Update related documentation**
   - If creating docs for CacheHelper, and UserService uses CacheHelper, add cross-reference in UserService docs
   - Example: Add to `docs/api/user-service.md`:
     ```markdown
     ## Caching
     This service uses [CacheHelper](../utilities/cache-helper.md) for caching user data.
     ```

3. **Update architecture docs if needed**
   - If new component adds to architecture, update architecture diagrams/docs

---

#### APO-3 Step 6: Web Search for Framework Standards

Same as APO-1 and APO-2 - search for framework-specific documentation standards.

---

#### APO-3 Step 6A: Physical File Verification Gate (MANDATORY)

**⚠️ THIS IS A BLOCKING GATE - CANNOT PROCEED WITHOUT 100% FILE VERIFICATION**

**Before generating completion report, verify EVERY assigned component's documentation file physically exists:**

1. **Extract assignment list**
   ```typescript
   // From audit report Part 3
   const assigned_components = [
     { name: "CacheHelper", source: "src/utils/cache.helper.ts", target_doc: "docs/utilities/cache-helper.md" },
     { name: "RateLimiter", source: "src/middleware/rate-limiter.ts", target_doc: "docs/middleware/rate-limiter.md" },
     // ... all assigned components
   ]
   const assignedCount = assigned_components.length
   ```

2. **Verify each new file exists and has content**
   ```typescript
   let verified = 0
   let missing = []
   let stub = []

   for (const component of assigned_components) {
     const file_exists = await check_file_exists(component.target_doc)

     if (file_exists) {
       const file_size = await get_file_size(component.target_doc)

       if (file_size > 100) {
         console.log(`✅ ${component.name} → ${component.target_doc} (${file_size} bytes)`)
         verified++
       } else {
         console.log(`⚠️ ${component.name} → ${component.target_doc} (${file_size} bytes) [STUB/EMPTY]`)
         stub.push({...component, file_size})
       }
     } else {
       console.log(`❌ ${component.name} → ${component.target_doc} [MISSING]`)
       missing.push(component)
     }
   }
   ```

3. **Verify 100% completion with non-stub content**
   ```typescript
   console.log(`\nVerification Results:`)
   console.log(`Assigned: ${assignedCount}`)
   console.log(`Verified: ${verified}`)
   console.log(`Missing: ${missing.length}`)
   console.log(`Stub/Empty: ${stub.length}`)

   if (verified !== assignedCount) {
     console.log(`\n❌ GATE FAILURE: Physical file verification failed`)
     console.log(`Cannot generate completion report`)

     if (missing.length > 0) {
       console.log(`\nMissing files:`)
       for (const item of missing) {
         console.log(`  - ${item.name} → ${item.target_doc} [NOT CREATED]`)
       }
     }

     if (stub.length > 0) {
       console.log(`\nStub/Empty files:`)
       for (const item of stub) {
         console.log(`  - ${item.name} → ${item.target_doc} (${item.file_size} bytes)`)
       }
     }

     console.log(`\nREQUIRED ACTION:`)
     if (missing.length > 0) {
       console.log(`  1. Use Write tool to create ${missing.length} missing files`)
     }
     if (stub.length > 0) {
       console.log(`  2. Fill ${stub.length} stub files with complete documentation (>100 bytes)`)
     }
     console.log(`  3. Use Read tool to verify each file`)
     console.log(`  4. Re-run this verification`)

     throw new Error(`APO-3 Gate Failure: ${missing.length} missing, ${stub.length} stub/empty`)
   }

   console.log(`\n✅ GATE PASS: All ${assignedCount} files verified with content`)
   ```

4. **Only if gate passes, proceed to completion report**
   - Gate ensures 100% physical file creation
   - Gate ensures no stub/empty files
   - Prevents false completion reports
   - Forces APO to create all assigned files with real content

---

#### APO-3 Step 7: Generate Completion Report

**Use template:** `trinity/templates/documentation/reports/apo-business-create-completion.md`

**Report includes:**
- All components documented
- New files created
- Documentation structure used
- Modularity analysis for each component
- Routing decisions explained
- Code examples included
- Integration with existing docs
- Issues encountered
- Quality metrics

**Save to:** `trinity/reports/APO-3-BUSINESS-CREATE-COMPLETE-iteration-{{ITERATION}}-{{DATE}}.md`

---

### Phase 2 Completion

**All 3 APOs complete their work and generate completion reports.**

**Update global state:**
```json
{
  "currentPhase": "verification",
  "reportsGenerated": [
    "DOCS-UPDATE-AUDIT-iteration-1-2026-01-16.md",
    "APO-1-BASE-UPDATE-COMPLETE-iteration-1-2026-01-16.md",
    "APO-2-BUSINESS-UPDATE-COMPLETE-iteration-1-2026-01-16.md",
    "APO-3-BUSINESS-CREATE-COMPLETE-iteration-1-2026-01-16.md"
  ]
}
```

**Proceed to Phase 3.**

---

## Phase 3: JUNO Verification Loop

**Agent:** JUNO (Quality Auditor)
**Mode:** READ-ONLY (Verification phase)
**Output:** `trinity/reports/DOCS-UPDATE-VERIFICATION-iteration-{{ITERATION}}-{{DATE}}.md`


**⚠️ AUTONOMOUS ITERATION - ITERATE AUTOMATICALLY WITHOUT USER INPUT:**
- JUNO verification executes automatically
- If alignment < 100%: Return to Phase 1 AUTOMATICALLY (no user confirmation needed)
- If alignment = 100%: Proceed to Phase 4 AUTOMATICALLY
- DO NOT stop to ask user whether to iterate
- DO NOT ask user to confirm iteration decision
- Decision tree execution is AUTOMATIC based on metrics

---
---

### Step 3.1: Read APO Completion Reports

Read all 3 APO completion reports from current iteration:
- APO-1-BASE-UPDATE-COMPLETE-iteration-{{ITERATION}}-{{DATE}}.md
- APO-2-BUSINESS-UPDATE-COMPLETE-iteration-{{ITERATION}}-{{DATE}}.md
- APO-3-BUSINESS-CREATE-COMPLETE-iteration-{{ITERATION}}-{{DATE}}.md

**Extract:**
- Files updated/created
- Changes made
- Issues reported

---

### Step 3.1A: Verify Assignment Completion

**CRITICAL: Cross-check assignments vs completions BEFORE accuracy verification.**

This step ensures APOs completed 100% of assigned work, preventing false 100% reports.

---

#### Step 3.1A.1: Read APO Assignments from Audit Report

Read the current iteration's audit report:
- `trinity/reports/DOCS-UPDATE-AUDIT-iteration-{{ITERATION}}-{{DATE}}.md`

**Extract assignments:**

```typescript
// From Part 1: Base Documentation Updates
const apo1Assigned: string[] = [
  "docs/architecture/system-design.md",
  "docs/setup/installation.md",
  // ... all files assigned to APO-1
];

// From Part 2: Existing Business Logic Updates
const apo2Assigned: string[] = [
  "UserService",
  "PaymentService",
  "RefundService",
  // ... all components assigned to APO-2
];

// From Part 3: Missing Business Logic (New Docs)
const apo3Assigned: string[] = [
  "NotificationService",
  "CacheHelper",
  "RateLimiter",
  // ... all components assigned to APO-3
];
```

---

#### Step 3.1A.2: Verify Physical File Creation (Cross-Check Reports vs Filesystem)

**⚠️ CRITICAL: Do not trust APO reports - verify EVERY file physically exists in filesystem.**

**Verification Process:**

**For APO-1 (Base Documentation Updates):**

1. **Extract claimed files from APO-1 report**
   - Read: `trinity/reports/APO-1-BASE-UPDATE-COMPLETE-iteration-{{ITERATION}}-{{DATE}}.md`
   - Section: "Files Modified"
   - Example: `["docs/architecture/system-design.md", ...]`

2. **Verify each file exists in filesystem**
   ```typescript
   const apo1_claimed_files = extract_from_report("APO-1", "Files Modified")
   const apo1_verified_files = []
   const apo1_missing_files = []

   for (const file of apo1_claimed_files) {
     const exists = await file_exists(file)

     if (exists) {
       apo1_verified_files.push(file)
     } else {
       apo1_missing_files.push(file)

       // Create CRITICAL discrepancy
       create_discrepancy({
         severity: "CRITICAL",
         category: "File Creation Failure",
         message: "APO-1 claimed file modified but file not found in filesystem",
         file: file,
         apo: "APO-1"
       })
     }
   }
   ```

3. **Use only VERIFIED files for completeness calculation**
   ```typescript
   const apo1Completed = apo1_verified_files  // NOT apo1_claimed_files
   ```

**For APO-2 (Business Logic Updates):**

1. **Extract claimed components from APO-2 report**
   - Read: `trinity/reports/APO-2-BUSINESS-UPDATE-COMPLETE-iteration-{{ITERATION}}-{{DATE}}.md`
   - Section: "Components Updated"
   - Extract: Component name + Target documentation path

2. **Verify each target documentation file exists**
   ```typescript
   const apo2_report_components = extract_from_report("APO-2", "Components Updated")
   const apo2_verified_components = []
   const apo2_missing_components = []

   for (const component of apo2_report_components) {
     const target_doc = component.target_documentation_path
     const exists = await file_exists(target_doc)

     if (exists) {
       const file_size = await get_file_size(target_doc)

       if (file_size > 100) {
         apo2_verified_components.push(component.name)
       } else {
         // File exists but is stub/empty
         create_discrepancy({
           severity: "HIGH",
           category: "Stub Documentation",
           message: "APO-2 created file but content is stub/empty (<100 bytes)",
           file: target_doc,
           file_size: file_size,
           apo: "APO-2"
         })
       }
     } else {
       apo2_missing_components.push(component.name)

       // Create CRITICAL discrepancy
       create_discrepancy({
         severity: "CRITICAL",
         category: "File Creation Failure",
         message: "APO-2 claimed component documented but file not found",
         component: component.name,
         expected_file: target_doc,
         apo: "APO-2"
       })
     }
   }
   ```

3. **Use only VERIFIED components for completeness calculation**
   ```typescript
   const apo2Completed = apo2_verified_components  // NOT apo2_claimed_components
   ```

**For APO-3 (New Documentation):**

1. **Extract claimed new files from APO-3 report**
   - Read: `trinity/reports/APO-3-BUSINESS-CREATE-COMPLETE-iteration-{{ITERATION}}-{{DATE}}.md`
   - Section: "New Files Created"
   - Example: `["docs/scrapers/base-dealer-scraper.md", ...]`

2. **Verify each new file exists and has content**
   ```typescript
   const apo3_claimed_files = extract_from_report("APO-3", "New Files Created")
   const apo3_verified_files = []
   const apo3_missing_files = []
   const apo3_stub_files = []

   for (const file of apo3_claimed_files) {
     const exists = await file_exists(file)

     if (exists) {
       const file_size = await get_file_size(file)

       if (file_size > 100) {
         apo3_verified_files.push(file)
       } else {
         apo3_stub_files.push(file)

         // Create HIGH severity discrepancy for stub
         create_discrepancy({
           severity: "HIGH",
           category: "Stub Documentation",
           message: "APO-3 created file but content is stub/empty (<100 bytes)",
           file: file,
           file_size: file_size,
           apo: "APO-3"
         })
       }
     } else {
       apo3_missing_files.push(file)

       // Create CRITICAL discrepancy for missing
       create_discrepancy({
         severity: "CRITICAL",
         category: "File Creation Failure",
         message: "APO-3 claimed file created but file not found in filesystem",
         file: file,
         apo: "APO-3"
       })
     }
   }
   ```

3. **Use only VERIFIED files for completeness calculation**
   ```typescript
   const apo3Completed = apo3_verified_files  // NOT apo3_claimed_files
   ```

**Example Production Failure Detection:**
```markdown
=== JUNO Step 3.1A.2 Filesystem Verification ===

APO-2 Completion Report Claims:
- 19 components documented
- Target files: docs/database/equipment-model.md, docs/database/dealer-model.md, [+ 17 more]

Filesystem Verification Results:
✅ docs/api/README.md - EXISTS (1,327,543 bytes)
❌ docs/database/equipment-model.md - MISSING
❌ docs/database/dealer-model.md - MISSING
❌ docs/database/change-model.md - MISSING
[... 16 more MISSING]

Verification Summary:
- APO-2 Claimed: 19 components
- APO-2 Verified: 1 components ✅
- APO-2 Missing: 18 components ❌
- APO-2 Completeness: 1/19 = 5.26% (NOT 100%)

CRITICAL DISCREPANCIES CREATED: 18

Assignment Completeness Calculation:
- APO-1: 3/3 verified (100%)
- APO-2: 1/19 verified (5.26%)  ← DETECTED FAILURE
- APO-3: 0/16 verified (0%)     ← DETECTED FAILURE
- Overall: 4/38 = 10.53%        ← REAL COMPLETENESS

Result: NOT 100% aligned, must ITERATE
```

---

#### Step 3.1A.3: Calculate Missing Work
#### Step 3.1A.3: Calculate Missing Work

**For each APO, identify missing items:**

```typescript
// APO-1 Missing Work
const apo1Missing = apo1Assigned.filter(file => !apo1Completed.includes(file));
const apo1Completeness = (apo1Completed.length / apo1Assigned.length) * 100;

// APO-2 Missing Work
const apo2Missing = apo2Assigned.filter(component => !apo2Completed.includes(component));
const apo2Completeness = (apo2Completed.length / apo2Assigned.length) * 100;

// APO-3 Missing Work
const apo3Missing = apo3Assigned.filter(component => !apo3Completed.includes(component));
const apo3Completeness = (apo3Completed.length / apo3Assigned.length) * 100;

// Overall Assignment Completeness
const totalAssigned = apo1Assigned.length + apo2Assigned.length + apo3Assigned.length;
// CRITICAL: Use VERIFIED counts (from filesystem check), not claimed counts from reports
const totalCompleted = apo1_verified_files.length + apo2_verified_components.length + apo3_verified_files.length;
const assignment_completeness = (totalCompleted / totalAssigned) * 100;
```

**Example:**
```
APO-1: Assigned 12, Completed 12 → 100% ✅
APO-2: Assigned 33, Completed 25 → 75.76% ❌
APO-3: Assigned 8, Completed 8 → 100% ✅

Overall: (12+25+8) / (12+33+8) = 45/53 = 84.91% ❌
```

---

#### Step 3.1A.4: Create Discrepancies for Missing Work

**IF any APO has missing work (completeness < 100%):**

For each missing item, create a HIGH severity discrepancy:

```markdown
### Discrepancy D-XXX: APO-2 Incomplete - Missing [ComponentName]

**Severity:** HIGH
**Category:** Assignment Completion
**APO:** APO-2

**Assignment:**
- Component: [ComponentName]
- Source: [source/path/to/component.ts]
- Target Doc: [docs/path/to/component.md]
- Assigned in: DOCS-UPDATE-AUDIT-iteration-{{ITERATION}}-{{DATE}}.md

**Completion Status:**
- ❌ NOT COMPLETED
- Component was assigned but no documentation was created/updated

**Impact:**
- Assignment completeness: {{COMPLETENESS}}% (below 100%)
- Component remains undocumented
- Overall alignment cannot reach 100%

**Required Action:**
- APO-2 MUST document this component in next iteration
- No rationalizations (e.g., "future scope", "lower priority")
- 100% completion is mandatory

**Next Iteration Assignment:** APO-2 (HIGH PRIORITY)
```

**Create one discrepancy per missing item.**

---

#### Step 3.1A.5: Record Assignment Completeness Metrics

**Store metrics for Step 3.3 alignment calculation:**

```json
{
  "assignmentCompleteness": {
    "apo1": {
      "assigned": 12,
      "completed": 12,
      "percentage": 100.0,
      "missing": []
    },
    "apo2": {
      "assigned": 33,
      "completed": 25,
      "percentage": 75.76,
      "missing": [
        "DealerFilter",
        "EquipmentCard",
        "ComparisonModal",
        "DealershipList",
        "EquipmentList",
        "SearchBar",
        "FilterPanel",
        "PriceDisplay"
      ]
    },
    "apo3": {
      "assigned": 8,
      "completed": 8,
      "percentage": 100.0,
      "missing": []
    },
    "overall": {
      "totalAssigned": 53,
      "totalCompleted": 45,
      "percentage": 84.91
    }
  }
}
```

---

#### Step 3.1A.6: Decision Point

**IF assignment_completeness === 100%:**
- ✅ All assigned work completed
- Proceed to Step 3.2 (Alignment Verification)
- Overall alignment CAN reach 100% if accuracy is also 100%

**IF assignment_completeness < 100%:**
- ❌ Incomplete work detected
- HIGH severity discrepancies created
- Proceed to Step 3.2 (Alignment Verification)
- **IMPORTANT:** Overall alignment is capped at assignment_completeness
  - Example: If assignment_completeness = 84.91%, overall alignment ≤ 84.91%
  - Even if documented items are 100% accurate, overall cannot exceed 84.91%

---

**Why This Step Is Critical:**

In production test failure:
- APO-2 assigned 33 components
- APO-2 completed 25 components (75.76%)
- APO-2 reported 100% success (only checked accuracy of 25 completed)
- JUNO never checked if all 33 were completed
- Result: 75.76% work reported as 100% success

This step prevents that failure by checking completeness BEFORE accuracy.

---

### Step 3.2: Comprehensive Alignment Verification

**Verify 100% alignment at ALL levels:**

---

#### Architecture-Level Alignment

**For each architecture documentation file:**

1. **Read documentation**
   - Example: `docs/architecture/system-design.md`

2. **Verify against codebase**
   - Does directory structure match architecture diagram?
   - Are major components described accurately?
   - Are system boundaries correct?
   - Are data flows accurate?

3. **Calculate alignment**
   - Count total claims in architecture docs
   - Count verified claims
   - Calculate: (verified / total) * 100 = architecture_alignment%

---

#### Module-Level Alignment

**For each module documentation file (services, controllers, models, etc.):**

1. **Read documentation**
   - Example: `docs/api/user-service.md`

2. **Read source code**
   - Example: `src/services/user.service.ts`

3. **Verify every documented method**
   - Method name matches?
   - Parameters match?
   - Return type matches?
   - Behavior description accurate?

4. **Identify missing methods**
   - Are there public methods in code not documented?
   - Count as discrepancy

5. **Identify fake methods**
   - Are there methods documented that don't exist in code?
   - Count as discrepancy

6. **Calculate alignment**
   - Count total methods in code
   - Count correctly documented methods
   - Calculate: (correct / total) * 100 = module_alignment%

---

#### Function-Level Alignment

**For each function/method documented:**

1. **Read function documentation**
   - Parameters documented?
   - Return type documented?
   - Behavior explained?
   - Error cases covered?

2. **Read function source code**
   - Extract actual signature
   - Identify actual behavior
   - List actual error cases

3. **Compare**
   - Signature matches? ✅ or ❌
   - Behavior matches? ✅ or ❌
   - Error cases documented? ✅ or ❌

4. **Calculate alignment**
   - Count total functions
   - Count correctly documented functions
   - Calculate: (correct / total) * 100 = function_alignment%

---

### Step 3.3: Calculate Overall Alignment

**CRITICAL: Alignment has TWO dimensions that must BOTH be 100%.**

---

#### Dimension 1: Assignment Completeness (from Step 3.1A)

**Formula:**
```typescript
assignment_completeness = (totalCompleted / totalAssigned) * 100
```

**This measures:** Did APOs complete ALL assigned work?

**Example from production failure:**
```
Assigned: 53 items (12 APO-1 + 33 APO-2 + 8 APO-3)
Completed: 45 items (12 APO-1 + 25 APO-2 + 8 APO-3)
assignment_completeness = (45 / 53) * 100 = 84.91%
```

---

#### Dimension 2: Documentation Accuracy (from Step 3.2)

**Formula:**
```typescript
documentation_accuracy = (
  (architecture_alignment * 0.33) +
  (module_alignment * 0.33) +
  (function_alignment * 0.34)
)
```

**This measures:** Are completed docs accurate to codebase?

**Example:**
```
Architecture: 100% aligned (all completed architecture docs are accurate)
Module: 100% aligned (all completed module docs are accurate)
Function: 100% aligned (all completed function docs are accurate)

documentation_accuracy = (100*0.33 + 100*0.33 + 100*0.34) = 100%
```

**In production failure:**
- APO-2 documented 25 components with 100% accuracy
- BUT only 25/33 were documented
- documentation_accuracy = 100% (the 25 were correct)
- assignment_completeness = 75.76% (only 25/33 completed)

---

#### Overall Alignment: MIN(Completeness, Accuracy)

**CRITICAL FORMULA:**
```typescript
overall_alignment = MIN(assignment_completeness, documentation_accuracy)
```

**Why MIN():**
- **BOTH dimensions must be 100% for overall 100%**
- If completeness = 84.91% and accuracy = 100%, overall = 84.91%
- If completeness = 100% and accuracy = 92%, overall = 92%
- Only if BOTH = 100%, overall = 100%

---

#### Examples

**Example 1: Production Failure Scenario**
```typescript
assignment_completeness = 84.91%  // 45/53 items completed
documentation_accuracy = 100%      // completed items were accurate

overall_alignment = MIN(84.91, 100) = 84.91% ❌

Result: NOT 100% aligned, must iterate
Reason: Incomplete work (8 frontend components missing)
```

**Example 2: Inaccurate but Complete**
```typescript
assignment_completeness = 100%  // All items completed
documentation_accuracy = 92%    // Some inaccuracies in completed docs

overall_alignment = MIN(100, 92) = 92% ❌

Result: NOT 100% aligned, must iterate
Reason: Inaccurate documentation needs fixes
```

**Example 3: Perfect Alignment**
```typescript
assignment_completeness = 100%  // All items completed
documentation_accuracy = 100%   // All docs accurate

overall_alignment = MIN(100, 100) = 100% ✅

Result: 100% aligned, proceed to Phase 4
Reason: Complete AND accurate
```

**Example 4: Incomplete AND Inaccurate**
```typescript
assignment_completeness = 87%  // Some missing work
documentation_accuracy = 91%   // Some inaccuracies

overall_alignment = MIN(87, 91) = 87% ❌

Result: NOT 100% aligned, must iterate
Reason: Both completeness AND accuracy need work
Focus: Fix missing items (APO accountability issue)
       AND fix inaccuracies (documentation quality issue)
```

---

#### Key Insight

**Old (Wrong) Formula:**
```
alignment = (accurate / documented) * 100
```
- Only checked accuracy of documented items
- Never checked if ALL assigned items were documented
- Allowed 75% completion to be reported as 100% success

**New (Correct) Formula:**
```
overall_alignment = MIN(
  (completed / assigned) * 100,
  weighted_accuracy_of_completed_docs
)
```
- Checks BOTH completeness AND accuracy
- Requires BOTH at 100% for overall 100%
- Prevents false 100% reports

---

**Record Metrics in Verification Report:**
```json
{
  "alignment": {
    "assignment_completeness": 84.91,
    "documentation_accuracy": 100.0,
    "overall_alignment": 84.91,
    "formula": "MIN(assignment_completeness, documentation_accuracy)",
    "breakdown": {
      "architecture": 100.0,
      "module": 100.0,
      "function": 100.0
    },
    "result": "NOT 100% - Incomplete work detected",
    "decision": "ITERATE - Focus on missing items"
  }
}
```

---

### Step 3.4: Identify All Discrepancies

**For each misalignment found, create discrepancy record:**

```markdown
### Discrepancy D-042: UserService.updateUser signature mismatch

**Severity:** HIGH
**Category:** Function-level

**Location:**
- Documentation: `docs/api/user-service.md:87`
- Codebase: `src/services/user.service.ts:42`

**What Documentation Says:**
```
updateUser(userId: string, data: UpdateUserDto): Promise<User>
```

**What Codebase Actually Has:**
```
updateUser(userId: string, data: UpdateUserDto, options?: UpdateOptions): Promise<User>
```

**Issue:** Missing optional `options` parameter in documentation

**Impact:** Developers won't know about options parameter

**Required Fix:** Add options parameter to documentation

**Assigned To:** APO-2 (for next iteration)
```

---

### Step 3.5: Generate Verification Report

**Use template:** `trinity/templates/documentation/reports/docs-update-verification.md`

**Report includes:**
- Overall alignment percentage
- Architecture-level alignment details
- Module-level alignment details
- Function-level alignment details
- Complete discrepancy list (all severities)
- APO performance review
- Decision: PROCEED TO PHASE 4 or ITERATE

**Save to:** `trinity/reports/DOCS-UPDATE-VERIFICATION-iteration-{{ITERATION}}-{{DATE}}.md`

---

### Step 3.6: Decision Tree


**⚠️ AUTOMATIC DECISION - NO USER PROMPT:**
- Evaluate metrics and execute decision tree AUTOMATICALLY
- If 100% alignment: Proceed to Phase 4 WITHOUT asking user
- If < 100% alignment: Return to Phase 1 WITHOUT asking user
- If max iterations reached: ABORT WITHOUT asking user
- DO NOT present options to user - EXECUTE the decision

---
**Update global state with BOTH metrics:**
```json
{
  "alignmentHistory": [
    {
      "iteration": 1,
      "assignment_completeness": 84.91,
      "documentation_accuracy": 100.0,
      "overall_alignment": 84.91,
      "discrepanciesFound": 23,
      "formula": "MIN(assignment_completeness, documentation_accuracy)"
    }
  ]
}
```

---

#### Decision 1: 100% Alignment Achieved (Strict Criteria)

**BOTH metrics must be 100% for overall 100%:**

```typescript
IF (assignment_completeness === 100% AND documentation_accuracy === 100%):
  overall_alignment = MIN(100, 100) = 100%
  → PROCEED TO PHASE 4 (Completion) ✅
  → stopCondition = "100_percent_aligned"
```

**Validation:**
- ✅ **All assigned work completed** (assignment_completeness = 100%)
- ✅ **All documented work is accurate** (documentation_accuracy = 100%)
- ✅ **Overall alignment = 100%**

**Example:**
```
Iteration 2 Results:
- APO-1: 12/12 files (100%) ✅
- APO-2: 33/33 components (100%) ✅
- APO-3: 8/8 components (100%) ✅
- assignment_completeness = 53/53 = 100% ✅

- Architecture: 100% aligned ✅
- Module: 100% aligned ✅
- Function: 100% aligned ✅
- documentation_accuracy = 100% ✅

overall_alignment = MIN(100, 100) = 100% ✅

Decision: PROCEED TO PHASE 4 ✅
```

**Stop Condition Met: SUCCESS**

---

#### Decision 2: Not 100% Aligned - Incomplete Work (Iterations Remaining)

**IF assignment_completeness < 100%:**

```typescript
IF (assignment_completeness < 100% AND currentIteration < 3):
  // Work was skipped - APO accountability failure
  overall_alignment = MIN(assignment_completeness, documentation_accuracy)
  → ITERATE (back to Phase 1) 🔄
  → currentIteration++
  → currentPhase = "audit"
  → Focus: HIGH priority on missing items from Step 3.1A
```

**Example (Production Failure Scenario):**
```
Iteration 1 Results:
- APO-1: 12/12 files (100%) ✅
- APO-2: 25/33 components (75.76%) ❌  ← 8 frontend components missing
- APO-3: 8/8 components (100%) ✅
- assignment_completeness = 45/53 = 84.91% ❌

- Architecture: 100% aligned ✅
- Module: 100% aligned ✅ (for the 25 completed components)
- Function: 100% aligned ✅ (for the 25 completed components)
- documentation_accuracy = 100% ✅

overall_alignment = MIN(84.91, 100) = 84.91% ❌

Decision: ITERATE 🔄
Reason: Incomplete work (8 components not documented)
Priority: HIGH - APO-2 MUST complete all 33 components
Next: Phase 1 audit focuses on 8 missing components
```

**Iteration Focus:**
1. JUNO re-audits with focus on 8 missing components
2. JUNO assigns missing components to APO-2 (HIGH priority)
3. APO-2 documents all 8 missing components
4. JUNO verifies assignment_completeness = 100% and documentation_accuracy = 100%

---

#### Decision 3: Not 100% Aligned - Inaccurate Docs (Iterations Remaining)

**IF documentation_accuracy < 100%:**

```typescript
IF (documentation_accuracy < 100% AND currentIteration < 3):
  // Docs are inaccurate - quality issue
  overall_alignment = MIN(assignment_completeness, documentation_accuracy)
  → ITERATE (back to Phase 1) 🔄
  → currentIteration++
  → currentPhase = "audit"
  → Focus: Fix inaccuracies identified in Step 3.2
```

**Example:**
```
Iteration 1 Results:
- assignment_completeness = 100% ✅ (all work completed)

- Architecture: 95% aligned ⚠️
- Module: 88% aligned ⚠️
- Function: 92% aligned ⚠️
- documentation_accuracy = 91.67% ❌

overall_alignment = MIN(100, 91.67) = 91.67% ❌

Decision: ITERATE 🔄
Reason: Inaccurate documentation (discrepancies at all levels)
Priority: Fix 23 identified discrepancies
Next: Phase 1 audit focuses on inaccurate sections
```

---

#### Decision 4: Not 100% Aligned - Both Issues (Iterations Remaining)

**IF assignment_completeness < 100% AND documentation_accuracy < 100%:**

```typescript
IF (assignment_completeness < 100% AND documentation_accuracy < 100% AND currentIteration < 3):
  // Both incomplete work AND inaccuracies
  overall_alignment = MIN(assignment_completeness, documentation_accuracy)
  → ITERATE (back to Phase 1) 🔄
  → currentIteration++
  → currentPhase = "audit"
  → Focus: BOTH missing items AND inaccuracies (prioritize completeness)
```

**Example:**
```
Iteration 1 Results:
- assignment_completeness = 87% ❌ (some work missing)
- documentation_accuracy = 91% ❌ (some inaccuracies)

overall_alignment = MIN(87, 91) = 87% ❌

Decision: ITERATE 🔄
Reason: Both incomplete work AND inaccuracies
Priority Order:
  1. HIGH: Complete missing work (APO accountability)
  2. HIGH: Fix inaccuracies (documentation quality)
Next: Phase 1 audit focuses on BOTH issues
```

---

#### Decision 5: Max Iterations Reached Without 100%

**Regardless of which metric(s) are below 100%:**

```typescript
IF (overall_alignment < 100% AND currentIteration === 3):
  // 3 iterations completed, still not 100%
  → ABORT (Max iterations without 100% alignment) ⚠️
  → stopCondition = "max_iterations"
  → Generate final report with detailed root cause analysis
```

**Example:**
```
Iteration 3 Results:
- assignment_completeness = 98% ❌ (3 items still missing)
- documentation_accuracy = 97% ❌ (5 inaccuracies remaining)

overall_alignment = MIN(98, 97) = 97% ❌

Decision: ABORT (Max 3 iterations reached) ⚠️

Root Cause Analysis:
1. Remaining incomplete work:
   - APO-2: 3 complex components with interdependencies
   - Reason: Circular dependencies preventing documentation

2. Remaining inaccuracies:
   - 5 discrepancies in edge case handling
   - Reason: Code behavior ambiguous without unit tests

Recommendation:
1. Manually resolve circular dependencies
2. Add unit tests to clarify edge case behavior
3. Re-run trinity-docs-update after fixes
```

**Stop Condition Met: MAX ITERATIONS REACHED**

Proceed to Phase 4 with INCOMPLETE status.

---

**Continue to next iteration:**
1. Increment iteration counter: `currentIteration++`
2. Reset phase: `currentPhase = "audit"`
3. Go back to Phase 1 (JUNO Audit)
4. **Focus areas based on metrics:**
   - If assignment_completeness < 100%: Prioritize missing items (HIGH)
   - If documentation_accuracy < 100%: Fix discrepancies
   - If both < 100%: Address completeness first, then accuracy
5. APOs work on focused assignments
6. JUNO verifies again in Phase 3
7. Decision tree evaluates again

---

**Key Difference from Old Decision Tree:**

**Old (Wrong):**
```
IF overall_alignment === 100%:
  → PROCEED ✅

Could be triggered by:
- assignment_completeness = 84.91%
- documentation_accuracy = 100%
- overall_alignment calculated as 100% (wrong formula)
- Result: FALSE 100% SUCCESS
```

**New (Correct):**
```
IF (assignment_completeness === 100% AND documentation_accuracy === 100%):
  → PROCEED ✅

Only triggered when:
- assignment_completeness = 100% (ALL work done)
- documentation_accuracy = 100% (ALL docs accurate)
- overall_alignment = MIN(100, 100) = 100% (TRUE 100%)
- Result: REAL 100% SUCCESS
```

**This prevents false 100% reports.**

---

## Phase 4: Completion & Cleanup

**Agent:** JUNO (Quality Auditor)
**Output:** `trinity/reports/DOCS-UPDATE-COMPLETE-{{DATE}}.md`

---

### Step 4.1: Generate Final Completion Report

**Use template:** `trinity/templates/documentation/reports/docs-update-complete.md`

**Report includes:**
- Final alignment percentage (100% if successful, <100% if max iterations)
- Total iterations executed
- Journey overview (alignment progress per iteration)
- All work completed summary (APO-1, APO-2, APO-3 totals)
- All files modified list
- Quality metrics (4-tier scoring)
- Business logic inventory
- Discrepancy resolution tracking
- Performance metrics
- Lessons learned
- All reports generated list

**Save to:** `trinity/reports/DOCS-UPDATE-COMPLETE-{{DATE}}.md`

---

### Step 4.2: Move All Reports to trinity/sessions/

**Move ALL reports generated during execution:**

```bash
mv trinity/reports/DOCS-UPDATE-AUDIT-iteration-*.md trinity/sessions/
mv trinity/reports/APO-1-BASE-UPDATE-COMPLETE-iteration-*.md trinity/sessions/
mv trinity/reports/APO-2-BUSINESS-UPDATE-COMPLETE-iteration-*.md trinity/sessions/
mv trinity/reports/APO-3-BUSINESS-CREATE-COMPLETE-iteration-*.md trinity/sessions/
mv trinity/reports/DOCS-UPDATE-VERIFICATION-iteration-*.md trinity/sessions/
mv trinity/reports/DOCS-UPDATE-COMPLETE-*.md trinity/sessions/
```

**Verify trinity/reports/ is now empty of docs-update related reports.**

---

### Step 4.3: Report Completion to User

**If 100% alignment achieved:**

```
✅ SUCCESS: Documentation Update Complete

Final Alignment: 100% ✅
Iterations: {{TOTAL_ITERATIONS}}
Files Updated: {{FILES_UPDATED}}
New Files Created: {{NEW_FILES_CREATED}}
Business Logic Documented: {{BUSINESS_LOGIC_COUNT}}

Your documentation now perfectly reflects your codebase at all levels:
- Architecture-level: 100% aligned ✅
- Module-level: 100% aligned ✅
- Function-level: 100% aligned ✅

Reports archived to: trinity/sessions/

To view final report:
  trinity/sessions/DOCS-UPDATE-COMPLETE-{{DATE}}.md

Your documentation is now trustworthy and up-to-date.
```

---

**If max iterations reached without 100% alignment:**

```
⚠️ INCOMPLETE: Documentation Update Reached Max Iterations

Final Alignment: {{FINAL_ALIGNMENT}}% (Target: 100%)
Iterations: 3 (max)
Discrepancies Remaining: {{DISCREPANCIES_REMAINING}}

Alignment by Level:
- Architecture-level: {{ARCH_ALIGNMENT}}%
- Module-level: {{MODULE_ALIGNMENT}}%
- Function-level: {{FUNCTION_ALIGNMENT}}%

Root Cause:
{{ROOT_CAUSE_DESCRIPTION}}

Reports archived to: trinity/sessions/

To view detailed analysis:
  trinity/sessions/DOCS-UPDATE-COMPLETE-{{DATE}}.md
  trinity/sessions/DOCS-UPDATE-VERIFICATION-iteration-3-{{DATE}}.md

Recommended Actions:
1. {{ACTION_1}}
2. {{ACTION_2}}
3. Re-run trinity-docs-update after corrections

Manual intervention required.
```

---

### Step 4.4: Update Global State (Final)

```json
{
  "command": "trinity-docs-update",
  "startTime": "{{START_TIMESTAMP}}",
  "endTime": "{{END_TIMESTAMP}}",
  "currentIteration": {{FINAL_ITERATION}},
  "maxIterations": 3,
  "currentPhase": "complete",
  "finalAlignment": {{FINAL_ALIGNMENT}},
  "alignmentHistory": [
    {"iteration": 1, "alignmentPercentage": 91.62, "discrepanciesFound": 23},
    {"iteration": 2, "alignmentPercentage": 97.5, "discrepanciesFound": 7},
    {"iteration": 3, "alignmentPercentage": 100, "discrepanciesFound": 0}
  ],
  "apoAssignments": [...],
  "reportsGenerated": [...],
  "stopCondition": "{{STOP_CONDITION}}"
}
```

---

## Context Recovery Mechanism

**If execution is interrupted mid-command due to context window limits:**

### Recovery Procedure

1. **Read Most Recent Report**
   - Check `trinity/reports/` for most recent DOCS-UPDATE-* report
   - Read the state snapshot JSON at end of report

2. **Extract State Information**
   ```json
   {
     "currentIteration": 2,
     "currentPhase": "apo_execution",
     "alignmentHistory": [...],
     "apoAssignments": [...],
     "reportsGenerated": [...]
   }
   ```

3. **Resume from Current Phase**

**If currentPhase === "audit":**
- Resume Phase 1 (JUNO Audit) for current iteration
- Complete audit report
- Proceed to Phase 2

**If currentPhase === "apo_execution":**
- Read audit report for current iteration
- Check which APO reports exist
  - If APO-1 report missing → Run APO-1
  - If APO-2 report missing → Run APO-2
  - If APO-3 report missing → Run APO-3
- After all APOs complete, proceed to Phase 3

**If currentPhase === "verification":**
- Resume Phase 3 (JUNO Verification)
- Read all APO reports from current iteration
- Complete verification
- Make decision (iterate or complete)

**If currentPhase === "complete":**
- Execution was nearly complete
- Generate final report if missing
- Move reports to trinity/sessions/
- Report to user

4. **Continue Until Stop Condition**
   - Do NOT ask user for confirmation to resume
   - Automatically continue execution
   - Stop only when one of 3 stop conditions is met

---

## Quality Scoring (4-Tier System)

**Same as trinity-docs command:**

**1. Completion (40 points):**
- All assigned work completed
- All iterations executed
- All reports generated

**2. Quality (40 points):**
- Accuracy of documentation
- Completeness of coverage
- Clarity of explanations
- Technical depth

**3. Accuracy (15 points):**
- Codebase verification
- No fake components
- Cross-references validated

**4. Excellence (5 points):**
- Above-and-beyond factors
- Exceptional clarity
- Proactive improvements

**Total: 100 points**

**Grading:**
- 90-100: A (Excellent)
- 80-89: B (Good)
- 70-79: C (Acceptable)
- 60-69: D (Needs Improvement)
- Below 60: F (Unacceptable)

---

## Workflow Summary

```
┌─────────────────────────────────────────────────────────────┐
│              TRINITY-DOCS-UPDATE WORKFLOW                   │
└─────────────────────────────────────────────────────────────┘

PHASE 0: Pre-Flight Check
├─ Check docs/ exists → ABORT if missing
└─ Initialize global state

PHASE 1: JUNO Audit (Iteration {{N}})
├─ Scan existing docs/
├─ Scan codebase (ALL levels: architecture, module, function)
├─ Cross-reference docs vs code
├─ Identify discrepancies
├─ Assign work to APOs (APO-1: base, APO-2: tied, APO-3: modular)
├─ Zero-tolerance check
└─ Generate audit report

PHASE 2: Parallel APO Execution
├─ APO-1: Update base docs (architecture, guides, setup)
├─ APO-2: Update business logic docs (tied components)
├─ APO-3: Create new business logic docs (modular components)
└─ All APOs generate completion reports

PHASE 3: JUNO Verification
├─ Read APO reports
├─ Verify alignment at ALL levels
│  ├─ Architecture-level verification
│  ├─ Module-level verification
│  └─ Function-level verification
├─ Calculate overall alignment percentage
├─ Identify all discrepancies
└─ Decision:
   ├─ IF 100% aligned → PROCEED TO PHASE 4 ✅
   ├─ IF <100% AND iteration < 3 → ITERATE (back to PHASE 1) 🔄
   └─ IF <100% AND iteration === 3 → ABORT (max iterations) ⚠️

PHASE 4: Completion
├─ Generate final completion report
├─ Move all reports to trinity/sessions/
└─ Report to user (SUCCESS or INCOMPLETE)

┌─────────────────────────────────────────────────────────────┐
│  STOP CONDITIONS (Only 3)                                   │
├─────────────────────────────────────────────────────────────┤
│  1. docs/ directory missing → ABORT                        │
│  2. 3 iterations without 100% → ABORT                       │
│  3. 100% alignment achieved → SUCCESS                       │
└─────────────────────────────────────────────────────────────┘
```

---

## Key Differences from /maintenance:trinity-docs

| Feature | trinity-docs | trinity-docs-update |
|---------|--------------|---------------------|
| **Purpose** | Generate NEW docs from scratch | UPDATE EXISTING docs |
| **docs/ required** | No (creates it) | Yes (ABORT if missing) |
| **Iterations** | Single pass | Up to 3 iterations until 100% |
| **Verification** | Single JUNO verification | Iterative JUNO verification loop |
| **Alignment goal** | Best effort | 100% alignment required |
| **Stop conditions** | Completion | 3 conditions (docs missing, max iterations, 100% aligned) |
| **Context recovery** | Standard | Enhanced with iteration state |

---

## Examples

### Example 1: Successful 100% Alignment (2 iterations)

```
User: /maintenance:trinity-docs-update

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

PHASE 0: Pre-Flight Check

✅ docs/ directory found
✅ Global state initialized

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ITERATION 1 - PHASE 1: JUNO Audit

Scanning existing documentation...
✅ Found 45 documentation files

Scanning codebase for business logic...
✅ Found 67 business logic components

Cross-referencing...
❌ 23 discrepancies found

APO Work Assignment:
- APO-1: 12 base documentation files
- APO-2: 18 tied business logic components
- APO-3: 8 modular components (new docs)

Zero-tolerance check: PASS ✅

Audit report: trinity/reports/DOCS-UPDATE-AUDIT-iteration-1-2026-01-16.md

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ITERATION 1 - PHASE 2: APO Execution

APO-1: Updating 12 base documentation files...
✅ APO-1 complete (12 files updated)

APO-2: Updating 18 business logic docs...
✅ APO-2 complete (18 components updated)

APO-3: Creating 8 new business logic docs...
✅ APO-3 complete (8 new files created)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ITERATION 1 - PHASE 3: JUNO Verification

Verifying alignment...
- Architecture-level: 95% aligned
- Module-level: 88% aligned
- Function-level: 92% aligned

Overall Alignment: 91.67%

❌ Not 100% aligned (7 discrepancies remaining)

Decision: ITERATE (1 of 3 iterations used)

Verification report: trinity/reports/DOCS-UPDATE-VERIFICATION-iteration-1-2026-01-16.md

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ITERATION 2 - PHASE 1: JUNO Audit (Focus on remaining discrepancies)

Re-scanning with focus on 7 identified discrepancies...

APO Work Assignment:
- APO-1: 2 files (fix missing config docs)
- APO-2: 4 components (fix signature mismatches)
- APO-3: 1 component (complete missing sections)

Audit report: trinity/reports/DOCS-UPDATE-AUDIT-iteration-2-2026-01-16.md

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ITERATION 2 - PHASE 2: APO Execution

APO-1: Fixing 2 base docs...
✅ APO-1 complete

APO-2: Fixing 4 component docs...
✅ APO-2 complete

APO-3: Completing 1 component doc...
✅ APO-3 complete

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

ITERATION 2 - PHASE 3: JUNO Verification

Verifying alignment...
- Architecture-level: 100% aligned ✅
- Module-level: 100% aligned ✅
- Function-level: 100% aligned ✅

Overall Alignment: 100% ✅

Decision: PROCEED TO PHASE 4 (100% alignment achieved!)

Verification report: trinity/reports/DOCS-UPDATE-VERIFICATION-iteration-2-2026-01-16.md

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

PHASE 4: Completion

Generating final report...
✅ Final report generated

Moving reports to trinity/sessions/...
✅ 9 reports archived

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✅ SUCCESS: Documentation Update Complete

Final Alignment: 100% ✅
Iterations: 2
Files Updated: 32
New Files Created: 8
Business Logic Documented: 67

Reports archived to: trinity/sessions/

Final report: trinity/sessions/DOCS-UPDATE-COMPLETE-2026-01-16.md
```

---

### Example 2: ABORT - Max Iterations Without 100%

```
[After 3 iterations]

ITERATION 3 - PHASE 3: JUNO Verification

Verifying alignment...
- Architecture-level: 100% aligned ✅
- Module-level: 98% aligned ⚠️
- Function-level: 97% aligned ⚠️

Overall Alignment: 98.33%

❌ Not 100% aligned (3 discrepancies remaining)
❌ Max iterations (3) reached

Decision: ABORT (Max iterations without 100% alignment)

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

PHASE 4: Completion (INCOMPLETE)

⚠️ INCOMPLETE: Documentation Update Reached Max Iterations

Final Alignment: 98.33% (Target: 100%)
Iterations: 3 (max)
Discrepancies Remaining: 3

Remaining Issues:
1. UserService.resetPassword() - missing error case docs
2. OrderService.calculateTotal() - incorrect return type documented
3. PaymentService - missing new processRefund() method

Root Cause: Complex interdependencies require manual resolution

Recommended Actions:
1. Manually review UserService error handling edge cases
2. Fix OrderService return type in code or docs (verify which is correct)
3. Add processRefund() method documentation to PaymentService

Reports archived to: trinity/sessions/

Final report: trinity/sessions/DOCS-UPDATE-COMPLETE-2026-01-16.md
```

---

## Troubleshooting

### Issue: Context Window Exhausted Mid-Execution

**Solution:** Automatic context recovery
1. When resumed, read most recent report's state snapshot
2. Identify current iteration and phase
3. Resume from that phase
4. Continue until stop condition

### Issue: APO Takes Too Long

**Mitigation:**
- Break work into smaller chunks
- Prioritize HIGH severity discrepancies first
- If one APO is blocked, others continue in parallel

### Issue: Discrepancies Keep Appearing

**Root Cause:** Systemic issues in codebase or documentation structure

**Solution:**
- After 3 iterations, ABORT with detailed root cause analysis
- Provide specific recommendations for manual fixes
- User addresses systemic issues, then re-runs command

### Issue: Zero-Tolerance Violation Found

**Action:** ABORT immediately
- Generate report detailing violation
- Do not proceed with updates
- User fixes violation, then re-runs command

---

## Command Complete

This command provides iterative, verified documentation updates that achieve 100% alignment between documentation and codebase reality, or clearly reports why 100% was not achievable after 3 iterations.

**When to use this command:**
- After significant codebase changes
- When documentation drift is suspected
- As part of regular maintenance (quarterly recommended)
- Before major releases to ensure docs are accurate

**When NOT to use this command:**
- If docs/ doesn't exist (use `/maintenance:trinity-docs` first)
- For brand new projects (use `/maintenance:trinity-docs` first)
- If you want to regenerate docs from scratch (use `/maintenance:trinity-docs`)