/**
 * Benchmark Reporter
 *
 * Generates benchmark reports in multiple formats (JSON, Markdown, HTML).
 */

import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join } from 'path';
import { BenchmarkSuite, BenchmarkResult, BenchmarkComparison } from './types';

export class BenchmarkReporter {
  private outputDir: string;

  constructor(outputDir: string = 'trinity/benchmarks') {
    this.outputDir = outputDir;
    this.ensureOutputDir();
  }

  /**
   * Generate all reports for a benchmark suite
   */
  async generateReports(suite: BenchmarkSuite): Promise<void> {
    const timestamp = new Date().toISOString().replace(/:/g, '-').split('.')[0];
    const baseFilename = `${suite.name.replace(/\s+/g, '-').toLowerCase()}-${timestamp}`;

    // Generate JSON report
    const jsonPath = join(this.outputDir, `${baseFilename}.json`);
    this.generateJSON(suite, jsonPath);
    console.log(`\nüìÑ JSON Report: ${jsonPath}`);

    // Generate Markdown report
    const mdPath = join(this.outputDir, `${baseFilename}.md`);
    this.generateMarkdown(suite, mdPath);
    console.log(`üìÑ Markdown Report: ${mdPath}`);

    // Generate summary report (latest.md)
    const summaryPath = join(this.outputDir, 'latest.md');
    this.generateMarkdown(suite, summaryPath);
    console.log(`üìÑ Latest Summary: ${summaryPath}`);
  }

  /**
   * Generate JSON report
   */
  generateJSON(suite: BenchmarkSuite, outputPath: string): void {
    const report = {
      ...suite,
      generatedAt: new Date().toISOString(),
      version: '1.0.0',
    };

    writeFileSync(outputPath, JSON.stringify(report, null, 2), 'utf-8');
  }

  /**
   * Generate Markdown report
   */
  generateMarkdown(suite: BenchmarkSuite, outputPath: string): void {
    const lines: string[] = [];

    // Header
    lines.push(`# ${suite.name}\n`);
    lines.push(`**Generated:** ${new Date(suite.timestamp).toLocaleString()}\n`);
    lines.push(`**Duration:** ${(suite.duration / 1000).toFixed(2)}s\n`);
    lines.push(`---\n`);

    // Summary
    lines.push(`## Summary\n`);
    lines.push(`- **Total Benchmarks:** ${suite.summary.total}`);
    lines.push(`- **Passed:** ${suite.summary.passed} ‚úÖ`);
    lines.push(`- **Failed:** ${suite.summary.failed} ${suite.summary.failed > 0 ? '‚ùå' : ''}`);
    lines.push(`- **Success Rate:** ${((suite.summary.passed / suite.summary.total) * 100).toFixed(1)}%\n`);

    // Key Metrics
    if (Object.keys(suite.summary.metrics).length > 0) {
      lines.push(`## Key Metrics\n`);
      lines.push(`| Metric | Min | Max | Avg | Std Dev |`);
      lines.push(`|--------|-----|-----|-----|---------|`);

      for (const [metric, stats] of Object.entries(suite.summary.metrics)) {
        const min = this.formatMetric(metric, stats.min);
        const max = this.formatMetric(metric, stats.max);
        const avg = this.formatMetric(metric, stats.avg);
        const stdDev = this.formatMetric(metric, stats.stdDev);
        lines.push(`| ${metric} | ${min} | ${max} | ${avg} | ${stdDev} |`);
      }
      lines.push('');
    }

    // Individual Benchmarks
    lines.push(`## Benchmark Results\n`);

    for (const benchmark of suite.benchmarks) {
      const status = benchmark.passed ? '‚úÖ PASS' : '‚ùå FAIL';
      lines.push(`### ${status} - ${benchmark.name}\n`);
      lines.push(`**Description:** ${benchmark.description}\n`);
      lines.push(`**Duration:** ${benchmark.duration}ms`);
      lines.push(`**Iterations:** ${benchmark.iterations}\n`);

      if (benchmark.error) {
        lines.push(`**Error:** \`${benchmark.error}\`\n`);
      }

      // Metrics
      if (Object.keys(benchmark.metrics).length > 0) {
        lines.push(`**Metrics:**\n`);
        for (const [key, value] of Object.entries(benchmark.metrics)) {
          lines.push(`- **${key}:** ${this.formatMetric(key, value)}`);
        }
        lines.push('');
      }

      // Metadata
      if (benchmark.metadata && Object.keys(benchmark.metadata).length > 0) {
        lines.push(`<details>`);
        lines.push(`<summary>Metadata</summary>\n`);
        lines.push('```json');
        lines.push(JSON.stringify(benchmark.metadata, null, 2));
        lines.push('```');
        lines.push(`</details>\n`);
      }

      lines.push(`---\n`);
    }

    // Footer
    lines.push(`\n*Generated by Trinity Method Benchmarking System*`);

    writeFileSync(outputPath, lines.join('\n'), 'utf-8');
  }

  /**
   * Generate comparison report
   */
  generateComparisonMarkdown(
    comparison: BenchmarkComparison,
    outputPath: string
  ): void {
    const lines: string[] = [];

    lines.push(`# Benchmark Comparison\n`);
    lines.push(`**Baseline:** ${comparison.baseline.name} (${comparison.baseline.timestamp})`);
    lines.push(`**Current:** ${comparison.current.name} (${comparison.current.timestamp})\n`);
    lines.push(`---\n`);

    // Summary
    lines.push(`## Summary\n`);
    lines.push(`- **Total Metrics:** ${comparison.summary.totalMetrics}`);
    lines.push(`- **Regressions:** ${comparison.summary.regressions} ${comparison.summary.regressions > 0 ? '‚ö†Ô∏è' : '‚úÖ'}`);
    lines.push(`- **Improvements:** ${comparison.summary.improvements} üìà`);
    lines.push(`- **Neutral:** ${comparison.summary.neutral} ‚û°Ô∏è\n`);

    // Detailed Differences
    lines.push(`## Metric Changes\n`);
    lines.push(`| Metric | Baseline | Current | Diff | Change | Status |`);
    lines.push(`|--------|----------|---------|------|--------|--------|`);

    for (const [metric, diff] of Object.entries(comparison.differences)) {
      const baseline = this.formatMetric(metric, diff.baseline);
      const current = this.formatMetric(metric, diff.current);
      const diffValue = this.formatMetric(metric, diff.diff);
      const percentChange = `${diff.percentChange >= 0 ? '+' : ''}${diff.percentChange.toFixed(1)}%`;
      const status = diff.regression ? '‚ö†Ô∏è Regression' : diff.diff < 0 ? 'üìà Improvement' : '‚û°Ô∏è Neutral';

      lines.push(`| ${metric} | ${baseline} | ${current} | ${diffValue} | ${percentChange} | ${status} |`);
    }
    lines.push('');

    // Regressions (if any)
    if (comparison.summary.regressions > 0) {
      lines.push(`## ‚ö†Ô∏è Regressions Detected\n`);
      const regressions = Object.entries(comparison.differences).filter(([_, diff]) => diff.regression);

      for (const [metric, diff] of regressions) {
        lines.push(`### ${metric}`);
        lines.push(`- **Baseline:** ${this.formatMetric(metric, diff.baseline)}`);
        lines.push(`- **Current:** ${this.formatMetric(metric, diff.current)}`);
        lines.push(`- **Change:** ${diff.percentChange >= 0 ? '+' : ''}${diff.percentChange.toFixed(1)}%\n`);
      }
    }

    writeFileSync(outputPath, lines.join('\n'), 'utf-8');
  }

  /**
   * Generate visualization HTML (simple charts)
   */
  generateVisualization(suite: BenchmarkSuite, outputPath: string): void {
    const html = `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${suite.name} - Benchmark Results</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    body {
      font-family: system-ui, -apple-system, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: #f5f5f5;
    }
    .header {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    .chart-container {
      background: white;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    canvas {
      max-height: 400px;
    }
    .summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    .metric-card {
      background: white;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
    }
    .metric-value {
      font-size: 2em;
      font-weight: bold;
      color: #2563eb;
    }
    .metric-label {
      color: #666;
      margin-top: 5px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>${suite.name}</h1>
    <p><strong>Generated:</strong> ${new Date(suite.timestamp).toLocaleString()}</p>
    <p><strong>Duration:</strong> ${(suite.duration / 1000).toFixed(2)}s</p>
  </div>

  <div class="summary">
    <div class="metric-card">
      <div class="metric-value">${suite.summary.total}</div>
      <div class="metric-label">Total Benchmarks</div>
    </div>
    <div class="metric-card">
      <div class="metric-value" style="color: #10b981">${suite.summary.passed}</div>
      <div class="metric-label">Passed</div>
    </div>
    <div class="metric-card">
      <div class="metric-value" style="color: ${suite.summary.failed > 0 ? '#ef4444' : '#10b981'}">${suite.summary.failed}</div>
      <div class="metric-label">Failed</div>
    </div>
    <div class="metric-card">
      <div class="metric-value">${((suite.summary.passed / suite.summary.total) * 100).toFixed(1)}%</div>
      <div class="metric-label">Success Rate</div>
    </div>
  </div>

  <div class="chart-container">
    <canvas id="metricsChart"></canvas>
  </div>

  <script>
    const data = ${JSON.stringify(suite)};

    // Extract metric averages
    const labels = Object.keys(data.summary.metrics);
    const avgValues = labels.map(label => data.summary.metrics[label].avg);

    new Chart(document.getElementById('metricsChart'), {
      type: 'bar',
      data: {
        labels: labels,
        datasets: [{
          label: 'Average Value',
          data: avgValues,
          backgroundColor: 'rgba(37, 99, 235, 0.5)',
          borderColor: 'rgba(37, 99, 235, 1)',
          borderWidth: 1
        }]
      },
      options: {
        responsive: true,
        plugins: {
          title: {
            display: true,
            text: 'Benchmark Metrics Overview'
          }
        },
        scales: {
          y: {
            beginAtZero: true
          }
        }
      }
    });
  </script>
</body>
</html>
    `.trim();

    writeFileSync(outputPath, html, 'utf-8');
  }

  /**
   * Format metric value with appropriate units
   */
  private formatMetric(metricName: string, value: number | string): string {
    if (typeof value === 'string') return value;

    const name = metricName.toLowerCase();

    if (name.includes('time') || name.includes('duration') || name.includes('ms')) {
      return `${value.toFixed(2)}ms`;
    }

    if (name.includes('rate') || name.includes('percent') || name.includes('accuracy')) {
      return `${value.toFixed(2)}%`;
    }

    if (name.includes('token')) {
      return `${Math.round(value)} tokens`;
    }

    if (name.includes('speedup')) {
      return `${value.toFixed(2)}x`;
    }

    // Default: 2 decimal places
    return value.toFixed(2);
  }

  /**
   * Ensure output directory exists
   */
  private ensureOutputDir(): void {
    if (!existsSync(this.outputDir)) {
      mkdirSync(this.outputDir, { recursive: true });
    }
  }
}
